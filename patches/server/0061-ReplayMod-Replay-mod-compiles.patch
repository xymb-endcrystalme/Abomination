From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Xymb <xymb@endcrystal.me>
Date: Mon, 5 Feb 2024 22:26:01 +0100
Subject: [PATCH] ReplayMod: Replay mod compiles.


diff --git a/build.gradle.kts b/build.gradle.kts
index dcc27d0cf835560c3661c6779797d85c086770f4..df3862e1a746d169177267303290e07851bc7a86 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -19,6 +19,13 @@ dependencies {
         exclude("io.papermc.paper", "paper-api")
     }
     // Folia end
+    // Abomination start - replay mod
+    implementation("com.github.steveice10:packetlib:614d56cdc0")
+    implementation("com.github.viaversion:opennbt:0a02214")
+    implementation("com.github.replaymod.viaversion:viaversion-common:fd4d6b1c8")
+    compileOnly("org.projectlombok:lombok:1.16.6")
+    annotationProcessor("org.projectlombok:lombok:1.18.30")
+    // Abomination end - replay mod
     // Paper start - Add support for io_uring
     implementation("io.netty.incubator:netty-incubator-transport-native-io_uring:0.0.21.Final:linux-x86_64")
     implementation("io.netty.incubator:netty-incubator-transport-native-io_uring:0.0.21.Final:linux-aarch_64")
diff --git a/src/main/java/com/replaymod/replaystudio/PacketData.java b/src/main/java/com/replaymod/replaystudio/PacketData.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7168f527543df997e42bbd6fd97eeee25adbcb6
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/PacketData.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio;
+
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.util.Objects;
+
+/**
+ * Contains packet data. That is the packet itself and its timestamp.
+ */
+public final class PacketData implements Cloneable {
+
+    /**
+     * Timestamp in milliseconds.
+     */
+    private final long time;
+
+    /**
+     * The packet.
+     */
+    private final Packet packet;
+
+    public PacketData(long time, Packet packet) {
+        this.time = time;
+        this.packet = packet;
+    }
+
+    public long getTime() {
+        return this.time;
+    }
+
+    public Packet getPacket() {
+        return this.packet;
+    }
+
+    public PacketData retain() {
+        this.packet.retain();
+        return this;
+    }
+
+    public PacketData copy() {
+        return new PacketData(time, packet.copy());
+    }
+
+    public boolean release() {
+        return this.packet.release();
+    }
+
+    public boolean equals(Object o) {
+        if (o == this) return true;
+        if (!(o instanceof PacketData)) return false;
+        final PacketData other = (PacketData) o;
+        if (this.time != other.time) return false;
+        if (!Objects.equals(this.packet, other.packet)) return false;
+        return true;
+    }
+
+    public int hashCode() {
+        int result = 1;
+        result = result * 59 + (int) (time >>> 32 ^ time);
+        result = result * 59 + (packet == null ? 0 : packet.hashCode());
+        return result;
+    }
+
+    public String toString() {
+        return "PacketData(time=" + this.time + ", packet=" + this.packet + ")";
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/Studio.java b/src/main/java/com/replaymod/replaystudio/Studio.java
new file mode 100644
index 0000000000000000000000000000000000000000..40257c2375f530736ea8c2ba24e5d7c843354e3f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/Studio.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio;
+
+import com.replaymod.replaystudio.filter.StreamFilter;
+
+public interface Studio {
+
+    /**
+     * Returns the name of this implementation.
+     * @return The name
+     */
+    String getName();
+
+    /**
+     * Returns the numerical version of this implementation.
+     * @return Version number
+     */
+    int getVersion();
+
+    /**
+     * Loads a new instance of the specified stream filter.
+     * @param name Name of the stream filter
+     * @return New instance of the stream filter
+     */
+    StreamFilter loadStreamFilter(String name);
+
+    /**
+     * Return whether the specified replay and protocol file version can be read (and if necessary be converted to the
+     * current version) by this Studio implementation.
+     * @param fileVersion The file version
+     * @param protocolVersion The MC protocol version
+     * @param currentVersion The desired MC protocol version
+     * @return {@code true} if the specified version is supported, {@code false} otherwise
+     */
+    boolean isCompatible(int fileVersion, int protocolVersion, int currentVersion);
+
+    /**
+     * Returns the file format version of replay files written with this Studio implementation.
+     * @return The current file format version
+     */
+    int getCurrentFileFormatVersion();
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/data/Marker.java b/src/main/java/com/replaymod/replaystudio/data/Marker.java
new file mode 100644
index 0000000000000000000000000000000000000000..4907614d07b7e36b07a2b085a4465c1459181b2b
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/data/Marker.java
@@ -0,0 +1,142 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.data;
+
+/**
+ * Marks a specific time and position in a replay.
+ */
+public final class Marker {
+    private String name;
+    private int time;
+    private double x, y, z;
+    private float yaw, pitch, roll;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public int getTime() {
+        return time;
+    }
+
+    public void setTime(int time) {
+        this.time = time;
+    }
+
+    public double getX() {
+        return x;
+    }
+
+    public void setX(double x) {
+        this.x = x;
+    }
+
+    public double getY() {
+        return y;
+    }
+
+    public void setY(double y) {
+        this.y = y;
+    }
+
+    public double getZ() {
+        return z;
+    }
+
+    public void setZ(double z) {
+        this.z = z;
+    }
+
+    public float getYaw() {
+        return yaw;
+    }
+
+    public void setYaw(float yaw) {
+        this.yaw = yaw;
+    }
+
+    public float getPitch() {
+        return pitch;
+    }
+
+    public void setPitch(float pitch) {
+        this.pitch = pitch;
+    }
+
+    public float getRoll() {
+        return roll;
+    }
+
+    public void setRoll(float roll) {
+        this.roll = roll;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Marker)) return false;
+
+        Marker marker = (Marker) o;
+
+        if (time != marker.time) return false;
+        if (Double.compare(marker.x, x) != 0) return false;
+        if (Double.compare(marker.y, y) != 0) return false;
+        if (Double.compare(marker.z, z) != 0) return false;
+        if (Float.compare(marker.yaw, yaw) != 0) return false;
+        if (Float.compare(marker.pitch, pitch) != 0) return false;
+        if (Float.compare(marker.roll, roll) != 0) return false;
+        return !(name != null ? !name.equals(marker.name) : marker.name != null);
+    }
+
+    @Override
+    public int hashCode() {
+        int result;
+        long temp;
+        result = name != null ? name.hashCode() : 0;
+        result = 31 * result + time;
+        temp = Double.doubleToLongBits(x);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(y);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        temp = Double.doubleToLongBits(z);
+        result = 31 * result + (int) (temp ^ (temp >>> 32));
+        result = 31 * result + (yaw != +0.0f ? Float.floatToIntBits(yaw) : 0);
+        result = 31 * result + (pitch != +0.0f ? Float.floatToIntBits(pitch) : 0);
+        result = 31 * result + (roll != +0.0f ? Float.floatToIntBits(roll) : 0);
+        return result;
+    }
+
+    @Override
+    public String toString() {
+        return "Marker{" +
+                "name='" + name + '\'' +
+                ", time=" + time +
+                ", x=" + x +
+                ", y=" + y +
+                ", z=" + z +
+                ", yaw=" + yaw +
+                ", pitch=" + pitch +
+                ", roll=" + roll +
+                '}';
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/data/ModInfo.java b/src/main/java/com/replaymod/replaystudio/data/ModInfo.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ef0197cdd296c97f0ce03fccd9c4511b0ecfe81
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/data/ModInfo.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.data;
+
+import lombok.Data;
+
+@Data
+public class ModInfo {
+    private final String id;
+    private final String name;
+    private final String version;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/data/ReplayAssetEntry.java b/src/main/java/com/replaymod/replaystudio/data/ReplayAssetEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..36cd0c18096c5c7000aea037d57f6acb4bca2a6d
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/data/ReplayAssetEntry.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.data;
+
+import java.util.UUID;
+
+public class ReplayAssetEntry {
+    private final UUID uuid;
+    private final String fileExtension;
+    private String name;
+
+    public ReplayAssetEntry(UUID uuid, String fileExtension) {
+        this.uuid = uuid;
+        this.fileExtension = fileExtension;
+    }
+
+    public ReplayAssetEntry(UUID uuid, String fileExtension, String name) {
+        this.uuid = uuid;
+        this.fileExtension = fileExtension;
+        this.name = name;
+    }
+
+    public UUID getUuid() {
+        return uuid;
+    }
+
+    public String getFileExtension() {
+        return fileExtension;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+
+        ReplayAssetEntry that = (ReplayAssetEntry) o;
+
+        return uuid.equals(that.uuid);
+
+    }
+
+    @Override
+    public int hashCode() {
+        return uuid.hashCode();
+    }
+
+    @Override
+    public String toString() {
+        return "ReplayAssetEntry{" +
+                "uuid=" + uuid +
+                ", fileExtension='" + fileExtension + '\'' +
+                ", name='" + name + '\'' +
+                '}';
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/filter/ChangeTimestampFilter.java b/src/main/java/com/replaymod/replaystudio/filter/ChangeTimestampFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..7f7b5782a8cefd0ea9d2fb6cfc30d0d87450619c
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/filter/ChangeTimestampFilter.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.filter;
+
+import com.google.gson.JsonObject;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.stream.PacketStream;
+
+public class ChangeTimestampFilter implements StreamFilter {
+
+    private long offset;
+
+    @Override
+    public String getName() {
+        return "timestamp";
+    }
+
+    @Override
+    public void init(Studio studio, JsonObject config) {
+        offset = config.get("offset").getAsLong();
+    }
+
+    @Override
+    public void onStart(PacketStream stream) {
+
+    }
+
+    @Override
+    public boolean onPacket(PacketStream stream, PacketData data) {
+        stream.insert(new PacketData(data.getTime() + offset, data.getPacket()));
+        return false;
+    }
+
+    @Override
+    public void onEnd(PacketStream stream, long timestamp) {
+
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/filter/DimensionTracker.java b/src/main/java/com/replaymod/replaystudio/filter/DimensionTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..aeb1aba9c350256e2e710567783093d4fe40eb41
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/filter/DimensionTracker.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.filter;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.google.gson.JsonObject;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.packets.PacketJoinGame;
+import com.replaymod.replaystudio.protocol.packets.PacketConfigRegistries;
+import com.replaymod.replaystudio.protocol.packets.PacketRespawn;
+import com.replaymod.replaystudio.protocol.registry.DimensionType;
+import com.replaymod.replaystudio.stream.PacketStream;
+
+import java.io.IOException;
+
+public class DimensionTracker implements StreamFilter {
+
+    public CompoundTag registries;
+    public String dimension;
+    public DimensionType dimensionType;
+
+    @Override
+    public void onStart(PacketStream stream) {
+    }
+
+    @Override
+    public boolean onPacket(PacketStream stream, PacketData data) throws IOException {
+        Packet packet = data.getPacket();
+        PacketType type = packet.getType();
+
+        switch (type) {
+            case ConfigRegistries: {
+                registries = PacketConfigRegistries.read(packet);
+                break;
+            }
+            case Respawn: {
+                PacketRespawn packetRespawn = PacketRespawn.read(packet, registries);
+                dimension = packetRespawn.dimension;
+                dimensionType = packetRespawn.dimensionType;
+                break;
+            }
+            case JoinGame: {
+                PacketJoinGame packetJoinGame = PacketJoinGame.read(packet, registries);
+                registries = packetJoinGame.registries;
+                dimension = packetJoinGame.dimension;
+                dimensionType = packetJoinGame.dimensionType;
+                break;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public void onEnd(PacketStream stream, long timestamp) throws IOException {
+    }
+
+    @Override
+    public String getName() {
+        return "track_dimension";
+    }
+
+    @Override
+    public void init(Studio studio, JsonObject config) {
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/filter/PacketCountFilter.java b/src/main/java/com/replaymod/replaystudio/filter/PacketCountFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a78b4ac7be2e90fee03c865f03c79ba335c572f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/filter/PacketCountFilter.java
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.filter;
+
+import com.google.common.collect.Ordering;
+import com.google.gson.JsonObject;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.stream.PacketStream;
+import org.apache.commons.lang3.mutable.MutableInt;
+
+import java.util.EnumMap;
+import java.util.Map;
+
+public class PacketCountFilter implements StreamFilter {
+
+    private final EnumMap<PacketType, MutableInt> count = new EnumMap<>(PacketType.class);
+
+    @Override
+    public String getName() {
+        return "packet_count";
+    }
+
+    @Override
+    public void init(Studio studio, JsonObject config) {
+
+    }
+
+    @Override
+    public void onStart(PacketStream stream) {
+        count.clear();
+    }
+
+    @Override
+    public boolean onPacket(PacketStream stream, PacketData data) {
+        PacketType type = data.getPacket().getType();
+
+        count.computeIfAbsent(type, key -> new MutableInt()).increment();
+        return true;
+    }
+
+    @Override
+    public void onEnd(PacketStream stream, long timestamp) {
+        System.out.println();
+        System.out.println();
+
+        Ordering<Map.Entry<PacketType, MutableInt>> entryOrdering = Ordering.natural().reverse().onResultOf(Map.Entry::getValue);
+        for (Map.Entry<PacketType, MutableInt> e : entryOrdering.immutableSortedCopy(count.entrySet())) {
+            System.out.println(String.format("[%dx] %s", e.getValue().intValue(), e.getKey().toString()));
+        }
+
+        System.out.println();
+
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/filter/RemoveFilter.java b/src/main/java/com/replaymod/replaystudio/filter/RemoveFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..76b0a2f86188e491285aa7bb1b94d000dd6903e2
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/filter/RemoveFilter.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.filter;
+
+import com.google.gson.JsonObject;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.stream.PacketStream;
+
+import java.util.function.Predicate;
+
+public class RemoveFilter implements StreamFilter {
+
+    private Predicate<PacketData> filter = packetData -> true;
+
+    @Override
+    public String getName() {
+        return "remove";
+    }
+
+    @Override
+    public void init(Studio studio, JsonObject config) {
+        if (config.has("type")) {
+            String name = config.get("type").getAsString();
+            PacketType type = PacketType.valueOf(name);
+            filter = (d) -> d.getPacket().getType() == type;
+        }
+    }
+
+    @Override
+    public void onStart(PacketStream stream) {
+
+    }
+
+    @Override
+    public boolean onPacket(PacketStream stream, PacketData data) {
+        return !filter.test(data);
+    }
+
+    @Override
+    public void onEnd(PacketStream stream, long timestamp) {
+
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/filter/SquashFilter.java b/src/main/java/com/replaymod/replaystudio/filter/SquashFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..47c51f3b2699b9fa32911864ac26be722b76048e
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/filter/SquashFilter.java
@@ -0,0 +1,955 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.filter;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.google.gson.JsonObject;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.protocol.packets.*;
+import com.replaymod.replaystudio.protocol.packets.PacketChunkData.Chunk;
+import com.replaymod.replaystudio.protocol.packets.PacketChunkData.Column;
+import com.replaymod.replaystudio.protocol.registry.DimensionType;
+import com.replaymod.replaystudio.stream.IteratorStream;
+import com.replaymod.replaystudio.stream.PacketStream;
+import com.replaymod.replaystudio.util.DPosition;
+import com.replaymod.replaystudio.util.IPosition;
+import com.replaymod.replaystudio.util.PacketUtils;
+import com.replaymod.replaystudio.util.Utils;
+import org.apache.commons.lang3.tuple.MutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.commons.lang3.tuple.Triple;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import static com.replaymod.replaystudio.util.Utils.within;
+
+public class SquashFilter implements StreamFilter {
+
+    private static final long POS_MIN = Byte.MIN_VALUE;
+    private static final long POS_MAX = Byte.MAX_VALUE;
+
+    private static class Team {
+        private final String name;
+        private Packet create;
+        private Packet update;
+        private Packet remove;
+        private final Set<String> added = new HashSet<>();
+        private final Set<String> removed = new HashSet<>();
+
+        private Team(String name) {
+            this.name = name;
+        }
+
+        public Team copy() {
+            Team copy = new Team(this.name);
+            copy.create = this.create != null ? this.create.copy() : null;
+            copy.update = this.update != null ? this.update.copy() : null;
+            copy.remove = this.remove != null ? this.remove.copy() : null;
+            copy.added.addAll(this.added);
+            copy.removed.addAll(this.removed);
+            return copy;
+        }
+
+        void release() {
+            if (create != null) {
+                create.release();
+                create = null;
+            }
+            if (update != null) {
+                update.release();
+                update = null;
+            }
+            if (remove != null) {
+                remove.release();
+                remove = null;
+            }
+        }
+    }
+
+    private static class Entity {
+        private boolean complete;
+        private boolean despawned;
+        private List<PacketData> packets = new ArrayList<>();
+        private long lastTimestamp = 0;
+        private Packet teleport;
+        private long dx = 0;
+        private long dy = 0;
+        private long dz = 0;
+        private Float yaw = null;
+        private Float pitch = null;
+        private boolean onGround = false; // 1.8+
+
+        Entity copy() {
+            Entity copy = new Entity();
+            copy.complete = this.complete;
+            copy.despawned = this.despawned;
+            this.packets.forEach(it -> copy.packets.add(it.copy()));
+            copy.lastTimestamp = this.lastTimestamp;
+            copy.teleport = this.teleport != null ? this.teleport.copy() : null;
+            copy.dx = this.dx;
+            copy.dy = this.dy;
+            copy.dz = this.dz;
+            copy.yaw = this.yaw;
+            copy.pitch = this.pitch;
+            copy.onGround = this.onGround;
+            return copy;
+        }
+
+        void release() {
+            if (teleport != null) {
+                teleport.release();
+                teleport = null;
+            }
+            packets.forEach(PacketData::release);
+            packets.clear();
+        }
+    }
+
+    private PacketTypeRegistry registry;
+
+    /**
+     * Forge handshake takes place after login phase (i.e. after LoginSuccess) but before JoinGame.
+     * So we still want to include those in the loginPhase list even though they're not technically login phase.
+     */
+    private boolean forgeHandshake;
+    private final List<PacketData> configurationPhase = new ArrayList<>();
+    private final List<PacketData> loginPhase = new ArrayList<>();
+    private final List<PacketData> unhandled = new ArrayList<>();
+    private final Map<Integer, Entity> entities = new HashMap<>();
+    private final Map<String, Team> teams = new HashMap<>();
+    private final Map<Integer, PacketData> mainInventoryChanges = new HashMap<>();
+    private final Map<Integer, Packet> maps = new HashMap<>();
+
+    private final List<PacketData> currentWorld = new ArrayList<>();
+    private final List<PacketData> currentWindow = new ArrayList<>();
+    private final List<PacketData> closeWindows = new ArrayList<>();
+    private final Map<PacketType, PacketData> latestOnly = new HashMap<>();
+
+    private final Map<Long, ChunkData> chunks = new HashMap<>();
+    private final Map<Long, Long> unloadedChunks = new HashMap<>();
+
+    private CompoundTag registries;
+
+    /**
+     * The behavior of the Respawn packet depends on the current world. While vanilla seems to never
+     * make any use of that fact, custom server and proxies do, so we need to take it into consideration.
+     */
+    private String dimension;
+
+    /**
+     * Starting with 1.18, we need to know the height of our dimension to be able to parse a chunk packet.
+     */
+    private DimensionType dimensionType;
+
+    /**
+     * We rely on the timestamps to keep relative packet order. However, by default, two packets may have the same
+     * timestamp, in which case their relative order may be affected by the place in which we store the packet, and that
+     * change may break things (e.g. set block needs to be sent before the corresponding block entity data packet, but
+     * we process them the other way round).
+     * We therefore need to keep track and manually increment the timestamp if it didn't increment by itself. This will
+     * mess with the actual time value but that is not much of an issue because everything will get squashed into a
+     * single moment at the end anyway.
+     */
+    private long prevTimestamp;
+
+    public SquashFilter(CompoundTag registries, String dimension, DimensionType dimensionType) {
+        this.registries = registries;
+        this.dimension = dimension;
+        this.dimensionType = dimensionType;
+    }
+
+    public SquashFilter(DimensionTracker dimensionTracker) {
+        this(dimensionTracker.registries, dimensionTracker.dimension, dimensionTracker.dimensionType);
+    }
+
+    public SquashFilter copy() {
+        SquashFilter copy = new SquashFilter(this.registries, this.dimension, this.dimensionType);
+        copy.registry = this.registry;
+        copy.forgeHandshake = this.forgeHandshake;
+        this.teams.forEach((key, value) -> copy.teams.put(key, value.copy()));
+        this.entities.forEach((key, value) -> copy.entities.put(key, value.copy()));
+        this.configurationPhase.forEach(it -> copy.configurationPhase.add(it.copy()));
+        this.loginPhase.forEach(it -> copy.loginPhase.add(it.copy()));
+        this.unhandled.forEach(it -> copy.unhandled.add(it.copy()));
+        this.mainInventoryChanges.forEach((key, value) -> copy.mainInventoryChanges.put(key, value.copy()));
+        this.maps.forEach((key, value) -> copy.maps.put(key, value.copy()));
+        this.currentWorld.forEach(it -> copy.currentWorld.add(it.copy()));
+        this.currentWindow.forEach(it -> copy.currentWindow.add(it.copy()));
+        this.closeWindows.forEach(it -> copy.closeWindows.add(it.copy()));
+        this.latestOnly.forEach((key, value) -> copy.latestOnly.put(key, value.copy()));
+        this.chunks.forEach((key, value) -> copy.chunks.put(key, value.copy()));
+        copy.unloadedChunks.putAll(this.unloadedChunks);
+        copy.prevTimestamp = this.prevTimestamp;
+        return copy;
+    }
+
+    /**
+     * Flushes all state via {@link #onEnd(PacketStream, long)} and returns the filter to a mostly empty
+     * state such that one can continue to use it for subsequent packets.
+     */
+    private void flush() throws IOException {
+        // Emit all packets
+        List<PacketData> flushedPackets = new ArrayList<>();
+        onEnd(new IteratorStream(flushedPackets.listIterator(), (PacketStream.FilterInfo) null), 0);
+
+        // Store the flushed packets in the login phase list
+        // They aren't technically login phase but like the login phase, they must be emitted first.
+        loginPhase.addAll(flushedPackets);
+    }
+
+    public void release() {
+        teams.values().forEach(Team::release);
+        entities.values().forEach(Entity::release);
+        configurationPhase.forEach(PacketData::release);
+        loginPhase.forEach(PacketData::release);
+        unhandled.forEach(PacketData::release);
+        mainInventoryChanges.values().forEach(PacketData::release);
+        maps.values().forEach(Packet::release);
+        currentWorld.forEach(PacketData::release);
+        currentWindow.forEach(PacketData::release);
+        closeWindows.forEach(PacketData::release);
+        latestOnly.values().forEach(PacketData::release);
+    }
+
+    @Override
+    public void onStart(PacketStream stream) {
+
+    }
+
+    @Override
+    public boolean onPacket(PacketStream stream, PacketData originalData) throws IOException {
+        // Ensure timestamps are strictly increasing; just monotonically increasing is not enough; see prevTimestamp
+        PacketData data = new PacketData(Math.max(originalData.getTime(), prevTimestamp + 1), originalData.getPacket());
+        prevTimestamp = data.getTime();
+
+        Packet packet = data.getPacket();
+        PacketType type = packet.getType();
+        registry = packet.getRegistry();
+        long lastTimestamp = data.getTime();
+
+        // Entities
+        Integer entityId = PacketUtils.getEntityId(packet);
+        if (entityId != null) { // Some entity is associated with this packet
+            if (entityId == -1) { // Multiple entities in fact
+                for (int id : PacketUtils.getEntityIds(packet)) {
+                    Entity entity;
+                    if (type == PacketType.DestroyEntity || type == PacketType.DestroyEntities) {
+                        entity = entities.computeIfAbsent(id, i -> new Entity());
+                        entity.release();
+                        entity.despawned = true;
+                        if (entity.complete) {
+                            entities.remove(id);
+                        }
+                    } else {
+                        entity = entities.compute(id, (i, e) -> e == null || e.despawned ? new Entity() : e);
+                        entity.packets.add(data.retain());
+                    }
+                    entity.lastTimestamp = lastTimestamp;
+                }
+            } else { // Only one entity
+                Entity entity = entities.compute(entityId, (i, e) -> e == null || e.despawned ? new Entity() : e);
+                if (type == PacketType.EntityMovement
+                        || type == PacketType.EntityPosition
+                        || type == PacketType.EntityRotation
+                        || type == PacketType.EntityPositionRotation) {
+                    Triple<DPosition, Pair<Float, Float>, Boolean> movement = PacketEntityMovement.getMovement(packet);
+                    DPosition deltaPos = movement.getLeft();
+                    Pair<Float, Float> yawPitch = movement.getMiddle();
+                    if (deltaPos != null) {
+                        entity.dx += deltaPos.getX() * 32;
+                        entity.dy += deltaPos.getY() * 32;
+                        entity.dz += deltaPos.getZ() * 32;
+                    }
+                    if (yawPitch != null) {
+                        entity.yaw = yawPitch.getKey();
+                        entity.pitch = yawPitch.getValue();
+                    }
+                    entity.onGround = movement.getRight();
+                } else if (type == PacketType.EntityTeleport) {
+                    if (entity.teleport != null) {
+                        entity.teleport.release();
+                    }
+                    entity.dx = entity.dy = entity.dz = 0;
+                    entity.yaw = entity.pitch = null;
+                    entity.teleport = packet.retain();
+                } else {
+                    if (PacketUtils.isSpawnEntityPacket(packet)) {
+                        entity.complete = true;
+                    }
+                    entity.packets.add(data.retain());
+                }
+                entity.lastTimestamp = lastTimestamp;
+            }
+            return false;
+        }
+
+        switch (type) {
+            //
+            // World
+            //
+
+            // Appears to only be used to reset blocks which have speculatively been changed in the client world
+            // and as such should never do anything useful in a a replay.
+            case PlayerActionAck:
+            case SpawnParticle:
+                break;
+            case Respawn: {
+                PacketRespawn packetRespawn = PacketRespawn.read(packet, registries);
+                String newDimension = packetRespawn.dimension;
+                if (dimension == null) {
+                    // We do not know which dimension we are current in, so we cannot know how to handle this packet.
+                    // Instead we flush all state accumulated so far, and then start fresh with the newly
+                    // gained knowledge (so this will only happen once).
+                    flush();
+                } else if (!dimension.equals(newDimension)) {
+                    currentWorld.forEach(PacketData::release);
+                    currentWorld.clear();
+                    chunks.clear();
+                    unloadedChunks.clear();
+                    currentWindow.forEach(PacketData::release);
+                    currentWindow.clear();
+                    entities.values().forEach(Entity::release);
+                    entities.clear();
+                }
+                dimension = newDimension;
+                dimensionType = packetRespawn.dimensionType;
+
+                PacketData prev = this.latestOnly.put(type, data.retain());
+                if (prev != null) {
+                    prev.release();
+                }
+                break;
+            }
+            case JoinGame:
+                currentWorld.forEach(PacketData::release);
+                currentWorld.clear();
+                chunks.clear();
+                unloadedChunks.clear();
+                currentWindow.forEach(PacketData::release);
+                currentWindow.clear();
+                entities.values().forEach(Entity::release);
+                entities.clear();
+                PacketJoinGame packetJoinGame = PacketJoinGame.read(packet, registries);
+                registries = packetJoinGame.registries;
+                dimension = packetJoinGame.dimension;
+                dimensionType = packetJoinGame.dimensionType;
+                forgeHandshake = false;
+            case SetExperience:
+            case PlayerAbilities:
+            case Difficulty:
+            case UpdateViewPosition:
+            case UpdateViewDistance: {
+                PacketData prev = this.latestOnly.put(type, data.retain());
+                if (prev != null) {
+                    prev.release();
+                }
+                break;
+            }
+            case UpdateLight:
+                PacketUpdateLight updateLight = PacketUpdateLight.read(packet);
+                chunks.computeIfAbsent(
+                        ColumnPos.coordToLong(updateLight.getX(), updateLight.getZ()),
+                        idx -> new ChunkData(data.getTime(), updateLight.getX(), updateLight.getZ())
+                ).updateLight(updateLight.getData());
+                break;
+            case ChunkData:
+            case UnloadChunk:
+                PacketChunkData chunkData = PacketChunkData.read(packet, dimensionType.getSections());
+                if (chunkData.isUnload()) {
+                    unloadChunk(data.getTime(), chunkData.getUnloadX(), chunkData.getUnloadZ());
+                } else {
+                    updateChunk(data.getTime(), chunkData.getColumn());
+                }
+                break;
+            case BulkChunkData:
+                for (Column column : PacketChunkData.readBulk(packet)) {
+                    updateChunk(data.getTime(), column);
+                }
+                break;
+            case BlockChange:
+                updateBlock(data.getTime(), PacketBlockChange.read(packet));
+                break;
+            case MultiBlockChange:
+                for (PacketBlockChange change : PacketBlockChange.readBulk(packet)) {
+                    updateBlock(data.getTime(), change);
+                }
+                break;
+            case PlayerPositionRotation:
+            case BlockBreakAnim:
+            case BlockValue:
+            case Explosion:
+            case OpenTileEntityEditor:
+            case PlayEffect:
+            case PlaySound:
+            case SpawnPosition:
+            case UpdateSign:
+            case UpdateTileEntity:
+            case UpdateTime:
+            case WorldBorder:
+            case NotifyClient:
+            case MapData:
+                currentWorld.add(data.retain());
+                break;
+
+            //
+            // Windows
+            //
+
+            case CloseWindow:
+                currentWindow.forEach(PacketData::release);
+                currentWindow.clear();
+                closeWindows.add(data.retain());
+                break;
+            case ConfirmTransaction:
+                break; // This packet isn't of any use in replays
+            case OpenWindow:
+            case TradeList:
+            case WindowProperty:
+                currentWindow.add(data.retain());
+                break;
+            case WindowItems:
+                if (PacketWindowItems.getWindowId(packet) == 0) {
+                    PacketData prev = latestOnly.put(type, data.retain());
+                    if (prev != null) {
+                        prev.release();
+                    }
+                } else {
+                    currentWindow.add(data.retain());
+                }
+                break;
+            case SetSlot:
+                if (PacketSetSlot.getWindowId(packet) == 0) {
+                    PacketData prev = mainInventoryChanges.put(PacketSetSlot.getSlot(packet), data.retain());
+                    if (prev != null) {
+                        prev.release();
+                    }
+                } else {
+                    currentWindow.add(data.retain());
+                }
+                break;
+
+            //
+            // Teams
+            //
+
+            case Team:
+                Team team = teams.computeIfAbsent(PacketTeam.getName(packet), Team::new);
+                switch (PacketTeam.getAction(packet)) {
+                    case CREATE:
+                        if (team.create != null) {
+                            team.create.release();
+                        }
+                        team.create = packet.retain();
+                        break;
+                    case UPDATE:
+                        if (team.update != null) {
+                            team.update.release();
+                        }
+                        team.update = packet.retain();
+                        break;
+                    case REMOVE:
+                        if (team.remove != null) {
+                            team.remove.release();
+                        }
+                        team.remove = packet.retain();
+                        if (team.create != null) {
+                            team.release();
+                            teams.remove(team.name);
+                        }
+                        break;
+                    case ADD_PLAYER:
+                        for (String player : PacketTeam.getPlayers(packet)) {
+                            if (!team.removed.remove(player)) {
+                                team.added.add(player);
+                            }
+                        }
+                        break;
+                    case REMOVE_PLAYER:
+                        for (String player : PacketTeam.getPlayers(packet)) {
+                            if (!team.added.remove(player)) {
+                                team.removed.add(player);
+                            }
+                        }
+                        break;
+                }
+                break;
+
+            //
+            // Misc
+            //
+
+            case ConfigRegistries:
+                registries = PacketConfigRegistries.read(packet);
+                // fallthrough
+            case ConfigTags:
+            case ConfigFeatures:
+                configurationPhase.removeIf(old -> {
+                    if (old.getPacket().getType() == type) {
+                        old.release();
+                        return true;
+                    } else {
+                        return false;
+                    }
+                });
+                configurationPhase.add(data.retain());
+                break;
+
+            default:
+                if (type.getState() == State.CONFIGURATION) {
+                    configurationPhase.add(data.retain());
+                } else if (type.getState() == State.LOGIN || forgeHandshake) {
+                    loginPhase.add(data.retain());
+                    forgeHandshake = true;
+                } else {
+                    unhandled.add(data.retain());
+                }
+        }
+        return false;
+    }
+
+    @Override
+    public void onEnd(PacketStream stream, long timestamp) throws IOException {
+        boolean inBundle = false;
+
+        // If we have any login-phase packets, those need to be sent before regular play-phase ones
+        for (PacketData data : loginPhase) {
+            if (data.getPacket().getType() == PacketType.Bundle) {
+                inBundle = !inBundle;
+            }
+            stream.insert(timestamp, data.getPacket());
+        }
+        loginPhase.clear();
+
+        // If we have a configuration phase, that need to be sent before the regular play phase
+        if (!configurationPhase.isEmpty()) {
+            for (PacketData data : configurationPhase) {
+                stream.insert(timestamp, data.getPacket());
+            }
+            configurationPhase.clear();
+        }
+
+        // Join/respawn packet must be the first packet
+        PacketData join = latestOnly.remove(PacketType.JoinGame);
+        PacketData respawn = latestOnly.remove(PacketType.Respawn);
+        if (join != null) {
+            stream.insert(timestamp, join.getPacket());
+        }
+        if (respawn != null) {
+            stream.insert(timestamp, respawn.getPacket());
+        }
+
+        // These must always come before any chunk packets because otherwise those may get rejected.
+        // Position must come before distance because that one actually unloads chunks.
+        PacketData updateViewPosition = latestOnly.remove(PacketType.UpdateViewPosition);
+        PacketData updateViewDistance = latestOnly.remove(PacketType.UpdateViewDistance);
+        if (updateViewPosition != null) {
+            stream.insert(timestamp, updateViewPosition.getPacket());
+        }
+        if (updateViewDistance != null) {
+            stream.insert(timestamp, updateViewDistance.getPacket());
+        }
+
+        List<PacketData> result = new ArrayList<>();
+
+        result.addAll(unhandled);
+        result.addAll(currentWorld);
+        result.addAll(currentWindow);
+        result.addAll(closeWindows);
+        result.addAll(mainInventoryChanges.values());
+        result.addAll(latestOnly.values());
+        unhandled.clear();
+        currentWorld.clear();
+        currentWindow.clear();
+        closeWindows.clear();
+        mainInventoryChanges.clear();
+        latestOnly.clear();
+
+        for (Map.Entry<Integer, Entity> e : entities.entrySet()) {
+            Entity entity = e.getValue();
+
+            if (entity.despawned) {
+                result.add(new PacketData(entity.lastTimestamp, PacketDestroyEntities.write(registry, e.getKey())));
+                entity.release();
+                continue;
+            }
+
+            FOR_PACKETS:
+            for (PacketData data : entity.packets) {
+                Packet packet = data.getPacket();
+                for (int i : PacketUtils.getEntityIds(packet)) {
+                    Entity other = entities.get(i);
+                    if (other == null || other.despawned) { // Other entity doesn't exist
+                        packet.release();
+                        continue FOR_PACKETS;
+                    }
+                }
+                result.add(data);
+            }
+
+            if (entity.teleport != null) {
+                result.add(new PacketData(entity.lastTimestamp, entity.teleport));
+            }
+            while (entity.dx != 0 || entity.dy != 0 || entity.dz != 0) {
+                long mx = within(entity.dx, POS_MIN, POS_MAX);
+                long my = within(entity.dy, POS_MIN, POS_MAX);
+                long mz = within(entity.dz, POS_MIN, POS_MAX);
+                entity.dx -= mx;
+                entity.dy -= my;
+                entity.dz -= mz;
+                DPosition deltaPos = new DPosition(mx / 32.0, my / 32.0, mz / 32.0);
+                result.add(new PacketData(entity.lastTimestamp, PacketEntityMovement.write(
+                        registry, e.getKey(), deltaPos, null, entity.onGround)));
+            }
+            if (entity.yaw != null && entity.pitch != null) {
+                result.add(new PacketData(entity.lastTimestamp, PacketEntityMovement.write(
+                        registry, e.getKey(), null, Pair.of(entity.yaw, entity.pitch), entity.onGround)));
+            }
+        }
+        entities.clear();
+
+        for (Map.Entry<Long, Long> e : unloadedChunks.entrySet()) {
+            int x = ColumnPos.longToX(e.getKey());
+            int z = ColumnPos.longToZ(e.getKey());
+            result.add(new PacketData(e.getValue(), PacketChunkData.unload(x, z).write(registry)));
+        }
+
+        for (ChunkData chunk : chunks.values()) {
+            PacketUpdateLight.Data lightData = new PacketUpdateLight.Data(
+                    Arrays.asList(chunk.skyLight),
+                    Arrays.asList(chunk.blockLight)
+            );
+            Column column = new Column(
+                    chunk.x, chunk.z, chunk.changes,
+                    chunk.biomeData, chunk.tileEntities, chunk.heightmaps, chunk.biomes, chunk.useExistingLightData,
+                    lightData
+            );
+            if (column.isFull() || !Utils.containsOnlyNull(chunk.changes)) {
+                result.add(new PacketData(chunk.firstAppearance, PacketChunkData.load(column).write(registry)));
+            }
+            for (Map<Short, MutablePair<Long, PacketBlockChange>> e : chunk.blockChanges) {
+                if (e != null) {
+                    for (MutablePair<Long, PacketBlockChange> pair : e.values()) {
+                        result.add(new PacketData(pair.getLeft(), pair.getRight().write(registry)));
+                    }
+                }
+            }
+            for (MutablePair<Long, PacketBlockChange> pair : chunk.allBlockChanges.values()) {
+                result.add(new PacketData(pair.getLeft(), pair.getRight().write(registry)));
+            }
+            if (chunk.hasLight() && registry.olderThan(ProtocolVersion.v1_18)) {
+                result.add(new PacketData(chunk.firstAppearance,
+                        new PacketUpdateLight(chunk.x, chunk.z, lightData).write(registry)));
+            }
+        }
+        chunks.clear();
+
+        result.sort(Comparator.comparingLong(PacketData::getTime));
+
+        PacketData pendingBundle = null;
+        for (PacketData data : result) {
+            if (data.getPacket().getType() == PacketType.Bundle) {
+                if (inBundle) {
+                    inBundle = false;
+                } else {
+                    // If the bundle was just opened and is already being closed without any packets in it, drop it
+                    if (pendingBundle != null) {
+                        pendingBundle.release();
+                        pendingBundle = null;
+                        data.release();
+                        continue;
+                    }
+                    pendingBundle = data;
+                    continue;
+                }
+            } else if (pendingBundle != null) {
+                add(stream, timestamp, pendingBundle.getPacket());
+                pendingBundle = null;
+                inBundle = true;
+            }
+
+            add(stream, timestamp, data.getPacket());
+        }
+        if (pendingBundle != null) {
+            add(stream, timestamp, pendingBundle.getPacket());
+        }
+
+        for (Team team : teams.values()) {
+            if (team.create != null) {
+                add(stream, timestamp, team.create);
+            }
+            if (team.update != null) {
+                add(stream, timestamp, team.update);
+            }
+            if (team.remove != null) {
+                add(stream, timestamp, team.remove);
+            } else {
+                if (!team.added.isEmpty()) {
+                    add(stream, timestamp, PacketTeam.addPlayers(registry, team.name, team.added));
+                }
+                if (!team.removed.isEmpty()) {
+                    add(stream, timestamp, PacketTeam.removePlayers(registry, team.name, team.removed));
+                }
+            }
+        }
+        teams.clear();
+
+        for (Packet packet : maps.values()) {
+            add(stream, timestamp, packet);
+        }
+        maps.clear();
+    }
+
+    @Override
+    public String getName() {
+        return "squash";
+    }
+
+    @Override
+    public void init(Studio studio, JsonObject config) {
+    }
+
+    private void add(PacketStream stream, long timestamp, Packet packet) {
+        stream.insert(new PacketData(timestamp, packet));
+    }
+
+    private void updateBlock(long time, PacketBlockChange record) {
+        IPosition pos = record.getPosition();
+        chunks.computeIfAbsent(
+                ColumnPos.coordToLong(pos.getX() >> 4, pos.getZ() >> 4),
+                idx -> new ChunkData(time, pos.getX() >> 4, pos.getZ() >> 4)
+        ).updateBlock(time, record);
+    }
+
+    private void unloadChunk(long time, int x, int z) {
+        long coord = ColumnPos.coordToLong(x, z);
+        chunks.remove(coord);
+        unloadedChunks.put(coord, time);
+    }
+
+    private void updateChunk(long time, Column column) {
+        long coord = ColumnPos.coordToLong(column.x, column.z);
+        unloadedChunks.remove(coord);
+        ChunkData chunk = chunks.get(coord);
+        if (chunk == null) {
+            chunks.put(coord, chunk = new ChunkData(time, column.x, column.z));
+        }
+        chunk.update(
+                column.chunks,
+                column.biomeData,
+                column.tileEntities,
+                column.heightMaps,
+                column.biomes,
+                column.useExistingLightData
+        );
+        if (column.lightData != null) { // 1.18+
+            chunk.updateLight(column.lightData);
+        }
+    }
+
+    private class ChunkData {
+        private final long firstAppearance;
+        private final int x;
+        private final int z;
+        private Chunk[] changes = new Chunk[0];
+        private byte[] biomeData; // pre 1.15
+        // We store block changes per chunk so we can easily clear them when we see a partial chunk update.
+        // This no longer applies to 1.17 cause MC no longer supports partial chunk updates, so instead we just
+        // clear everything. This has the added bonus that we do not need to be aware of the world y to index mapping.
+        @SuppressWarnings("unchecked")
+        private Map<Short, MutablePair<Long, PacketBlockChange>>[] blockChanges = new Map[16]; // pre 1.17
+        private final Map<Integer, MutablePair<Long, PacketBlockChange>> allBlockChanges = new HashMap<>(); // 1.17+
+        // 1.9+
+        private PacketChunkData.TileEntity[] tileEntities;
+        // 1.14+
+        private CompoundTag heightmaps;
+        private byte[][] skyLight = new byte[0][];
+        private byte[][] blockLight = new byte[0][];
+        // 1.15+
+        private int[] biomes;
+        // 1.16+
+        private boolean useExistingLightData = true;
+
+         ChunkData(long firstAppearance, int x, int z) {
+            this.firstAppearance = firstAppearance;
+            this.x = x;
+            this.z = z;
+        }
+
+        ChunkData copy() {
+            ChunkData copy = new ChunkData(this.firstAppearance, this.x, this.z);
+            copy.changes = new Chunk[this.changes.length];
+            for (int i = 0; i < this.changes.length; i++) {
+                copy.changes[i] = this.changes[i] != null ? this.changes[i].copy() : null;
+            }
+            copy.biomeData = this.biomeData;
+            for (int i = 0; i < this.blockChanges.length; i++) {
+                if (this.blockChanges[i] != null) {
+                    Map<Short, MutablePair<Long, PacketBlockChange>> copyMap = new HashMap<>();
+                    copy.blockChanges[i] = copyMap;
+                    this.blockChanges[i].forEach((key, value) -> copyMap.put(key, new MutablePair<>(value.left, value.right)));
+                }
+            }
+            this.allBlockChanges.forEach((key, value) -> copy.allBlockChanges.put(key, new MutablePair<>(value.left, value.right)));
+            copy.tileEntities = this.tileEntities;
+            copy.heightmaps = this.heightmaps;
+            copy.skyLight = this.skyLight.clone();
+            copy.blockLight = this.blockLight.clone();
+            copy.biomes = this.biomes;
+            copy.useExistingLightData = this.useExistingLightData;
+            return copy;
+        }
+
+        void update(
+                Chunk[] newChunks,
+                byte[] newBiomeData, // pre 1.15
+                PacketChunkData.TileEntity[] newTileEntities, // 1.9+
+                CompoundTag newHeightmaps, // 1.14+
+                int[] newBiomes, // 1.15+
+                boolean useExistingLightData // 1.16+
+        ) {
+            if (changes.length < newChunks.length) {
+                changes = Arrays.copyOf(changes, newChunks.length);
+            }
+            for (int i = 0; i < newChunks.length; i++) {
+                if (newChunks[i] != null) {
+                    changes[i] = newChunks[i];
+                    if (registry.olderThan(ProtocolVersion.v1_17)) {
+                        blockChanges[i] = null;
+                    }
+                }
+            }
+            allBlockChanges.clear();
+
+            if (newBiomeData != null) { // pre 1.15
+                this.biomeData = newBiomeData;
+            }
+            if (newTileEntities != null) { // 1.9+
+                this.tileEntities = newTileEntities;
+            }
+            if (newHeightmaps != null) { // 1.14+
+                this.heightmaps = newHeightmaps;
+            }
+            if (newBiomes != null) { // 1.15+
+                this.biomes = newBiomes;
+            }
+            if (!useExistingLightData) { // 1.16+
+                this.useExistingLightData = false;
+            }
+        }
+
+        private void updateLight(PacketUpdateLight.Data data) { // 1.14+
+            List<byte[]> skyLightUpdates = data.skyLight;
+            List<byte[]> blockLightUpdates = data.blockLight;
+
+            if (skyLight.length < skyLightUpdates.size()) {
+                skyLight = Arrays.copyOf(skyLight, skyLightUpdates.size());
+            }
+
+            if (blockLight.length < blockLightUpdates.size()) {
+                blockLight = Arrays.copyOf(blockLight, blockLightUpdates.size());
+            }
+
+            int i = 0;
+            for (byte[] light : skyLightUpdates) {
+                if (light != null) {
+                    skyLight[i] = light;
+                }
+                i++;
+            }
+            i = 0;
+            for (byte[] light : blockLightUpdates) {
+                if (light != null) {
+                    blockLight[i] = light;
+                }
+                i++;
+            }
+        }
+
+        private boolean hasLight() { // 1.14+
+            for (byte[] light : skyLight) {
+                if (light != null) {
+                    return true;
+                }
+            }
+            for (byte[] light : blockLight) {
+                if (light != null) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        private MutablePair<Long, PacketBlockChange> blockChanges(IPosition pos) {
+            int x = pos.getX();
+            int y = pos.getY();
+            int chunkY = y / 16;
+            int z = pos.getZ();
+            if (registry.atLeast(ProtocolVersion.v1_17)) {
+                int index = y << 10 | (x & 15) << 5 | (z & 15);
+                return allBlockChanges.computeIfAbsent(index, k -> MutablePair.of(0L, null));
+            } else {
+                if (chunkY < 0 || chunkY >= blockChanges.length) {
+                    return null;
+                }
+                if (blockChanges[chunkY] == null) {
+                    blockChanges[chunkY] = new HashMap<>();
+                }
+                short index = (short) ((x & 15) << 10 | (y & 15) << 5 | (z & 15));
+                return blockChanges[chunkY].computeIfAbsent(index, k -> MutablePair.of(0L, null));
+            }
+        }
+
+        void updateBlock(long time, PacketBlockChange change) {
+            MutablePair<Long, PacketBlockChange> pair = blockChanges(change.getPosition());
+            if (pair != null && pair.getLeft() <= time) {
+                pair.setLeft(time);
+                pair.setRight(change);
+            }
+        }
+    }
+
+    private static class ColumnPos {
+        private static long coordToLong(int x, int z) {
+            return (long) x << 32 | z & 0xFFFFFFFFL;
+        }
+
+        private static int longToX(long coord) {
+            return (int) (coord >> 32);
+        }
+
+        private static int longToZ(long coord) {
+            return (int) (coord & 0xFFFFFFFFL);
+        }
+    }
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/filter/StreamFilter.java b/src/main/java/com/replaymod/replaystudio/filter/StreamFilter.java
new file mode 100644
index 0000000000000000000000000000000000000000..0a7bbf44790b30170ccecf7d378ac06067375400
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/filter/StreamFilter.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.filter;
+
+import com.google.gson.JsonObject;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.stream.PacketStream;
+
+import java.io.IOException;
+
+/**
+ * A manipulation that applies some effect onto the supplied packet stream on the fly.
+ */
+public interface StreamFilter {
+
+    /**
+     * Returns a unique but simple name for this filter. This name is used when referring to the filter
+     * in configs and in {@link Studio#loadStreamFilter(String)}.
+     * It may not contain whitespace or special characters except underscores.
+     * It should be all lowercase, however this is not a requirement.
+     * @return Name of this filter
+     */
+    String getName();
+
+    /**
+     * Initializes this filter.
+     * Read the configuration of this filter from the supplied json.
+     * This can be called multiple times.
+     */
+    void init(Studio studio, JsonObject config);
+
+    /**
+     * Called at the beginning of a new stream.
+     * @param stream The stream of packets
+     */
+    void onStart(PacketStream stream) throws IOException;
+
+    /**
+     * Called for each packet traversing the stream.
+     * @param stream The stream
+     * @param data The packet
+     * @return {@code true} if the packet should remain in the stream, {@code false} if it should be removed
+     */
+    boolean onPacket(PacketStream stream, PacketData data) throws IOException;
+
+    /**
+     * Called at the end of a stream.
+     * @param stream The stream of packets
+     * @param timestamp The current time int this stream in milliseconds
+     */
+    void onEnd(PacketStream stream, long timestamp) throws IOException;
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/io/ReplayInputStream.java b/src/main/java/com/replaymod/replaystudio/io/ReplayInputStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..97622c82f35a6679c64f3d65ed6c230e4804552a
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/io/ReplayInputStream.java
@@ -0,0 +1,235 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.io;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.PooledByteBufAllocator;
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetInput;
+import com.replaymod.replaystudio.PacketData;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.protocol.packets.PacketJoinGame;
+import com.replaymod.replaystudio.protocol.packets.PacketLoginSuccess;
+import com.replaymod.replaystudio.protocol.packets.PacketConfigRegistries;
+import com.replaymod.replaystudio.replay.ReplayMetaData;
+import com.replaymod.replaystudio.stream.PacketStream;
+import com.replaymod.replaystudio.studio.StudioPacketStream;
+import com.replaymod.replaystudio.viaversion.ViaVersionPacketConverter;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.util.ArrayDeque;
+import java.util.Collections;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Queue;
+import java.util.UUID;
+
+import static com.replaymod.replaystudio.util.Utils.readInt;
+
+/**
+ * Input stream for reading packet data.
+ */
+public class ReplayInputStream extends InputStream {
+
+    private static final ByteBufAllocator ALLOC = PooledByteBufAllocator.DEFAULT;
+
+    private PacketTypeRegistry rawRegistry;
+    private PacketTypeRegistry registry;
+    private CompoundTag mcRegistries; // 1.20.2+
+
+    /**
+     * The actual input stream.
+     */
+    private final InputStream in;
+
+    /**
+     * The instance of the ViaVersion packet converter in use.
+     */
+    private ViaVersionPacketConverter viaVersionConverter;
+
+    /**
+     * Whether the packet stream (at the head of the input stream, not any already buffered packets) is currently
+     * in the login phase.
+     */
+    private boolean loginPhase;
+
+    /**
+     * Whether login phase packets are returned from the stream (otherwise they'll be silently dropped for backwards compatibility).
+     */
+    private boolean outputLoginPhase;
+
+    /**
+     * Packets which have already been read from the input but have not yet been requested via {@link #readPacket()}.
+     */
+    private Queue<PacketData> buffer = new ArrayDeque<>();
+
+    /**
+     * Creates a new replay input stream for reading raw packet data.
+     * @param registry The registry used for the first packet produced.
+     *                 Further packets may be using a registry for the same version but PLAY state instead.
+     *                 Should generally start in LOGIN state, even if the file doesn't not include the LOGIN phase,
+     *                 the ReplayInputStream will handle it.
+     * @param in The actual input stream.
+     * @param fileFormatVersion The file format version of the replay packet data
+     * @param fileProtocol The MC protocol version of the replay packet data
+     */
+    public ReplayInputStream(PacketTypeRegistry registry, InputStream in, int fileFormatVersion, int fileProtocol) throws IOException {
+        boolean includeLoginPhase = fileFormatVersion >= 14;
+        this.registry = registry;
+        this.loginPhase = includeLoginPhase;
+        this.outputLoginPhase = registry.getState() == State.LOGIN;
+        if (!includeLoginPhase && outputLoginPhase) {
+            // For Replays older than version 14, immediately end the Login phase to enter Play phase where the replay starts
+            buffer.offer(new PacketData(0, new PacketLoginSuccess(UUID.nameUUIDFromBytes(new byte[0]), "Player", Collections.emptyList()).write(registry)));
+            this.registry = PacketTypeRegistry.get(registry.getVersion(), State.PLAY);
+        } else if (includeLoginPhase && !outputLoginPhase) {
+            this.registry = PacketTypeRegistry.get(registry.getVersion(), State.LOGIN);
+        }
+        this.in = in;
+        this.viaVersionConverter = ViaVersionPacketConverter.createForFileVersion(fileFormatVersion, fileProtocol, registry.getVersion().getOriginalVersion());
+        this.rawRegistry = PacketTypeRegistry.get(ReplayMetaData.getProtocolVersion(fileFormatVersion, fileProtocol), this.registry.getState());
+
+        if (rawRegistry.atLeast(ProtocolVersion.v1_20_2) && rawRegistry.getState() == State.PLAY) {
+            throw new IllegalArgumentException("Cannot go directly to PLAY phase on 1.20.2+, only LOGIN and CONFIGURATION are valid.");
+        }
+    }
+
+    @Override
+    public int read() throws IOException {
+        return in.read();
+    }
+
+    @Override
+    public void close() throws IOException {
+        in.close();
+    }
+
+    public PacketTypeRegistry getRegistry() {
+        return registry;
+    }
+
+    /**
+     * Read the next packet from this input stream.
+     * @return The packet
+     * @throws IOException if an I/O error occurs.
+     */
+    public PacketData readPacket() throws IOException {
+        fillBuffer();
+        return buffer.poll();
+    }
+
+    private void fillBuffer() throws IOException {
+        while (buffer.isEmpty()) {
+            int next = readInt(in);
+            int length = readInt(in);
+            if (next == -1 || length == -1) {
+                break; // reached end of stream
+            }
+            if (length == 0) {
+                continue; // skip empty segments
+            }
+
+            ByteBuf buf = ALLOC.buffer(length);
+            while (length > 0) {
+                int read = buf.writeBytes(in, length);
+                if (read == -1) {
+                    throw new EOFException();
+                }
+                length -= read;
+            }
+
+            int rawPacketId = new ByteBufNetInput(buf).readVarInt();
+            Packet rawPacket = new Packet(rawRegistry, rawPacketId, buf);
+            switch (rawPacket.getType()) {
+                case LoginSuccess:
+                    rawRegistry = rawRegistry.withLoginSuccess();
+                    break;
+                case Reconfigure:
+                    rawRegistry = rawRegistry.withState(State.CONFIGURATION);
+                    break;
+                case ConfigRegistries:
+                    mcRegistries = PacketConfigRegistries.read(rawPacket);
+                    break;
+                case ConfigFinish:
+                    rawRegistry = rawRegistry.withState(State.PLAY);
+                    break;
+                case JoinGame:
+                    PacketJoinGame joinGame = PacketJoinGame.read(rawPacket, mcRegistries);
+                    joinGame.entityId = -1789435; // arbitrary negative value
+                    joinGame.gameMode = 3; // Spectator
+                    try (Packet.Writer writer = rawPacket.overwrite()) {
+                        joinGame.write(rawPacket, writer);
+                    }
+                    break;
+            }
+
+            buf.resetReaderIndex();
+
+            List<Packet> decoded = new LinkedList<>();
+            try {
+                for (ByteBuf packet : viaVersionConverter.convertPacket(buf, rawPacket.getType().getState())) {
+                    int packetId = new ByteBufNetInput(packet).readVarInt();
+                    decoded.add(new Packet(registry, packetId, registry.getType(packetId), packet));
+                }
+            } catch (Exception e) {
+                throw e instanceof IOException ? (IOException) e : new IOException("decoding", e);
+            }
+            buf.release();
+
+            for (Packet packet : decoded) {
+                PacketType type = packet.getType();
+                if (type == PacketType.KeepAlive) {
+                    packet.release();
+                    continue; // They aren't needed in a replay
+                }
+
+                if (type == PacketType.LoginSuccess) {
+                    loginPhase = false;
+                    registry = registry.withLoginSuccess();
+                }
+                if ((loginPhase || type == PacketType.LoginSuccess) && !outputLoginPhase) {
+                    packet.release();
+                    continue;
+                }
+                if (type == PacketType.ConfigFinish) {
+                    registry = registry.withState(State.PLAY);
+                }
+                if (type == PacketType.Reconfigure) {
+                    registry = registry.withState(State.CONFIGURATION);
+                }
+                buffer.offer(new PacketData(next, packet));
+            }
+        }
+    }
+
+    /**
+     * Wraps this {@link ReplayInputStream} into a {@link PacketStream}.
+     * Closing the replay input stream will close the packet stream and vice versa.
+     */
+    public PacketStream asPacketStream() {
+        return new StudioPacketStream(this);
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/io/ReplayOutputStream.java b/src/main/java/com/replaymod/replaystudio/io/ReplayOutputStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..f9670edd2398584c925762607e2557278c765da9
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/io/ReplayOutputStream.java
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.io;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.PooledByteBufAllocator;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetOutput;
+import com.google.gson.Gson;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.Studio;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.protocol.packets.PacketLoginSuccess;
+import com.replaymod.replaystudio.replay.ReplayMetaData;
+import com.replaymod.replaystudio.studio.ReplayStudio;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.util.Collections;
+import java.util.UUID;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipOutputStream;
+
+import static com.replaymod.replaystudio.util.Utils.writeInt;
+
+/**
+ * Output stream capable of writing {@link Packet}s and (optionally)
+ * {@link ReplayMetaData}.
+ */
+public class ReplayOutputStream extends OutputStream {
+
+    private static final Gson GSON = new Gson();
+    private static final ByteBufAllocator ALLOC = PooledByteBufAllocator.DEFAULT;
+
+    /**
+     * Meta data for the current replay. Gets written after all packets are written.
+     */
+    private final ReplayMetaData metaData;
+
+    /**
+     * The actual output stream.
+     * If we write to a ZIP output stream, this is the same as {@link #zipOut}.
+     */
+    private final OutputStream out;
+
+    /**
+     * If we write to a ZIP output stream instead of just raw data, this holds a reference to that output stream.
+     */
+    private final ZipOutputStream zipOut;
+
+    /**
+     * Duration of the replay written. This gets updated with each packet and is afterwards used to set the
+     * duration in the replay meta data.
+     */
+    private int duration;
+
+    private boolean loginPhase = true;
+
+    /**
+     * Creates a new replay output stream which will not compress packets written to it nor write any meta data.
+     * The resulting output can be read directly by a {@link ReplayInputStream}.
+     * @param out The actual output stream
+     */
+    public ReplayOutputStream(OutputStream out) {
+        this.out = out;
+        this.zipOut = null;
+        this.metaData = null;
+    }
+
+    /**
+     * Creates a new replay output stream which will write its packets and the specified meta data
+     * in a zip output stream according to the MCPR format.
+     *
+     * @param out The actual output stream
+     * @param metaData The meta data written to the output
+     * @throws IOException If an exception occurred while writing the first entry to the zip output stream
+     */
+    public ReplayOutputStream(ProtocolVersion version, OutputStream out, ReplayMetaData metaData) throws IOException {
+        Studio studio = new ReplayStudio();
+        if (metaData == null) {
+            metaData = new ReplayMetaData();
+            metaData.setSingleplayer(false);
+            metaData.setServerName(studio.getName() + " v" + studio.getVersion());
+            metaData.setDate(System.currentTimeMillis());
+        }
+        metaData.setFileFormat("MCPR");
+        metaData.setFileFormatVersion(ReplayMetaData.CURRENT_FILE_FORMAT_VERSION);
+        metaData.setProtocolVersion(version.getOriginalVersion());
+        metaData.setGenerator("ReplayStudio v" + studio.getVersion());
+        this.metaData = metaData;
+
+        this.out = zipOut = new ZipOutputStream(out);
+
+        zipOut.putNextEntry(new ZipEntry("recording.tmcpr"));
+
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        out.write(b);
+    }
+
+    /**
+     * Writes the specified packet data to the underlying output stream.
+     * @param data The packet data
+     * @throws IOException - if an I/O error occurs.
+     *      In particular, an IOException may be thrown if the output stream has been closed.
+     * @see #write(long, Packet)
+     */
+    public void write(PacketData data) throws IOException {
+        write(data.getTime(), data.getPacket());
+    }
+
+    /**
+     * Writes the specified packet data to the underlying output stream.
+     * @param time The timestamp
+     * @param packet The packet
+     * @throws IOException - if an I/O error occurs.
+     *      In particular, an IOException may be thrown if the output stream has been closed.
+     * @see #write(PacketData)
+     */
+    public void write(long time, Packet packet) throws IOException {
+        if (packet.getRegistry().getState() != State.LOGIN && loginPhase) {
+            PacketTypeRegistry registry = PacketTypeRegistry.get(packet.getProtocolVersion(), State.LOGIN);
+            doWrite(0, new PacketLoginSuccess(UUID.nameUUIDFromBytes(new byte[0]), "Player", Collections.emptyList()).write(registry));
+        }
+        doWrite(time, packet);
+    }
+
+    private void doWrite(long time, Packet packet) throws IOException {
+        if (duration < time) {
+            duration = (int) time;
+        }
+
+        ByteBuf packetIdBuf = ALLOC.buffer();
+        try {
+            new ByteBufNetOutput(packetIdBuf).writeVarInt(packet.getId());
+
+            int packetIdLen = packetIdBuf.readableBytes();
+            int packetBufLen = packet.getBuf().readableBytes();
+            writeInt(out, (int) time);
+            writeInt(out, packetIdLen + packetBufLen);
+            packetIdBuf.readBytes(out, packetIdLen);
+            packet.getBuf().getBytes(packet.getBuf().readerIndex(), out, packetBufLen);
+        } finally {
+            packetIdBuf.release();
+            packet.getBuf().release();
+        }
+
+        if (packet.getType() == PacketType.LoginSuccess) {
+            loginPhase = false;
+        }
+    }
+
+    /**
+     * Starts a new entry in this replay zip file.
+     * The previous entry is therefore closed.
+     * @param name Name of the new entry
+     */
+    public void nextEntry(String name) throws IOException {
+        if (zipOut != null) {
+            zipOut.closeEntry();
+            zipOut.putNextEntry(new ZipEntry(name));
+        } else {
+            throw new UnsupportedOperationException("Cannot start new entry when writing raw replay output.");
+        }
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (zipOut != null) {
+            zipOut.closeEntry();
+
+            metaData.setDuration(duration);
+            zipOut.putNextEntry(new ZipEntry("metaData.json"));
+            zipOut.write(GSON.toJson(metaData).getBytes());
+            zipOut.closeEntry();
+        }
+        out.close();
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/PathingRegistry.java b/src/main/java/com/replaymod/replaystudio/pathing/PathingRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..557c6578eea385b0c58d2ab9eaaeea36f9c52301
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/PathingRegistry.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing;
+
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+
+import java.io.IOException;
+
+/**
+ * Contains mappings required for serialization.
+ */
+public interface PathingRegistry {
+    Timeline createTimeline();
+    void serializeInterpolator(JsonWriter writer, Interpolator interpolator) throws IOException;
+    Interpolator deserializeInterpolator(JsonReader reader) throws IOException;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/AddInterpolatorProperty.java b/src/main/java/com/replaymod/replaystudio/pathing/change/AddInterpolatorProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..ad018ce692137334254f7ffebdc88830cd6827ef
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/AddInterpolatorProperty.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+import lombok.NonNull;
+
+/**
+ * Adds a new property.
+ */
+public final class AddInterpolatorProperty implements Change {
+    @NonNull
+    public static AddInterpolatorProperty create(Interpolator interpolator, Property property) {
+        return new AddInterpolatorProperty(interpolator, property);
+    }
+
+    AddInterpolatorProperty(Interpolator interpolator, Property property) {
+        this.interpolator = interpolator;
+        this.property = property;
+    }
+
+    private final Interpolator interpolator;
+
+    private final Property property;
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        interpolator.registerProperty(property);
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        interpolator.unregisterProperty(property);
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/AddKeyframe.java b/src/main/java/com/replaymod/replaystudio/pathing/change/AddKeyframe.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b12d06f9df85750a2358857f10348bf70866e1a
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/AddKeyframe.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Predicates;
+import com.google.common.collect.Iterables;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import lombok.NonNull;
+
+/**
+ * Adds a new property.
+ */
+public final class AddKeyframe implements Change {
+    @NonNull
+    public static AddKeyframe create(Path path, long time) {
+        return new AddKeyframe(path.getTimeline().getPaths().indexOf(path), time);
+    }
+
+    AddKeyframe(int path, long time) {
+        this.path = path;
+        this.time = time;
+    }
+
+    /**
+     * Path index
+     */
+    private final int path;
+
+    /**
+     * Time at which the property should be injected.
+     */
+    private final long time;
+
+    /**
+     * Index of the newly created property.
+     */
+    private int index;
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        Keyframe keyframe = path.insert(time);
+        index = Iterables.indexOf(path.getKeyframes(), Predicates.equalTo(keyframe));
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        path.remove(Iterables.get(path.getKeyframes(), index), true);
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/AddPath.java b/src/main/java/com/replaymod/replaystudio/pathing/change/AddPath.java
new file mode 100644
index 0000000000000000000000000000000000000000..111da2b6614bea4213d4ba69db378deba8dd8533
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/AddPath.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import lombok.NonNull;
+
+/**
+ * Adds a new property.
+ */
+public final class AddPath implements Change {
+    @NonNull
+    public static AddPath create() {
+        return new AddPath();
+    }
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        timeline.createPath();
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        timeline.getPaths().remove(timeline.getPaths().size() - 1);
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/Change.java b/src/main/java/com/replaymod/replaystudio/pathing/change/Change.java
new file mode 100644
index 0000000000000000000000000000000000000000..fc61d57fe58615e5b81145abf6be91671f1a7b32
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/Change.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.replaymod.replaystudio.pathing.path.Timeline;
+
+/**
+ * A change to any part of a timeline.
+ * If {@link #undo(Timeline)} is not called in the reverse order of {@link #apply(Timeline)}, the behavior is unspecified.
+ */
+public interface Change {
+
+    /**
+     * Apply this change.
+     *
+     * @param timeline The timeline
+     * @throws IllegalStateException If already applied.
+     */
+    void apply(Timeline timeline);
+
+    /**
+     * Undo this change.
+     *
+     * @param timeline The timeline
+     * @throws IllegalStateException If not yet applied.
+     */
+    void undo(Timeline timeline);
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/CombinedChange.java b/src/main/java/com/replaymod/replaystudio/pathing/change/CombinedChange.java
new file mode 100644
index 0000000000000000000000000000000000000000..10e6c05fb36dcb83ba5e9a908027d2c8c7cdaad0
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/CombinedChange.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import lombok.NonNull;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.ListIterator;
+
+/**
+ * Represents multiple changes as one change.
+ */
+public class CombinedChange implements Change {
+
+    /**
+     * Combines the specified changes into one change in the order given.
+     * All changes must not yet have been applied.
+     *
+     * @param changes List of changes
+     * @return A new CombinedChange instance
+     */
+    @NonNull
+    public static CombinedChange create(Change... changes) {
+        return new CombinedChange(Arrays.asList(changes), false);
+    }
+
+    /**
+     * Combines the specified changes into one change in the order given.
+     * All changes must have been applied.
+     *
+     * @param changes List of changes
+     * @return A new CombinedChange instance
+     */
+    @NonNull
+    public static CombinedChange createFromApplied(Change... changes) {
+        return new CombinedChange(Arrays.asList(changes), true);
+    }
+
+    CombinedChange(List<Change> changeList, boolean applied) {
+        this.changeList = changeList;
+        this.applied = applied;
+    }
+
+    private final List<Change> changeList;
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        for (Change change : changeList) {
+            change.apply(timeline);
+        }
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        ListIterator<Change> iterator = changeList.listIterator(changeList.size());
+        while (iterator.hasPrevious()) {
+            iterator.previous().undo(timeline);
+        }
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/RemoveInterpolatorProperty.java b/src/main/java/com/replaymod/replaystudio/pathing/change/RemoveInterpolatorProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..68aa6b5be40586abcbf7280582b8fc3d92845682
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/RemoveInterpolatorProperty.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+import lombok.NonNull;
+
+/**
+ * Removes a property.
+ */
+public final class RemoveInterpolatorProperty implements Change {
+    @NonNull
+    public static RemoveInterpolatorProperty create(Interpolator interpolator, Property property) {
+        return new RemoveInterpolatorProperty(interpolator, property);
+    }
+
+    RemoveInterpolatorProperty(Interpolator interpolator, Property property) {
+        this.interpolator = interpolator;
+        this.property = property;
+    }
+
+    private final Interpolator interpolator;
+
+    private final Property property;
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        interpolator.unregisterProperty(property);
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        interpolator.registerProperty(property);
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/RemoveKeyframe.java b/src/main/java/com/replaymod/replaystudio/pathing/change/RemoveKeyframe.java
new file mode 100644
index 0000000000000000000000000000000000000000..7985ae613b043f3161826463207cd42806d5b003
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/RemoveKeyframe.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.google.common.base.Predicates;
+import com.google.common.collect.Iterables;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import lombok.NonNull;
+
+/**
+ * Removes a property.
+ */
+public final class RemoveKeyframe implements Change {
+    @NonNull
+    public static RemoveKeyframe create(@NonNull Path path, @NonNull Keyframe keyframe) {
+        return new RemoveKeyframe(path.getTimeline().getPaths().indexOf(path),
+                Iterables.indexOf(path.getKeyframes(), Predicates.equalTo(keyframe)));
+    }
+
+    RemoveKeyframe(int path, int index) {
+        this.path = path;
+        this.index = index;
+    }
+
+    /**
+     * Path index
+     */
+    private final int path;
+
+    /**
+     * Index of the property to be removed.
+     */
+    private final int index;
+
+    private volatile Keyframe removedKeyframe;
+    private volatile Interpolator removedInterpolator;
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        // The interpolator can only be saved if there are at least two keyframes / one segment
+        if (!path.getSegments().isEmpty()) {
+            // By default we keep the interpolator of the left-hand side and and store the right-hand side for undoing
+            // however if this is the last keyframe, we have to store the left-hand side as it will otherwise be lost
+            if (index == path.getSegments().size()) {
+                // This is the last keyframe, save the previous interpolator
+                removedInterpolator = Iterables.get(path.getSegments(), index - 1).getInterpolator();
+            } else {
+                // Save the next interpolator
+                removedInterpolator = Iterables.get(path.getSegments(), index).getInterpolator();
+            }
+        }
+        path.remove(removedKeyframe = Iterables.get(path.getKeyframes(), index), true);
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        path.insert(removedKeyframe);
+        if (removedInterpolator != null) {
+            if (index == path.getSegments().size()) {
+                // The keyframe is the last one, restore the previous interpolator
+                Iterables.get(path.getSegments(), index - 1).setInterpolator(removedInterpolator);
+            } else {
+                // Save the next iterpolator
+                Iterables.get(path.getSegments(), index).setInterpolator(removedInterpolator);
+            }
+        }
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/RemovePath.java b/src/main/java/com/replaymod/replaystudio/pathing/change/RemovePath.java
new file mode 100644
index 0000000000000000000000000000000000000000..6c071194ea00fc96644cb0a00a66294891b9f99b
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/RemovePath.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import lombok.NonNull;
+
+/**
+ * Adds a new property.
+ */
+public final class RemovePath implements Change {
+    @NonNull
+    public static RemovePath create(Path path) {
+        return new RemovePath(path.getTimeline().getPaths().indexOf(path));
+    }
+
+    RemovePath(int path) {
+        this.path = path;
+    }
+
+    /**
+     * Path index
+     */
+    private final int path;
+
+    /**
+     * The removed path
+     */
+    private volatile Path oldPath;
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        oldPath = timeline.getPaths().remove(path);
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        timeline.getPaths().add(path, oldPath);
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/SetInterpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/change/SetInterpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..1972974a17045fedea2b4a11dd0f88d7e3a5c9a0
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/SetInterpolator.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.google.common.collect.Iterables;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import lombok.NonNull;
+
+/**
+ * Sets the interpolator of a path segment.
+ */
+public final class SetInterpolator implements Change {
+
+    @NonNull
+    public static SetInterpolator create(PathSegment segment, Interpolator interpolator) {
+        Path path = segment.getPath();
+        return new SetInterpolator(path.getTimeline().getPaths().indexOf(path),
+                Iterables.indexOf(path.getSegments(), segment::equals),
+                interpolator);
+    }
+
+    SetInterpolator(int path, int index, Interpolator interpolator) {
+        this.path = path;
+        this.index = index;
+        this.interpolator = interpolator;
+    }
+
+    private final int path;
+    private final int index;
+
+    private final Interpolator interpolator;
+
+    private Interpolator oldInterpolator;
+
+    private boolean applied;
+
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        PathSegment segment = Iterables.get(path.getSegments(), index);
+
+        oldInterpolator = segment.getInterpolator();
+        segment.setInterpolator(interpolator);
+
+        applied = true;
+    }
+
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        PathSegment segment = Iterables.get(path.getSegments(), index);
+
+        segment.setInterpolator(oldInterpolator);
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/change/UpdateKeyframeProperties.java b/src/main/java/com/replaymod/replaystudio/pathing/change/UpdateKeyframeProperties.java
new file mode 100644
index 0000000000000000000000000000000000000000..0b89590932f4c3141ac906fc7b3bdc6951ce416c
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/change/UpdateKeyframeProperties.java
@@ -0,0 +1,149 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.change;
+
+import com.google.common.base.Preconditions;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyGroup;
+import lombok.NonNull;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+
+import static com.google.common.base.Predicates.equalTo;
+import static com.google.common.collect.Iterables.get;
+import static com.google.common.collect.Iterables.indexOf;
+
+/**
+ * Updates some properties of a property.
+ */
+public final class UpdateKeyframeProperties implements Change {
+
+    private static String toId(Property property) {
+        assert property != null;
+        PropertyGroup group = property.getGroup();
+        return (group != null ? group.getId() + ":" : "") + property.getId();
+    }
+
+    public static class Builder {
+        private final int path;
+        private final int keyframe;
+        private final Map<String, Optional<Object>> updates = new HashMap<>();
+
+        private Builder(int path, int keyframe) {
+            this.path = path;
+            this.keyframe = keyframe;
+        }
+
+        /**
+         * Set the value for the property at this property.
+         * If the property is not present, adds it.
+         *
+         * @param property The property
+         * @param value    Value of the property, may be {@code null}
+         * @param <T>      Type of the property
+         * @return {@code this} for chaining
+         */
+        public <T> Builder setValue(Property<T> property, T value) {
+            updates.put(toId(property), Optional.of((Object) value));
+            return this;
+        }
+
+        /**
+         * Remove the specified property from this property.
+         *
+         * @param property The property to be removed
+         * @return {@code this} for chaining
+         */
+        public Builder removeProperty(Property property) {
+            updates.put(toId(property), Optional.empty());
+            return this;
+        }
+
+        public UpdateKeyframeProperties done() {
+            return new UpdateKeyframeProperties(path, keyframe, updates);
+        }
+    }
+
+    @NonNull
+    public static UpdateKeyframeProperties.Builder create(@NonNull Path path, @NonNull Keyframe keyframe) {
+        return new UpdateKeyframeProperties.Builder(path.getTimeline().getPaths().indexOf(path),
+                indexOf(path.getKeyframes(), equalTo(keyframe)));
+    }
+
+    UpdateKeyframeProperties(int path, int index, Map<String, Optional<Object>> newValues) {
+        this.path = path;
+        this.index = index;
+        this.newValues = newValues;
+    }
+
+    private final int path;
+    private final int index;
+    private final Map<String, Optional<Object>> newValues;
+    private final Map<String, Optional<Object>> oldValues = new HashMap<>();
+    private boolean applied;
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void apply(Timeline timeline) {
+        Preconditions.checkState(!applied, "Already applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        Keyframe keyframe = get(path.getKeyframes(), index);
+        for (Map.Entry<String, Optional<Object>> entry : newValues.entrySet()) {
+            Property property = timeline.getProperty(entry.getKey());
+            if (property == null) throw new IllegalStateException("Property " + entry.getKey() + " unknown.");
+            Optional<Object> newValue = entry.getValue();
+            oldValues.put(entry.getKey(), keyframe.getValue(property));
+            if (newValue.isPresent()) {
+                keyframe.setValue(property, newValue.get());
+            } else {
+                keyframe.removeProperty(property);
+            }
+        }
+
+        applied = true;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public void undo(Timeline timeline) {
+        Preconditions.checkState(applied, "Not yet applied!");
+
+        Path path = timeline.getPaths().get(this.path);
+        Keyframe keyframe = get(path.getKeyframes(), index);
+        for (Map.Entry<String, Optional<Object>> entry : oldValues.entrySet()) {
+            Property property = timeline.getProperty(entry.getKey());
+            if (property == null) throw new IllegalStateException("Property " + entry.getKey() + " unknown.");
+            Optional<Object> oldValue = entry.getValue();
+            newValues.put(entry.getKey(), keyframe.getValue(property));
+            if (oldValue.isPresent()) {
+                keyframe.setValue(property, oldValue.get());
+            } else {
+                keyframe.removeProperty(property);
+            }
+        }
+
+        applied = false;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/impl/KeyframeImpl.java b/src/main/java/com/replaymod/replaystudio/pathing/impl/KeyframeImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..324adc5684db7d9f043fafc29b38c45d0cdcf3ac
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/impl/KeyframeImpl.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.impl;
+
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.property.Property;
+import lombok.RequiredArgsConstructor;
+
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.Optional;
+
+@RequiredArgsConstructor
+public class KeyframeImpl implements Keyframe {
+    private final long time;
+    private final Map<Property, Object> properties = new HashMap<>();
+
+    @Override
+    public long getTime() {
+        return time;
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> Optional<T> getValue(Property<T> property) {
+        return properties.containsKey(property) ? Optional.of((T) properties.get(property)) : Optional.empty();
+    }
+
+    @Override
+    public <T> void setValue(Property<T> property, T value) {
+        properties.put(property, value);
+    }
+
+    @Override
+    public void removeProperty(Property property) {
+        properties.remove(property);
+    }
+
+    @Override
+    public Set<Property> getProperties() {
+        return Collections.unmodifiableSet(properties.keySet());
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/impl/PathImpl.java b/src/main/java/com/replaymod/replaystudio/pathing/impl/PathImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..8dc6f547ad1e2287e6be5944cf9968766265d90d
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/impl/PathImpl.java
@@ -0,0 +1,204 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.impl;
+
+import com.replaymod.replaystudio.pathing.interpolation.InterpolationParameters;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyPart;
+
+import java.util.*;
+
+public class PathImpl implements Path {
+    private final Timeline timeline;
+    private Map<Long, Keyframe> keyframes = new TreeMap<>();
+    private List<PathSegment> segments = new LinkedList<>();
+    private boolean active = true;
+
+    public PathImpl(Timeline timeline) {
+        this.timeline = timeline;
+    }
+
+    @Override
+    public Timeline getTimeline() {
+        return timeline;
+    }
+
+    @Override
+    public Collection<Keyframe> getKeyframes() {
+        return Collections.unmodifiableCollection(keyframes.values());
+    }
+
+    @Override
+    public Collection<PathSegment> getSegments() {
+        return Collections.unmodifiableCollection(segments);
+    }
+
+    @Override
+    public void update() {
+        update(false);
+    }
+
+    @Override
+    public void updateAll() {
+        update(false);
+    }
+
+    private void update(boolean force) {
+        Interpolator interpolator = null;
+        Map<PropertyPart, InterpolationParameters> parameters = new HashMap<>();
+        for (PathSegment segment : segments) {
+            if (segment.getInterpolator() != interpolator) {
+                interpolator = segment.getInterpolator();
+                if (force || interpolator.isDirty()) {
+                    parameters = interpolator.bake(parameters);
+                }
+            }
+        }
+    }
+
+    @Override
+    public <T> Optional<T> getValue(Property<T> property, long time) {
+        PathSegment segment = getSegment(time);
+        if (segment != null) {
+            Interpolator interpolator = segment.getInterpolator();
+            if (interpolator != null) {
+                if (interpolator.getKeyframeProperties().contains(property)) {
+                    return interpolator.getValue(property, time);
+                }
+            }
+        }
+        return Optional.empty();
+    }
+
+    @Override
+    public Keyframe insert(long time) {
+        Keyframe keyframe = new KeyframeImpl(time);
+        insert(keyframe);
+        return keyframe;
+    }
+
+    @Override
+    public Keyframe getKeyframe(long time) {
+        return keyframes.get(time);
+    }
+
+    @Override
+    public void insert(Keyframe keyframe) {
+        if (keyframes.containsKey(keyframe.getTime())) {
+            throw new IllegalStateException("A keyframe at " + keyframe.getTime() + " already exists.");
+        }
+        keyframes.put(keyframe.getTime(), keyframe);
+
+        if (segments.isEmpty()) {
+            if (keyframes.size() >= 2) {
+                Iterator<Keyframe> iter = keyframes.values().iterator();
+                segments.add(new PathSegmentImpl(this, iter.next(), iter.next()));
+            }
+            return;
+        }
+
+        ListIterator<PathSegment> iter = segments.listIterator();
+        PathSegment next = iter.next();
+        if (keyframe.getTime() < next.getStartKeyframe().getTime()) {
+            iter.previous();
+            iter.add(new PathSegmentImpl(this, keyframe, next.getStartKeyframe(), next.getInterpolator()));
+            return;
+        }
+
+        while (true) {
+            if (next.getStartKeyframe().getTime() <= keyframe.getTime()
+                    && next.getEndKeyframe().getTime() >= keyframe.getTime()) {
+                iter.remove();
+                iter.add(new PathSegmentImpl(this, next.getStartKeyframe(), keyframe, next.getInterpolator()));
+                iter.add(new PathSegmentImpl(this, keyframe, next.getEndKeyframe(), next.getInterpolator()));
+                next.setInterpolator(null);
+                return;
+            }
+            if (iter.hasNext()) {
+                next = iter.next();
+            } else {
+                iter.add(new PathSegmentImpl(this, next.getEndKeyframe(), keyframe, next.getInterpolator()));
+                return;
+            }
+        }
+    }
+
+    @Override
+    public void remove(Keyframe keyframe, boolean useFirstInterpolator) {
+        if (keyframes.get(keyframe.getTime()) != keyframe) {
+            throw new IllegalArgumentException("The keyframe " + keyframe + " is not part of this path.");
+        }
+        keyframes.remove(keyframe.getTime());
+
+        if (segments.size() < 2) {
+            for (PathSegment segment : segments) {
+                segment.setInterpolator(null);
+            }
+            segments.clear();
+            return;
+        }
+
+        ListIterator<PathSegment> iter = segments.listIterator();
+        while (iter.hasNext()) {
+            PathSegment next = iter.next();
+            if (next.getEndKeyframe() == keyframe) {
+                iter.remove();
+                if (iter.hasNext()) {
+                    PathSegment next2 = iter.next();
+                    iter.remove();
+                    iter.add(new PathSegmentImpl(this, next.getStartKeyframe(), next2.getEndKeyframe(),
+                            (useFirstInterpolator ? next : next2).getInterpolator()));
+                    next2.setInterpolator(null);
+                }
+                next.setInterpolator(null);
+                return;
+            }
+            if (next.getStartKeyframe() == keyframe) {
+                next.setInterpolator(null);
+                iter.remove();
+                return;
+            }
+        }
+        throw new AssertionError("No segment for keyframe found!");
+    }
+
+    @Override
+    public void setActive(boolean active) {
+        this.active = active;
+    }
+
+    @Override
+    public boolean isActive() {
+        return active;
+    }
+
+    private PathSegment getSegment(long time) {
+        for (PathSegment segment : segments) {
+            if (segment.getStartKeyframe().getTime() <= time && segment.getEndKeyframe().getTime() >= time) {
+                return segment;
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/impl/PathSegmentImpl.java b/src/main/java/com/replaymod/replaystudio/pathing/impl/PathSegmentImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..259249f5a5086e85a011c1907e68d3fbf97c57d4
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/impl/PathSegmentImpl.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.impl;
+
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+
+@Getter
+@RequiredArgsConstructor
+public class PathSegmentImpl implements PathSegment {
+    private final Path path;
+    private final Keyframe startKeyframe;
+    private final Keyframe endKeyframe;
+    private Interpolator interpolator;
+
+    public PathSegmentImpl(Path path, Keyframe startKeyframe, Keyframe endKeyframe, Interpolator interpolator) {
+        this.path = path;
+        this.startKeyframe = startKeyframe;
+        this.endKeyframe = endKeyframe;
+        setInterpolator(interpolator);
+    }
+
+    @Override
+    public void setInterpolator(Interpolator interpolator) {
+        if (this.interpolator != null) {
+            this.interpolator.removeSegment(this);
+        }
+        this.interpolator = interpolator;
+        if (this.interpolator != null) {
+            this.interpolator.addSegment(this);
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/impl/TimelineImpl.java b/src/main/java/com/replaymod/replaystudio/pathing/impl/TimelineImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..bedfe19d6016c335b0f7ec45e46eec377ec67fc1
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/impl/TimelineImpl.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.impl;
+
+import com.replaymod.replaystudio.pathing.change.Change;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+
+import java.util.*;
+
+public class TimelineImpl implements Timeline {
+    private final List<Path> paths = new ArrayList<>();
+    private Map<String, Property> properties = new HashMap<>();
+    private Deque<Change> undoStack = new ArrayDeque<>();
+    private Deque<Change> redoStack = new ArrayDeque<>();
+
+    @Override
+    public List<Path> getPaths() {
+        return paths;
+    }
+
+    @Override
+    public Path createPath() {
+        Path path = new PathImpl(this);
+        paths.add(path);
+        return path;
+    }
+
+    @Override
+    public <T> Optional<T> getValue(Property<T> property, long time) {
+        for (Path path : paths) {
+            if (path.isActive()) {
+                Optional<T> value = path.getValue(property, time);
+                if (value.isPresent()) {
+                    return value;
+                }
+            }
+        }
+        return Optional.empty();
+    }
+
+    @Override
+    public void applyToGame(long time, Object replayHandler) {
+        for (Property<?> property : properties.values()) {
+            applyToGame(time, replayHandler, property);
+        }
+    }
+
+    private <T> void applyToGame(long time, Object replayHandler, Property<T> property) {
+        Optional<T> value = getValue(property, time);
+        if (value.isPresent()) {
+            property.applyToGame(value.get(), replayHandler);
+        }
+    }
+
+    @Override
+    public void registerProperty(Property property) {
+        String id = (property.getGroup() == null ? "" : property.getGroup().getId() + ":") + property.getId();
+        properties.put(id, property);
+    }
+
+    @Override
+    public Property getProperty(String id) {
+        return properties.get(id);
+    }
+
+    @Override
+    public void applyChange(Change change) {
+        change.apply(this);
+        pushChange(change);
+    }
+
+    @Override
+    public void pushChange(Change change) {
+        undoStack.push(change);
+        redoStack.clear();
+    }
+
+    @Override
+    public void undoLastChange() {
+        Change change = undoStack.pop();
+        change.undo(this);
+        redoStack.push(change);
+    }
+
+    @Override
+    public void redoLastChange() {
+        Change change = redoStack.pop();
+        change.apply(this);
+        undoStack.push(change);
+    }
+
+    @Override
+    public Change peekUndoStack() {
+        return undoStack.peek();
+    }
+
+    @Override
+    public Change peekRedoStack() {
+        return redoStack.peek();
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/AbstractInterpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/AbstractInterpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..c3f0a94458b6e502095a5bb774aa4fcacbb0870f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/AbstractInterpolator.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyPart;
+
+import java.util.*;
+
+public abstract class AbstractInterpolator implements Interpolator {
+    private List<PathSegment> segments = new LinkedList<>();
+    private boolean dirty;
+    private final Set<Property> properties = new HashSet<>();
+
+    @Override
+    public Collection<Property> getKeyframeProperties() {
+        return Collections.unmodifiableCollection(properties);
+    }
+
+    @Override
+    public void registerProperty(Property property) {
+        if (properties.add(property)) {
+            dirty = true;
+        }
+    }
+
+    @Override
+    public void unregisterProperty(Property property) {
+        if (properties.remove(property)) {
+            dirty = true;
+        }
+    }
+
+    @Override
+    public void addSegment(PathSegment segment) {
+        segments.add(segment);
+        dirty = true;
+    }
+
+    @Override
+    public void removeSegment(PathSegment segment) {
+        segments.remove(segment);
+        dirty = true;
+    }
+
+    @Override
+    public List<PathSegment> getSegments() {
+        return Collections.unmodifiableList(segments);
+    }
+
+    @Override
+    public Map<PropertyPart, InterpolationParameters> bake(Map<PropertyPart, InterpolationParameters> parameters) {
+        if (segments.isEmpty()) throw new IllegalStateException("No segments have been added yet.");
+        Collections.sort(segments, new Comparator<PathSegment>() {
+            @Override
+            public int compare(PathSegment s1, PathSegment s2) {
+                return Long.compare(s1.getStartKeyframe().getTime(), s2.getStartKeyframe().getTime());
+            }
+        });
+
+        // Check for continuity
+        Iterator<PathSegment> iter = segments.iterator();
+        PathSegment last = iter.next();
+        while (iter.hasNext()) {
+            if (last.getEndKeyframe() != (last = iter.next()).getStartKeyframe()) {
+                throw new IllegalStateException("Segments are not continuous.");
+            }
+        }
+
+        return bakeInterpolation(parameters);
+    }
+
+    /**
+     * Bake the interpolation of the current path segments with the specified parameters.
+     * Order of {@link #getSegments()} is guaranteed.
+     * @param parameters Map of parameters for some properties
+     * @return Map of parameters for the next interpolator
+     */
+    protected abstract Map<PropertyPart, InterpolationParameters> bakeInterpolation(Map<PropertyPart, InterpolationParameters> parameters);
+
+    @Override
+    public boolean isDirty() {
+        return dirty;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/CatmullRomSplineInterpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/CatmullRomSplineInterpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..64cae8baeedabed16bfc8e3701750be7fd2bde42
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/CatmullRomSplineInterpolator.java
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+import com.replaymod.replaystudio.pathing.interpolation.PolynomialSplineInterpolator.Polynomial;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyPart;
+import lombok.Getter;
+import lombok.RequiredArgsConstructor;
+
+import java.util.*;
+
+@RequiredArgsConstructor
+public class CatmullRomSplineInterpolator extends AbstractInterpolator {
+
+    @Getter
+    private final double alpha;
+
+    private Map<PropertyPart<?>, Polynomial[]> cubicPolynomials = new HashMap<>();
+    private Map<Property<?>, Set<Keyframe>> framesToProperty = new HashMap<>();
+
+    private void addToMap(Property property, Keyframe keyframe) {
+        Set<Keyframe> set = framesToProperty.get(property);
+        if (set == null) {
+            framesToProperty.put(property, set = new LinkedHashSet<>());
+        }
+        set.add(keyframe);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected Map<PropertyPart, InterpolationParameters> bakeInterpolation(Map<PropertyPart, InterpolationParameters> parameters) {
+        framesToProperty.clear();
+        for (PathSegment segment : getSegments()) {
+            for (Property property : getKeyframeProperties()) {
+                if (segment.getStartKeyframe().getValue(property).isPresent()) {
+                    addToMap(property, segment.getStartKeyframe());
+                }
+                if (segment.getEndKeyframe().getValue(property).isPresent()) {
+                    addToMap(property, segment.getEndKeyframe());
+                }
+            }
+        }
+
+        calcPolynomials();
+
+        Map<PropertyPart, InterpolationParameters> lastParameters = new HashMap<>();
+
+        for (Property<?> property : getKeyframeProperties()) {
+            for (PropertyPart<?> part : property.getParts()) {
+                Polynomial[] polynomials = cubicPolynomials.get(part);
+                Polynomial last = polynomials[polynomials.length - 1];
+
+                double value = last.eval(1);
+                double velocity = last.derivative().eval(1);
+                double acceleration = last.derivative().derivative().eval(1);
+
+                lastParameters.put(part, new InterpolationParameters(value, velocity, acceleration));
+            }
+        }
+
+        return lastParameters;
+    }
+
+    // http://steve.hollasch.net/cgindex/curves/catmull-rom.html
+    protected void calcPolynomials() {
+        for (Map.Entry<Property<?>, Set<Keyframe>> e : framesToProperty.entrySet()) {
+            Property<?> property = e.getKey();
+            Set<Keyframe> keyframes = e.getValue();
+
+            for (PropertyPart<?> part : property.getParts()) {
+                if (!part.isInterpolatable()) continue;
+
+                List<Double> values = new ArrayList<>();
+
+                if (Double.isNaN(part.getUpperBound())) {
+                    for (Keyframe k : keyframes) {
+                        values.add(getValueAsDouble(k, part));
+                    }
+                } else {
+                    double bound = part.getUpperBound();
+                    double halfBound = bound / 2;
+
+                    Iterator<Keyframe> it = keyframes.iterator();
+
+                    Double lastValue = null;
+                    Integer offset = null;
+
+                    while (it.hasNext()) {
+                        Keyframe keyframe = it.next();
+                        double value = mod(getValueAsDouble(keyframe, part), bound);
+
+                        if (lastValue == null) {
+                            lastValue = value;
+                            offset = (int) Math.floor(value / bound);
+                        }
+
+                        if (Math.abs(value - lastValue) > halfBound) {
+                            // We can wrap around to get to the new value quicker
+                            if (lastValue < halfBound) {
+                                offset--; // Wrap around the bottom
+                            } else {
+                                offset++; // Wrap around the top
+                            }
+                        }
+
+                        values.add(value + offset * bound);
+                        lastValue = value;
+                    }
+                }
+
+                Polynomial[] polynomials = new Polynomial[values.size()-1];
+
+                for (int i=0; i<values.size()-1; i++) {
+                    double p0, p1, p2, p3;
+
+                    p1 = values.get(i);
+                    p2 = values.get(i+1);
+
+                    if (i > 0) {
+                        p0 = values.get(i-1);
+                    } else {
+                        p0 = p1;
+                    }
+
+                    if (i < keyframes.size() - 2) {
+                        p3 = values.get(i+2);
+                    } else {
+                        p3 = p2;
+                    }
+
+                    double t0 = alpha * (p2 - p0);
+                    double t1 = alpha * (p3 - p1);
+
+                    double[] c = new double[] {
+                            2* p1 - 2* p2 + t0 + t1,
+                            -3* p1 + 3* p2 - 2*t0 - t1,
+                            t0,
+                            p1
+                    };
+
+                    polynomials[i] = new Polynomial(c);
+                }
+
+                cubicPolynomials.put(part, polynomials);
+            }
+        }
+    }
+
+    // copied from PolynomialSplineInterpolator - move this in a utils class?
+    private double mod(double val, double m) {
+        double off = Math.floor(val / m);
+        return val - off * m;
+    }
+
+    // Helper method because generics cannot be defined on blocks
+    private <T> double getValueAsDouble(Keyframe keyframe, PropertyPart<T> part) {
+        return part.toDouble(keyframe.getValue(part.getProperty()).get());
+    }
+
+    @Override
+    public <T> Optional<T> getValue(Property<T> property, long time) {
+        Set<Keyframe> kfSet = framesToProperty.get(property);
+        if (kfSet == null) {
+            return Optional.empty();
+        }
+
+        T valueBefore = null;
+        long timeBefore = -1, timeAfter = -1;
+        int index = 0;
+        int i = 0;
+        for (Keyframe keyframe : kfSet) {
+            if (keyframe.getTime() == time) {
+                return keyframe.getValue(property);
+            } else if (keyframe.getTime() < time) {
+                index = i;
+                timeBefore = keyframe.getTime();
+                valueBefore = keyframe.getValue(property).get();
+            } else if (keyframe.getTime() > time) {
+                timeAfter = keyframe.getTime();
+                break;
+            }
+            i++;
+        }
+
+        if (timeBefore == -1 || timeAfter == -1) {
+            return Optional.empty();
+        }
+
+        double fraction = (time - timeBefore) / (double) (timeAfter - timeBefore);
+
+        T interpolated = valueBefore;
+
+        for (PropertyPart<T> part : property.getParts()) {
+            if (!part.isInterpolatable()) continue;
+
+            Polynomial[] polynomials = cubicPolynomials.get(part);
+            interpolated = part.fromDouble(interpolated, polynomials[index].eval(fraction));
+        }
+        return Optional.of(interpolated);
+    }
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/CubicSplineInterpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/CubicSplineInterpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..c73ead468d30347523882a4ccf062b2d6fb05400
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/CubicSplineInterpolator.java
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+public class CubicSplineInterpolator extends PolynomialSplineInterpolator {
+    public CubicSplineInterpolator() {
+        super(3);
+    }
+
+    @Override
+    protected void fillMatrix(double[][] matrix, double[] xs, double[] ys, int num, InterpolationParameters params) {
+        int row = 0;
+        double x;
+
+        if (params != null) {
+            // Apply previous values
+            ys[0] = params.getValue();
+            x = xs[0];
+            matrix[row][0] = 3 * x * x;
+            matrix[row][1] = 2 * x;
+            matrix[row][2] = 1;
+            matrix[row][num * 4] = params.getVelocity();
+            row++;
+            matrix[row][0] = 6 * x;
+            matrix[row][1] = 2;
+            matrix[row][num * 4] = params.getAcceleration();
+            row++;
+        } else {
+            // Set second derivative at the first and the last knot to 0
+            matrix[row][0] = 6 * xs[0];
+            matrix[row][1] = 2;
+            row++;
+            matrix[row][(num - 1) * 4] = 6 * xs[xs.length - 1];
+            matrix[row][(num - 1) * 4 + 1] = 2;
+            row++;
+        }
+
+        for (int i = 0; i < num; i++) {
+            // Each cubic i must produce the correct result at x[i] and x[i+1], that is y[i] and y[i+1]
+            // Resulting in these linear equations for every value
+            //       a[i]    b[i]     c[i]    d[i]  ...  y
+            // (... x[i]    x[i]    x[i]     1    ...  y[i]     ...)  or  f[i](x[i]) = y[i]
+            // (... x[i+1]  x[i+1]  x[i+1]   1    ...  y[i+1]   ...)  or  f[i](x[i+1]) = y[i+1]
+            x = xs[i];
+            matrix[row][i * 4    ] = x * x * x;
+            matrix[row][i * 4 + 1] = x * x;
+            matrix[row][i * 4 + 2] = x;
+            matrix[row][i * 4 + 3] = 1;
+            matrix[row][num * 4] = ys[i];
+            row++;
+            x = xs[i + 1];
+            matrix[row][i * 4    ] = x * x * x;
+            matrix[row][i * 4 + 1] = x * x;
+            matrix[row][i * 4 + 2] = x;
+            matrix[row][i * 4 + 3] = 1;
+            matrix[row][num * 4] = ys[i + 1];
+            row++;
+
+            // The first derivative should be defined at all knots
+            // Therefore two adjacent cubics have to have the same derivative at their common knot
+            // Linear equation for every value (except the last one)
+            //       a[i]      b[i]    c[i]  d[i]  a[i+1]    b[i+1]   c[i+1]  d[i+1]
+            // (... 3x[i+1]  2x[i+1]   1     0    3x[i+1]  2x[i+1]    1       0     ...)
+            if (i < num - 1) {
+                x = xs[i + 1];
+                matrix[row][i * 4] = -(matrix[row][i * 4 + 4] = 3 * x * x);
+                matrix[row][i * 4 + 1] = -(matrix[row][i * 4 + 5] = 2 * x);
+                matrix[row][i * 4 + 2] = -(matrix[row][i * 4 + 6] = 1);
+                row++;
+            }
+
+            // Same for the second derivative
+            if (i < num - 1) {
+                x = xs[i + 1];
+                matrix[row][i * 4] = -(matrix[row][i * 4 + 4] = 6 * x);
+                matrix[row][i * 4 + 1] = -(matrix[row][i * 4 + 5] = 2);
+                row++;
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/InterpolationParameters.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/InterpolationParameters.java
new file mode 100644
index 0000000000000000000000000000000000000000..d494e5f3166cf45a245cf1c43fe030411b927d9f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/InterpolationParameters.java
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+import lombok.Data;
+
+/**
+ * Parameters which can be used to make an interpolation more fitting to the previous one.
+ */
+@Data
+public class InterpolationParameters {
+    /**
+     * The final value.
+     * Should be the same as for the final property.
+     * If it differs though, this value should be preferred.
+     */
+    private final double value;
+
+    /**
+     * Velocity at the end of the interpolation.
+     * Normally this is the first derivative of the interpolating function at the end of the interpolation.
+     */
+    private final double velocity;
+
+    /**
+     * Acceleration at the end of the interpolation.
+     * Normally this is the second derivative of the interpolating function at the end of the interpolation.
+     */
+    private final double acceleration;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/Interpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/Interpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..596e35e2aba8538842693d00d37b157fd1152643
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/Interpolator.java
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyPart;
+import lombok.NonNull;
+
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * Interpolates multiple keyframes. Also provides all Properties it can handle.
+ * Each Interpolator may provide certain outputs for the next Interpolator.
+ * Interpolators are evaluated first to last.
+ */
+public interface Interpolator {
+    /**
+     * Register the specified property to be handled by this interpolator.
+     * @param property The property
+     */
+    void registerProperty(Property property);
+
+    /**
+     * Removes the specified property from being handled by this interpolator
+     * @param property The property
+     */
+    void unregisterProperty(Property property);
+
+    /**
+     * Returns a collection of all properties applicable for this Interpolator.
+     *
+     * @return Collection of properties or empty collection if none
+     */
+    @NonNull
+    Collection<Property> getKeyframeProperties();
+
+    /**
+     * Add the specified path segment to this interpolator.
+     * <p/>
+     * This method should be called by the PathSegment itself.
+     *
+     * @param segment The path segments
+     */
+    void addSegment(PathSegment segment);
+
+    /**
+     * Remove the specified path segment from this interpolator.
+     * <p/>
+     * This method should be called by the PathSegment itself.
+     *
+     * @param segment The path segments
+     */
+    void removeSegment(PathSegment segment);
+
+    /**
+     * Returns an immutable list of all path segments handled by this interpolator.
+     * Ordering is only guaranteed after {@link #bake(Map)} has been called and only until
+     * the list is modified.
+     *
+     * @return List of path segments or empty list if none
+     */
+    @NonNull
+    List<PathSegment> getSegments();
+
+    /**
+     * Bake the interpolation of the current path segments with the specified parameters.
+     * Note that when this method is called directly, the path might need to be updated via {@link Path#update()}
+     *
+     * @param parameters Map of parameters for some properties
+     * @return Map of parameters for the next interpolator
+     * @throws IllegalStateException If no segments have been set yet
+     *                               or the segments are not continuous
+     */
+    @NonNull
+    Map<PropertyPart, InterpolationParameters> bake(Map<PropertyPart, InterpolationParameters> parameters);
+
+    /**
+     * Returns whether the segments handled by this interpolator have changed since the last
+     * call of {@link #bake(Map)}.
+     * This only includes the segments themselves, not the properties of their keyframes, those
+     * have to be tracked manually.
+     * @return {@code true} if segments have changed, {@code false} otherwise
+     */
+    boolean isDirty();
+
+    /**
+     * Return the value of the property at the specified point in time.
+     *
+     * @param property The property
+     * @param time     Time in milliseconds since the start
+     * @param <T>      Type of the property
+     * @return Optional value of the property
+     * @throws IllegalStateException If {@link #bake(Map)} has not yet been called
+     *                               or {@link #addSegment(PathSegment)}/{@link #removeSegment(PathSegment)}
+     *                               has been changed since the last bake
+     */
+    <T> Optional<T> getValue(Property<T> property, long time);
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/LinearInterpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/LinearInterpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..9b232425bb530d67f8df0c7b7d916fa0f636b41a
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/LinearInterpolator.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyPart;
+
+import java.util.*;
+
+public class LinearInterpolator extends AbstractInterpolator {
+    private Map<Property, Set<Keyframe>> framesToProperty = new HashMap<>();
+
+    private void addToMap(Property property, Keyframe keyframe) {
+        Set<Keyframe> set = framesToProperty.get(property);
+        if (set == null) {
+            framesToProperty.put(property, set = new LinkedHashSet<>());
+        }
+        set.add(keyframe);
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    protected Map<PropertyPart, InterpolationParameters> bakeInterpolation(Map<PropertyPart, InterpolationParameters> parameters) {
+        framesToProperty.clear();
+        for (PathSegment segment : getSegments()) {
+            for (Property property : getKeyframeProperties()) {
+                if (segment.getStartKeyframe().getValue(property).isPresent()) {
+                    addToMap(property, segment.getStartKeyframe());
+                }
+                if (segment.getEndKeyframe().getValue(property).isPresent()) {
+                    addToMap(property, segment.getEndKeyframe());
+                }
+            }
+        }
+
+        Keyframe lastKeyframe = getSegments().get(getSegments().size() - 1).getEndKeyframe();
+        Map<PropertyPart, InterpolationParameters> lastParameters = new HashMap<>();
+        for (Property<?> property : getKeyframeProperties()) {
+            Optional optionalValue = lastKeyframe.getValue(property);
+            if (optionalValue.isPresent()) {
+                Object value = optionalValue.get();
+                for (PropertyPart part : property.getParts()) {
+                    lastParameters.put(part, new InterpolationParameters(part.toDouble(value), 1, 0));
+                }
+            }
+        }
+        return lastParameters;
+    }
+
+    @Override
+    public <T> Optional<T> getValue(Property<T> property, long time) {
+        Set<Keyframe> kfSet = framesToProperty.get(property);
+        if (kfSet == null) {
+            return Optional.empty();
+        }
+        Keyframe kfBefore = null, kfAfter = null;
+        for (Keyframe keyframe : kfSet) {
+            if (keyframe.getTime() == time) {
+                return keyframe.getValue(property);
+            } else if (keyframe.getTime() < time) {
+                kfBefore = keyframe;
+            } else if (keyframe.getTime() > time) {
+                kfAfter = keyframe;
+                break;
+            }
+        }
+        if (kfBefore == null || kfAfter == null) {
+            return Optional.empty();
+        }
+
+        T valueBefore = kfBefore.getValue(property).get();
+        T valueAfter = kfAfter.getValue(property).get();
+        double fraction = (time - kfBefore.getTime()) / (double) (kfAfter.getTime() - kfBefore.getTime());
+
+        T interpolated = valueBefore;
+        for (PropertyPart<T> part : property.getParts()) {
+            if (part.isInterpolatable()) {
+                double before = part.toDouble(valueBefore);
+                double after = part.toDouble(valueAfter);
+                double bound = part.getUpperBound();
+                if (!Double.isNaN(bound)) {
+                    before = mod(before, bound);
+                    after = mod(after, bound);
+                    if (Math.abs(after - before) > bound / 2) {
+                        // Wrapping around is quicker
+                        if (before < bound / 2) {
+                            after -= bound;
+                        } else {
+                            after += bound;
+                        }
+                    }
+                }
+                double value = (after - before) * fraction + before;
+                if (!Double.isNaN(bound)) {
+                    value = mod(value, bound);
+                }
+                interpolated = part.fromDouble(interpolated, value);
+            }
+        }
+        return Optional.of(interpolated);
+    }
+
+    private double mod(double val, double m) {
+        double off = Math.floor(val / m);
+        return val - off * m;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/interpolation/PolynomialSplineInterpolator.java b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/PolynomialSplineInterpolator.java
new file mode 100644
index 0000000000000000000000000000000000000000..50b2ed661ace4e2351151ad22fbf116082cd114b
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/interpolation/PolynomialSplineInterpolator.java
@@ -0,0 +1,280 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.interpolation;
+
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.pathing.property.PropertyPart;
+
+import java.util.*;
+
+public abstract class PolynomialSplineInterpolator extends AbstractInterpolator {
+    private final int degree;
+    private Map<Property<?>, Set<Keyframe>> framesToProperty = new HashMap<>();
+    private Map<PropertyPart, Polynomials> polynomials = new HashMap<>();
+
+    protected PolynomialSplineInterpolator(int degree) {
+        this.degree = degree;
+    }
+
+    @Override
+    protected Map<PropertyPart, InterpolationParameters> bakeInterpolation(Map<PropertyPart, InterpolationParameters> parameters) {
+        framesToProperty.clear();
+        for (PathSegment segment : getSegments()) {
+            for (Property property : getKeyframeProperties()) {
+                if (segment.getStartKeyframe().getValue(property).isPresent()) {
+                    addToMap(framesToProperty, property, segment.getStartKeyframe());
+                }
+                if (segment.getEndKeyframe().getValue(property).isPresent()) {
+                    addToMap(framesToProperty, property, segment.getEndKeyframe());
+                }
+            }
+        }
+
+        polynomials.clear();
+        parameters = new HashMap<>(parameters);
+        for (Map.Entry<Property<?>, Set<Keyframe>> entry : framesToProperty.entrySet()) {
+            prepareProperty(entry.getKey(), entry.getValue(), parameters);
+        }
+
+        return parameters;
+    }
+
+    private <U> void prepareProperty(Property<U> property, Set<Keyframe> keyframes, Map<PropertyPart, InterpolationParameters> parameters) {
+        for (PropertyPart<U> part : property.getParts()) {
+            if (part.isInterpolatable()) {
+                double[] time = new double[keyframes.size()];
+                double[] values = new double[keyframes.size()];
+                int i = 0;
+                for (Keyframe keyframe : keyframes) {
+                    time[i] = keyframe.getTime();
+                    values[i++] = part.toDouble(keyframe.getValue(property).get());
+                }
+                Polynomials polynomials = calcPolynomials(part, time, values, parameters.get(part));
+
+                double lastTime = time[time.length - 1];
+                Polynomial lastPolynomial = polynomials.polynomials[polynomials.polynomials.length - 1];
+                double lastValue = lastPolynomial.eval(lastTime) + polynomials.yOffset;
+                double lastVelocity = (lastPolynomial = lastPolynomial.derivative()).eval(lastTime);
+                double lastAcceleration = lastPolynomial.derivative().eval(lastTime);
+                parameters.put(part, new InterpolationParameters(lastValue, lastVelocity, lastAcceleration));
+                this.polynomials.put(part, polynomials);
+            }
+        }
+    }
+
+    private void addToMap(Map<Property<?>, Set<Keyframe>> map, Property property, Keyframe keyframe) {
+        Set<Keyframe> set = map.get(property);
+        if (set == null) {
+            map.put(property, set = new LinkedHashSet<>());
+        }
+        set.add(keyframe);
+    }
+
+    protected <U> Polynomials calcPolynomials(PropertyPart<U> part, double[] xs, double[] ys, InterpolationParameters params) {
+        int unknowns = degree + 1;
+        int num = xs.length - 1;
+        if (num == 0) {
+            return new Polynomials(0, new Polynomial[]{new Polynomial(new double[]{ys[0]})});
+        }
+
+        for (int i = 0; i < xs.length; i++) {
+            xs[i] /= 1000;
+        }
+
+        double yOffset;
+        if (Double.isNaN(part.getUpperBound())) {
+            double total = 0;
+            for (double y : ys) {
+                total += y;
+            }
+            yOffset = total / ys.length;
+            for (int i = 0; i < ys.length; i++) {
+                ys[i] -= yOffset;
+            }
+            if (params != null) {
+                params = new InterpolationParameters(params.getValue() - yOffset,
+                        params.getVelocity(), params.getAcceleration());
+            }
+        } else {
+            double bound = part.getUpperBound();
+            double halfBound = bound / 2;
+            double firstValue = params != null ? params.getValue() : ys[0];
+            int offset = (int) Math.floor(firstValue / bound);
+            double lastValue = mod(firstValue, bound);
+            for (int i = 1; i < ys.length; i++) {
+                double value = mod(ys[i], bound);
+                if (Math.abs(value - lastValue) > halfBound) {
+                    // We can wrap around to get to the new value quicker
+                    if (lastValue < halfBound) {
+                        offset--; // Wrap around the bottom
+                    } else {
+                        offset++; // Wrap around the top
+                    }
+                }
+                ys[i] = value + offset * bound;
+                lastValue = value;
+            }
+            yOffset = 0; // Everything should be approximately around 0
+        }
+
+        // We want to find cubic equations y = ax + bx + cx + d, one for each pair of values
+        double[][] matrix = new double[num * unknowns][num * unknowns + 1];
+
+        fillMatrix(matrix, xs, ys, num, params);
+
+        solveMatrix(matrix);
+
+        Polynomial[] polynomials = new Polynomial[num];
+        for (int i = 0; i < num; i++) {
+            double[] coefficients = new double[degree + 1];
+            for (int j = 0; j <= degree; j++) {
+                coefficients[j] = matrix[i * unknowns + j][num * unknowns];
+            }
+            polynomials[i] = new Polynomial(coefficients);
+        }
+        return new Polynomials(yOffset, polynomials);
+    }
+
+    private double mod(double val, double m) {
+        double off = Math.floor(val / m);
+        return val - off * m;
+    }
+
+    protected abstract void fillMatrix(double[][] matrix, double[] xs, double[] ys, int num, InterpolationParameters params);
+
+    protected static void solveMatrix(double[][] matrix) {
+        for (int i = 0; i < matrix.length; i++) {
+            if (matrix[i][i] == 0) {
+                for (int j = i + 1; j < matrix.length; j++) {
+                    if (matrix[j][i] != 0) {
+                        double[] s = matrix[j];
+                        matrix[j] = matrix[i];
+                        matrix[i] = s;
+                        break;
+                    }
+                }
+            }
+            double factor = matrix[i][i];
+            if (factor != 1) {
+                matrix[i][i] = 1;
+                for (int j = i + 1; j < matrix[i].length; j++) {
+                    matrix[i][j] /= factor;
+                }
+            }
+            for (int j = i + 1; j < matrix.length; j++) {
+                factor = matrix[j][i];
+                if (factor != 0) {
+                    matrix[j][i] = 0;
+                    for (int k = i + 1; k < matrix[j].length; k++) {
+                        matrix[j][k] = matrix[j][k] - matrix[i][k] * factor;
+                    }
+                }
+            }
+        }
+        for (int i = matrix.length - 1; i >= 0; i--) {
+            for (int j = i - 1; j >= 0; j--) {
+                if (matrix[j][i] != 0) {
+                    int k = matrix[j].length - 1;
+                    matrix[j][k] -= matrix[j][i] / matrix[i][i] * matrix[i][k];
+                    matrix[j][i] = 0;
+                }
+            }
+        }
+    }
+
+    @Override
+    public <T> Optional<T> getValue(Property<T> property, long time) {
+        Set<Keyframe> kfSet = framesToProperty.get(property);
+        if (kfSet == null) {
+            return Optional.empty();
+        }
+        Keyframe kfBefore = null, kfAfter = null;
+        int index = 0;
+        for (Keyframe keyframe : kfSet) {
+            if (keyframe.getTime() == time) {
+                return keyframe.getValue(property);
+            } else if (keyframe.getTime() < time) {
+                kfBefore = keyframe;
+            } else if (keyframe.getTime() > time) {
+                kfAfter = keyframe;
+                index--;
+                break;
+            }
+            index++;
+        }
+        if (kfBefore == null || kfAfter == null) {
+            return Optional.empty();
+        }
+
+        T interpolated = kfBefore.getValue(property).get();
+        for (PropertyPart<T> part : property.getParts()) {
+            if (part.isInterpolatable()) {
+                double value = polynomials.get(part).eval(time, index);
+                if (!Double.isNaN(part.getUpperBound())) {
+                    value = mod(value, part.getUpperBound());
+                }
+                interpolated = part.fromDouble(interpolated, value);
+            }
+        }
+        return Optional.of(interpolated);
+    }
+
+    private static class Polynomials {
+        private final double yOffset;
+        private final Polynomial[] polynomials;
+
+        private Polynomials(double yOffset, Polynomial[] polynomials) {
+            this.yOffset = yOffset;
+            this.polynomials = polynomials;
+        }
+
+        public double eval(double time, int index) {
+            return polynomials[index].eval(time / 1000) + yOffset;
+        }
+    }
+
+    public static class Polynomial {
+        public final double[] coefficients;
+
+        public Polynomial(double[] coefficients) {
+            this.coefficients = coefficients;
+        }
+
+        public double eval(double at) {
+            double val = 0;
+            for (double coefficient : coefficients) {
+                val = val * at + coefficient;
+            }
+            return val;
+        }
+
+        public Polynomial derivative() {
+            if (coefficients.length == 0) {
+                return this;
+            }
+            Polynomial derived = new Polynomial(new double[coefficients.length - 1]);
+            for (int i = 0; i < coefficients.length - 1; i++) {
+                derived.coefficients[i] = coefficients[i] * (coefficients.length - 1 - i);
+            }
+            return derived;
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/path/Keyframe.java b/src/main/java/com/replaymod/replaystudio/pathing/path/Keyframe.java
new file mode 100644
index 0000000000000000000000000000000000000000..972f69700b49b5351747fef541bbf1332c100349
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/path/Keyframe.java
@@ -0,0 +1,73 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.path;
+
+import com.replaymod.replaystudio.pathing.property.Property;
+import lombok.NonNull;
+
+import java.util.Optional;
+import java.util.Set;
+
+/**
+ * Represents a key frame in time that is used to compute frames in between multiple key frames.
+ * Keyframes have different properties depending on the Interpolator tying them together.
+ * One property tied by a different Interpolator to the previous one than to the next one inherits both properties.
+ */
+public interface Keyframe {
+
+    /**
+     * Return the time at which this property is set.
+     *
+     * @return Time in milliseconds since the start
+     */
+    long getTime();
+
+    /**
+     * Return the value of the property set at this property.
+     *
+     * @param property The property
+     * @param <T>      Type of the property
+     * @return Optional value of the property
+     */
+    @NonNull
+    <T> Optional<T> getValue(Property<T> property);
+
+    /**
+     * Set the value for the property at this property.
+     * If the property is not present, adds it.
+     *
+     * @param property The property
+     * @param value    Value of the property, may be {@code null}
+     * @param <T>      Type of the property
+     */
+    <T> void setValue(Property<T> property, T value);
+
+    /**
+     * Remove the specified property from this property.
+     *
+     * @param property The property to be removed
+     */
+    void removeProperty(Property property);
+
+    /**
+     * Returns all properties of this property
+     * @return Set of properties
+     */
+    Set<Property> getProperties();
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/path/Path.java b/src/main/java/com/replaymod/replaystudio/pathing/path/Path.java
new file mode 100644
index 0000000000000000000000000000000000000000..0233528f27d9b01beb93ed8f7f805ca68ff9e0eb
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/path/Path.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.path;
+
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.property.Property;
+import lombok.NonNull;
+
+import java.util.Collection;
+import java.util.Map;
+import java.util.Optional;
+
+/**
+ * Represents a path for some object consisting of keyframes, path segments and interpolators.
+ */
+public interface Path {
+    /**
+     * Returns the timeline this path belongs to.
+     * @return The timeline
+     */
+    Timeline getTimeline();
+
+    /**
+     * Return an immutable collection of all keyframes in this path.
+     *
+     * @return Collection of keyframes or empty list if none
+     */
+    @NonNull
+    Collection<Keyframe> getKeyframes();
+
+    /**
+     * Return an immutable collection of all segments of this path.
+     *
+     * @return Collection of segments or empty list if none
+     */
+    @NonNull
+    Collection<PathSegment> getSegments();
+
+    /**
+     * Update all interpolators that need updating.
+     * This does <b>not</b> detect changes to keyframes, only interpolators.
+     * If a property has changed, call {@link Interpolator#bake(Map)} before calling this method
+     * or call {@link #updateAll()}.
+     *
+     * @throws IllegalStateException If any path segments do not have an interpolator set.
+     */
+    void update();
+
+    /**
+     * Update all interpolations.
+     * This method is significantly slower than {@link #update()}.
+     *
+     * @throws IllegalStateException If any path segments do not have an interpolator set.
+     */
+    void updateAll();
+
+    /**
+     * Return the value of the property at the specified point in time.
+     *
+     * @param property The property
+     * @param time     Time in milliseconds since the start
+     * @param <T>      Type of the property
+     * @return Optional value of the property
+     * @throws IllegalStateException If {@link #update()} has not yet been called
+     *                               or interpolators have changed since the last call
+     */
+    <T> Optional<T> getValue(Property<T> property, long time);
+
+    /**
+     * Insert a new property at the specified time.
+     * The two new path segments inherit the interpolator of the previous one.
+     * Does <b>not</b> update the interpolators, call {@link #update()} to do so.
+     *
+     * @param time Time in milliseconds
+     * @return The new property
+     */
+    Keyframe insert(long time);
+
+    /**
+     * Returns the property at the specified time.
+     * @param time Time in milliseconds
+     * @return The property or {@code null} if none exists at that timestamp
+     */
+    Keyframe getKeyframe(long time);
+
+    /**
+     * Insert the specified property.
+     * The two new path segments inherit the interpolator of the previous one.
+     * Does <b>not</b> update the interpolators, call {@link #update()} to do so.
+     *
+     * @param keyframe The property
+     */
+    void insert(Keyframe keyframe);
+
+    /**
+     * Removes the specified property.
+     * Does <b>not</b> update the interpolators, call {@link #update()} to do so.
+     *
+     * @param keyframe             The property to remove
+     * @param useFirstInterpolator {@code true} if the new path segment inherits the interpolator of the first segment,
+     *                             {@code false} if it inherits the one of the second segment
+     */
+    void remove(Keyframe keyframe, boolean useFirstInterpolator);
+
+    /**
+     * Set whether this path is active.
+     * If this path is not active, it shouldn't be applied to the game during playback.
+     * @param active {@code true} if active, {@code false} otherwise
+     */
+    void setActive(boolean active);
+
+    /**
+     * Returns whether this path is active.
+     * @return {@code true} if active, {@code false} otherwise
+     * @see #setActive(boolean)
+     */
+    boolean isActive();
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/path/PathSegment.java b/src/main/java/com/replaymod/replaystudio/pathing/path/PathSegment.java
new file mode 100644
index 0000000000000000000000000000000000000000..1bb461ce1af7e6603d17b4da8b305937747def4b
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/path/PathSegment.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.path;
+
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import lombok.NonNull;
+
+/**
+ * Represents a segment of a Path consisting of one start property and one end property.
+ * Each segment is interpolated by one Interpolator. Multiple segments may have the same Interpolator and can only
+ * be interpolated together (they may or may not influence each other indirectly).
+ */
+public interface PathSegment {
+    @NonNull
+    Path getPath();
+
+    /**
+     * Return the start property of this segment.
+     *
+     * @return The first property
+     */
+    @NonNull
+    Keyframe getStartKeyframe();
+
+    /**
+     * Return the end property of this segment.
+     *
+     * @return The second property
+     */
+    @NonNull
+    Keyframe getEndKeyframe();
+
+    /**
+     * Return the interpolator responsible for this path segment.
+     *
+     * @return The interpolator or {@code null} if not yet set
+     * @throws IllegalStateException If no interpolator has been set yet
+     */
+    @NonNull
+    Interpolator getInterpolator();
+
+    /**
+     * Set the interpolator responsible for this path segment.
+     * @param interpolator The interpolator
+     */
+    void setInterpolator(Interpolator interpolator);
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/path/Timeline.java b/src/main/java/com/replaymod/replaystudio/pathing/path/Timeline.java
new file mode 100644
index 0000000000000000000000000000000000000000..c9c12b99cae2fc7d9498d1b4b98a3d35fd300467
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/path/Timeline.java
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.path;
+
+import com.replaymod.replaystudio.pathing.change.Change;
+import com.replaymod.replaystudio.pathing.property.Property;
+
+import java.util.List;
+import java.util.Optional;
+
+/**
+ * A timeline is a collection of paths that are played together.
+ */
+public interface Timeline {
+    /**
+     * Returns the list of paths that compose this timeline.
+     * The returned list can be modified and changes are reflected on the timeline.
+     * The order of the paths is their priority in case of conflicting properties.
+     * The first path to support a property is the one whose value is used.
+     * @return List of paths
+     */
+    List<Path> getPaths();
+
+    /**
+     * Creates a new path and adds it to this timeline.
+     * @return A new Path instance
+     */
+    Path createPath();
+
+    /**
+     * Return the value of the property at the specified point in time.
+     *
+     * @param property The property
+     * @param time     Time in milliseconds since the start
+     * @param <T>      Type of the property
+     * @return Optional value of the property
+     * @throws IllegalStateException If {@link Path#update()} has not yet been called
+     *                               or interpolators have changed since the last call
+     */
+    <T> Optional<T> getValue(Property<T> property, long time);
+
+    /**
+     * Apply the values of all properties at the specified time to the game.
+     *
+     * @param time      The time on this path
+     * @param replayHandler The ReplayHandler instance
+     */
+    void applyToGame(long time, Object replayHandler);
+
+    /**
+     * Registers the specified property for use in keyframes in this path.
+     * @param property The property
+     */
+    void registerProperty(Property property);
+
+    /**
+     * Returns the property corresponding to the specified id.
+     * The id is either "groupId:propertyId" or "propertyId" if the property doesn't belong to any group.
+     * @param id Id of the property
+     * @return The property or {@code null} if not existent
+     */
+    Property getProperty(String id);
+
+    /**
+     * Apply the change and push it on the undo stack.
+     * Clears the redo stack.
+     * @param change The change
+     * @throws IllegalStateException if the change has already been applied
+     */
+    void applyChange(Change change);
+
+    /**
+     * Push the change on the undo stack.
+     * Clears the redo stack.
+     * @param change The change
+     * @throws IllegalStateException if the change has not yet been applied
+     */
+    void pushChange(Change change);
+
+    /**
+     * Undo the last change and push it on the redo stack.
+     * @throws java.util.NoSuchElementException if the stack is empty
+     */
+    void undoLastChange();
+
+    /**
+     * Redo the last undone change and push it back on the undo stack.
+     * @throws java.util.NoSuchElementException if the stack is empty
+     */
+    void redoLastChange();
+
+    /**
+     * Peek at the top element of the undo stack.
+     * The returned element must never be undone manually.
+     * @return Top element on the undo stack, or {@code null} if the stack is empty
+     */
+    Change peekUndoStack();
+
+    /**
+     * Peek at the top element of the redo stack.
+     * The returned element must never be redone manually.
+     * @return Top element on the redo stack, or {@code null} if the stack is empty
+     */
+    Change peekRedoStack();
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractProperty.java b/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractProperty.java
new file mode 100644
index 0000000000000000000000000000000000000000..877131600e3d0f2014bdbbef38a359c4329f2416
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractProperty.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+import com.replaymod.replaystudio.util.I18n;
+
+/**
+ * Abstract base class for most properties.
+ */
+public abstract class AbstractProperty<T> implements Property<T> {
+    private final String id, localizationKey;
+    private final PropertyGroup propertyGroup;
+    private final T initialValue;
+
+    public AbstractProperty(String id, String localizationKey, PropertyGroup propertyGroup, T initialValue) {
+        this.id = id;
+        this.localizationKey = localizationKey;
+        this.propertyGroup = propertyGroup;
+        this.initialValue = initialValue;
+
+        if (propertyGroup != null) {
+            propertyGroup.getProperties().add(this);
+        }
+    }
+
+    @Override
+    public String getLocalizedName() {
+        return I18n.format(localizationKey);
+    }
+
+    @Override
+    public PropertyGroup getGroup() {
+        return propertyGroup;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public T getNewValue() {
+        return initialValue;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractPropertyGroup.java b/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractPropertyGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..67d2df115c66561ffddb08c790b75fbe63304c6e
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractPropertyGroup.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+import com.replaymod.replaystudio.util.I18n;
+import lombok.RequiredArgsConstructor;
+
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Abstract base class for most property groups.
+ */
+@RequiredArgsConstructor
+public abstract class AbstractPropertyGroup implements PropertyGroup {
+    private final String id, localizationKey;
+    private final List<Property> properties = new ArrayList<>();
+
+    @Override
+    public String getLocalizedName() {
+        return I18n.format(localizationKey);
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    @Override
+    public List<Property> getProperties() {
+        return properties;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractPropertyPart.java b/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractPropertyPart.java
new file mode 100644
index 0000000000000000000000000000000000000000..80b9a904825b3f9f68df55b13cdfc1a75d6cc8c4
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/AbstractPropertyPart.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+public abstract class AbstractPropertyPart<T> implements PropertyPart<T> {
+    private final Property<T> property;
+    private final boolean interpolatable;
+    private final double upperBound;
+
+    public AbstractPropertyPart(Property<T> property, boolean interpolatable) {
+        this(property, interpolatable, Double.NaN);
+    }
+
+    public AbstractPropertyPart(Property<T> property, boolean interpolatable, double upperBound) {
+        this.property = property;
+        this.interpolatable = interpolatable;
+        this.upperBound = upperBound;
+    }
+
+    @Override
+    public Property<T> getProperty() {
+        return property;
+    }
+
+    @Override
+    public boolean isInterpolatable() {
+        return interpolatable;
+    }
+
+    @Override
+    public double getUpperBound() {
+        return upperBound;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/Property.java b/src/main/java/com/replaymod/replaystudio/pathing/property/Property.java
new file mode 100644
index 0000000000000000000000000000000000000000..c5355c750061bd83b7b1c35fa178da7d8807fd4c
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/Property.java
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+import lombok.NonNull;
+
+import java.io.IOException;
+import java.util.Collection;
+
+/**
+ * Represents a property of a property.
+ * Such properties may or may not be interpolated between keyframes.
+ * <br>
+ * If a property cannot be interpolated between keyframes, it is only active between two keyframes having the same
+ * value for that property.
+ *
+ * @param <T> The type of the property, must be immutable
+ */
+public interface Property<T> {
+    /**
+     * Returns the localized name of this property.
+     *
+     * @return Localized name.
+     */
+    @NonNull
+    String getLocalizedName();
+
+    /**
+     * Returns the group this property belongs to.
+     *
+     * @return The group
+     */
+    PropertyGroup getGroup();
+
+    /**
+     * Returns an ID unique for this property.
+     * There may be multiple instances for the same property ID
+     * if they all represent the same concept (all x-Coordinate).
+     *
+     * @return Unique ID
+     */
+    @NonNull
+    String getId();
+
+    /**
+     * Returns a new value for this property.
+     *
+     * @return New value, may be {@code null}
+     */
+    T getNewValue();
+
+    /**
+     * Returns (optionally) interpolatable parts of this property.
+     *
+     * @return Collection of parts
+     */
+    Collection<PropertyPart<T>> getParts();
+
+    /**
+     * Appy the specified value of this property to the game.
+     *
+     * @param value         The value of this property
+     * @param replayHandler The ReplayHandler instance
+     */
+    void applyToGame(T value, Object replayHandler);
+
+    /**
+     * Writes the specified value of this property to JSON.
+     *
+     * @param writer The json writer
+     * @param value  The value
+     */
+    void toJson(JsonWriter writer, T value) throws IOException;
+
+    /**
+     * Reads the value of this property from JSON.
+     *
+     * @param reader The json reader
+     * @return The value
+     */
+    T fromJson(JsonReader reader) throws IOException;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyGroup.java b/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyGroup.java
new file mode 100644
index 0000000000000000000000000000000000000000..dfdbfebab917e79f150a85ad552158ffd3ae76e3
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyGroup.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+import com.replaymod.replaystudio.pathing.change.Change;
+import lombok.NonNull;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.Callable;
+
+/**
+ * Represents a group of property properties.
+ * These groups are displayed and stored together.
+ * The same property id may exist in multiple groups.<br>
+ * Groups may also define a way of setting their properties in one simple way (e.g. "set to current position").
+ */
+public interface PropertyGroup {
+    /**
+     * Returns the localized name of this group.
+     *
+     * @return Localized name.
+     */
+    @NonNull
+    String getLocalizedName();
+
+    /**
+     * Returns an ID unique for this group.
+     *
+     * @return Unique ID
+     */
+    @NonNull
+    String getId();
+
+    /**
+     * Return a list of all properties in this group.
+     *
+     * @return List of properties or empty list if none.
+     */
+    @NonNull
+    List<Property> getProperties();
+
+    /**
+     * Return a Callable which can be used to set all properties in this group at once.
+     * It is up to the caller to apply those changes to the path. If those changes are not applied
+     * immediately, their content may become invalid and applying them results in undefined behavior.
+     *
+     * @return Optional callable
+     */
+    @NonNull
+    Optional<Callable<Change>> getSetter();
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyPart.java b/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyPart.java
new file mode 100644
index 0000000000000000000000000000000000000000..64d908607c76226c341f854dae0fdbbc56032f8f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyPart.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+/**
+ * Represents an (optionally) interpolatable part of a property (such as the X coordinate of the position property).
+ * @param <T> Type of the property
+ */
+public interface PropertyPart<T> {
+    Property<T> getProperty();
+
+    /**
+     * Returns whether this part should be interpolated between keyframes.
+     * Examples would be x/y/z coordinates or sun location.
+     * Counterexamples are spectated entity id or
+     * @return {@code true} if this part should be interpolated, {@code false} otherwise
+     */
+    boolean isInterpolatable();
+
+    /**
+     * Returns the upper bound (exclusive) of the range of this part, the lower bound is always 0 (inclusive).<br>
+     * If {@link Double#NaN} is returned, no range restrictions are imposed on this part.<br>
+     * If the range is well defined (> 0), then this part is treated as a cyclic value which wraps around.
+     * Cyclic values will be interpolated differently than normal values as there might be a shortcut by passing
+     * over the bounds.<br>
+     * Negative values are wrapped around to positive values automatically.
+     * <br>
+     * E.g. a value with {@code getUpperBound() == 360} when interpolated from 358 to 1 will go 358, 359, 0, 1 whereas
+     * one with {@code Double.isNaN(getUpperBound())} will go 358, 357, 356, ..., 3, 2, 1
+     * @return The upper bound or {@link Double#NaN}
+     */
+    double getUpperBound();
+
+    /**
+     * Convert this part of the value to a double for interpolation.
+     * @param value The value, may be {@code null}
+     * @return A double representing this value
+     * @throws UnsupportedOperationException if this part is not interpolatable
+     */
+    double toDouble(T value);
+
+    /**
+     * Convert the specified double to this part of the value and return it combined with the value for other parts.
+     * @param value Value of other parts
+     * @param d Value for this part
+     * @return Combined value
+     * @throws UnsupportedOperationException if this part is not interpolatable
+     */
+    T fromDouble(T value, double d);
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyParts.java b/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyParts.java
new file mode 100644
index 0000000000000000000000000000000000000000..9afddd0673efd25b59e1b38671dad1381283c127
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/property/PropertyParts.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.property;
+
+import org.apache.commons.lang3.tuple.Triple;
+
+public class PropertyParts {
+    private PropertyParts(){}
+
+    public static class ForInteger extends AbstractPropertyPart<Integer> {
+        public ForInteger(Property<Integer> property, boolean interpolatable) {
+            super(property, interpolatable);
+        }
+
+        public ForInteger(Property<Integer> property, boolean interpolatable, int upperBound) {
+            super(property, interpolatable, upperBound);
+        }
+
+        @Override
+        public double toDouble(Integer value) {
+            return value;
+        }
+
+        @Override
+        public Integer fromDouble(Integer value, double d) {
+            return (int) Math.round(d);
+        }
+    }
+
+    public static class ForDoubleTriple extends AbstractPropertyPart<Triple<Double, Double, Double>> {
+        private final TripleElement element;
+        public ForDoubleTriple(Property<Triple<Double, Double, Double>> property, boolean interpolatable, TripleElement element) {
+            super(property, interpolatable);
+            this.element = element;
+        }
+
+        public ForDoubleTriple(Property<Triple<Double, Double, Double>> property, boolean interpolatable, double upperBound, TripleElement element) {
+            super(property, interpolatable, upperBound);
+            this.element = element;
+        }
+
+        @Override
+        public double toDouble(Triple<Double, Double, Double> value) {
+            switch (element) {
+                case LEFT: return value.getLeft();
+                case MIDDLE: return value.getMiddle();
+                case RIGHT: return value.getRight();
+            }
+            throw new AssertionError(element);
+        }
+
+        @Override
+        public Triple<Double, Double, Double> fromDouble(Triple<Double, Double, Double> value, double d) {
+            switch (element) {
+                case LEFT: return Triple.of(d, value.getMiddle(), value.getRight());
+                case MIDDLE: return Triple.of(value.getLeft(), d, value.getRight());
+                case RIGHT: return Triple.of(value.getLeft(), value.getMiddle(), d);
+            }
+            throw new AssertionError(element);
+        }
+    }
+
+    public static class ForFloatTriple extends AbstractPropertyPart<Triple<Float, Float, Float>> {
+        private final TripleElement element;
+        public ForFloatTriple(Property<Triple<Float, Float, Float>> property, boolean interpolatable, TripleElement element) {
+            super(property, interpolatable);
+            this.element = element;
+        }
+
+        public ForFloatTriple(Property<Triple<Float, Float, Float>> property, boolean interpolatable, float upperBound, TripleElement element) {
+            super(property, interpolatable, upperBound);
+            this.element = element;
+        }
+
+        @Override
+        public double toDouble(Triple<Float, Float, Float> value) {
+            switch (element) {
+                case LEFT: return value.getLeft();
+                case MIDDLE: return value.getMiddle();
+                case RIGHT: return value.getRight();
+            }
+            throw new AssertionError(element);
+        }
+
+        @Override
+        public Triple<Float, Float, Float> fromDouble(Triple<Float, Float, Float> value, double d) {
+            switch (element) {
+                case LEFT: return Triple.of((float) d, value.getMiddle(), value.getRight());
+                case MIDDLE: return Triple.of(value.getLeft(), (float) d, value.getRight());
+                case RIGHT: return Triple.of(value.getLeft(), value.getMiddle(), (float) d);
+            }
+            throw new AssertionError(element);
+        }
+    }
+
+    public enum TripleElement {
+        LEFT, MIDDLE, RIGHT;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/serialize/LegacyKeyframeSetAdapter.java b/src/main/java/com/replaymod/replaystudio/pathing/serialize/LegacyKeyframeSetAdapter.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf0c96e5315caf0d0def003116cd287f2a454c71
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/serialize/LegacyKeyframeSetAdapter.java
@@ -0,0 +1,146 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.serialize;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonWriter;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import static com.replaymod.replaystudio.pathing.serialize.LegacyTimelineConverter.*;
+
+public class LegacyKeyframeSetAdapter extends TypeAdapter<KeyframeSet[]> {
+
+    public LegacyKeyframeSetAdapter() {
+        super();
+    }
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public KeyframeSet[] read(JsonReader in) throws IOException {
+        List<KeyframeSet> sets = new ArrayList<>();
+
+        in.beginArray();
+        while(in.hasNext()) { //iterate over all array entries
+
+            KeyframeSet set = new KeyframeSet();
+            List<Keyframe> positionKeyframes = new ArrayList<>();
+            List<Keyframe> timeKeyframes = new ArrayList<>();
+
+            in.beginObject();
+            while(in.hasNext()) { //iterate over all object entries
+                String jsonTag = in.nextName();
+
+                if("name".equals(jsonTag)) {
+                    set.name = in.nextString();
+
+                    //TODO: Adapt to new Spectator Keyframe system
+                } else if("positionKeyframes".equals(jsonTag)) {
+                    in.beginArray();
+                    while(in.hasNext()) {
+                        Keyframe<AdvancedPosition> newKeyframe = new Keyframe<>();
+                        Integer spectatedEntityID = null;
+                        in.beginObject();
+                        while(in.hasNext()) {
+                            String jsonKeyframeTag = in.nextName();
+                            if("value".equals(jsonKeyframeTag) || "position".equals(jsonKeyframeTag)) {
+                                SpectatorData spectatorData = new Gson().fromJson(in, SpectatorData.class);
+                                if (spectatorData.spectatedEntityID != null) {
+                                    newKeyframe.value = spectatorData;
+                                } else {
+                                    newKeyframe.value = new AdvancedPosition();
+                                    newKeyframe.value.x = spectatorData.x;
+                                    newKeyframe.value.y = spectatorData.y;
+                                    newKeyframe.value.z = spectatorData.z;
+                                    newKeyframe.value.yaw = spectatorData.yaw;
+                                    newKeyframe.value.pitch = spectatorData.pitch;
+                                    newKeyframe.value.roll = spectatorData.roll;
+                                }
+                            } else if("realTimestamp".equals(jsonKeyframeTag)) {
+                                newKeyframe.realTimestamp = in.nextInt();
+                            } else if("spectatedEntityID".equals(jsonKeyframeTag)) {
+                                spectatedEntityID = in.nextInt();
+                            }
+                        }
+
+                        if(spectatedEntityID != null) {
+                            AdvancedPosition pos = newKeyframe.value;
+                            SpectatorData spectatorData = new SpectatorData();
+                            spectatorData.spectatedEntityID = spectatedEntityID;
+                            newKeyframe.value = spectatorData;
+                            newKeyframe.value.x = pos.x;
+                            newKeyframe.value.y = pos.y;
+                            newKeyframe.value.z = pos.z;
+                            newKeyframe.value.yaw = pos.yaw;
+                            newKeyframe.value.pitch = pos.pitch;
+                            newKeyframe.value.roll = pos.roll;
+                        }
+
+                        in.endObject();
+
+                        positionKeyframes.add(newKeyframe);
+                    }
+                    in.endArray();
+
+                } else if("timeKeyframes".equals(jsonTag)) {
+                    in.beginArray();
+                    while(in.hasNext()) {
+                        Keyframe<TimestampValue> newKeyframe = new Keyframe<>();
+
+                        in.beginObject();
+                        while(in.hasNext()) {
+                            String jsonKeyframeTag = in.nextName();
+                            if("timestamp".equals(jsonKeyframeTag)) {
+                                TimestampValue timestampValue = new TimestampValue();
+                                timestampValue.value = in.nextInt();
+                                newKeyframe.value = timestampValue;
+                            } else if("value".equals(jsonKeyframeTag)) {
+                                newKeyframe.value = new Gson().fromJson(in, TimestampValue.class);
+                            } else if("realTimestamp".equals(jsonKeyframeTag)) {
+                                newKeyframe.realTimestamp = in.nextInt();
+                            }
+                        }
+                        in.endObject();
+
+                        timeKeyframes.add(newKeyframe);
+                    }
+                    in.endArray();
+
+                } else if("customObjects".equals(jsonTag)) {
+                    set.customObjects = new Gson().fromJson(in, CustomImageObject[].class);
+                }
+            }
+            in.endObject();
+
+            set.positionKeyframes = positionKeyframes.toArray(new Keyframe[positionKeyframes.size()]);
+            set.timeKeyframes = timeKeyframes.toArray(new Keyframe[timeKeyframes.size()]);
+            sets.add(set);
+        }
+        in.endArray();
+
+        return sets.toArray(new KeyframeSet[sets.size()]);
+    }
+
+    @Override
+    public void write(JsonWriter out, KeyframeSet[] value) throws IOException {}
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/serialize/LegacyTimelineConverter.java b/src/main/java/com/replaymod/replaystudio/pathing/serialize/LegacyTimelineConverter.java
new file mode 100644
index 0000000000000000000000000000000000000000..b14df6d2279dcbbd41beb46111db117d4d98be41
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/serialize/LegacyTimelineConverter.java
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.serialize;
+
+import com.google.common.base.Optional;
+import com.google.gson.GsonBuilder;
+import com.replaymod.replaystudio.pathing.PathingRegistry;
+import com.replaymod.replaystudio.pathing.interpolation.CubicSplineInterpolator;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.interpolation.LinearInterpolator;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.replay.ReplayFile;
+import org.apache.commons.lang3.tuple.Triple;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.util.*;
+
+public class LegacyTimelineConverter {
+    public static Map<String, Timeline> convert(PathingRegistry registry, ReplayFile replayFile) throws IOException {
+        KeyframeSet[] keyframeSets = readAndParse(replayFile);
+        if (keyframeSets == null) {
+            return Collections.emptyMap();
+        }
+
+        Map<String, Timeline> timelines = new LinkedHashMap<>();
+        for (KeyframeSet keyframeSet : keyframeSets) {
+            timelines.put(keyframeSet.name, convert(registry, keyframeSet));
+        }
+        return timelines;
+    }
+
+    private static Optional<InputStream> read(ReplayFile replayFile) throws IOException {
+        Optional<InputStream> in = replayFile.get("paths.json");
+        if (!in.isPresent()) {
+            in = replayFile.get("paths");
+        }
+        return in;
+    }
+
+    private static KeyframeSet[] parse(InputStream in) {
+        return new GsonBuilder()
+                .registerTypeAdapter(KeyframeSet[].class, new LegacyKeyframeSetAdapter())
+                .create().fromJson(new InputStreamReader(in), KeyframeSet[].class);
+    }
+
+    private static KeyframeSet[] readAndParse(ReplayFile replayFile) throws IOException {
+        Optional<InputStream> optIn = read(replayFile);
+        if (!optIn.isPresent()) {
+            return null;
+        }
+        KeyframeSet[] keyframeSets;
+        try (InputStream in = optIn.get()) {
+            keyframeSets = parse(in);
+        }
+        return keyframeSets;
+    }
+
+    @SuppressWarnings("unchecked")
+    private static Timeline convert(PathingRegistry registry, KeyframeSet keyframeSet) {
+        Timeline timeline = registry.createTimeline();
+        Property timestamp = timeline.getProperty("timestamp");
+        Property cameraPosition = timeline.getProperty("camera:position");
+        Property cameraRotation = timeline.getProperty("camera:rotation");
+
+        Path timePath = timeline.createPath();
+        Path positionPath = timeline.createPath();
+        for (Keyframe<AdvancedPosition> positionKeyframe : keyframeSet.positionKeyframes) {
+            AdvancedPosition value = positionKeyframe.value;
+            com.replaymod.replaystudio.pathing.path.Keyframe keyframe = getKeyframe(positionPath, positionKeyframe.realTimestamp);
+            keyframe.setValue(cameraPosition, Triple.of(value.x, value.y, value.z));
+            keyframe.setValue(cameraRotation, Triple.of(value.yaw, value.pitch, value.roll));
+            if (value instanceof SpectatorData) {
+                // TODO Spectator keyframes
+            }
+        }
+        for (Keyframe<TimestampValue> timeKeyframe : keyframeSet.timeKeyframes) {
+            TimestampValue value = timeKeyframe.value;
+            com.replaymod.replaystudio.pathing.path.Keyframe keyframe = getKeyframe(timePath, timeKeyframe.realTimestamp);
+            keyframe.setValue(timestamp, (int) value.value);
+        }
+
+        Interpolator timeInterpolator = new LinearInterpolator();
+        timeInterpolator.registerProperty(timestamp);
+        timePath.getSegments().forEach(s -> s.setInterpolator(timeInterpolator));
+
+        Interpolator positionInterpolator = new CubicSplineInterpolator();
+        positionInterpolator.registerProperty(cameraPosition);
+        positionInterpolator.registerProperty(cameraRotation);
+        positionPath.getSegments().forEach(s -> s.setInterpolator(positionInterpolator));
+
+        return timeline;
+    }
+
+    private static com.replaymod.replaystudio.pathing.path.Keyframe getKeyframe(Path path, long time) {
+        com.replaymod.replaystudio.pathing.path.Keyframe keyframe = path.getKeyframe(time);
+        if (keyframe == null) {
+            keyframe = path.insert(time);
+        }
+        return keyframe;
+    }
+
+    static class KeyframeSet {
+        String name;
+        Keyframe<AdvancedPosition>[] positionKeyframes;
+        Keyframe<TimestampValue>[] timeKeyframes;
+        CustomImageObject[] customObjects;
+    }
+    static class Keyframe<T> {
+        int realTimestamp;
+        T value;
+    }
+    static class Position {
+        double x, y, z;
+    }
+    static class AdvancedPosition extends Position {
+        float pitch, yaw, roll;
+    }
+    static class SpectatorData extends AdvancedPosition {
+        Integer spectatedEntityID;
+        SpectatingMethod spectatingMethod;
+        SpectatorDataThirdPersonInfo thirdPersonInfo;
+        enum SpectatingMethod {
+            FIRST_PERSON, SHOULDER_CAM;
+        }
+    }
+    static class SpectatorDataThirdPersonInfo {
+        double shoulderCamDistance;
+        double shoulderCamPitchOffset;
+        double shoulderCamYawOffset;
+        double shoulderCamSmoothness;
+    }
+    static class TimestampValue {
+        double value;
+    }
+    static class CustomImageObject {
+        String name;
+        UUID linkedAsset;
+        float width, height;
+        float textureWidth, textureHeight;
+        Transformations transformations = new Transformations();
+    }
+    static class Transformations {
+        Position defaultAnchor, defaultPosition, defaultOrientation, defaultScale;
+        NumberValue defaultOpacity;
+
+        List<Position> anchorKeyframes;
+        List<Position> positionKeyframes;
+        List<Position> orientationKeyframes;
+        List<Position> scaleKeyframes;
+        List<NumberValue> opacityKeyframes;
+    }
+    static class NumberValue {
+        double value;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/pathing/serialize/TimelineSerialization.java b/src/main/java/com/replaymod/replaystudio/pathing/serialize/TimelineSerialization.java
new file mode 100644
index 0000000000000000000000000000000000000000..7464a8bec89942cb457ffdb8168ea1b5133f8acf
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/pathing/serialize/TimelineSerialization.java
@@ -0,0 +1,247 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.pathing.serialize;
+
+import com.google.common.base.Charsets;
+import com.google.common.base.Optional;
+import com.google.common.io.CharStreams;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+import com.replaymod.replaystudio.pathing.PathingRegistry;
+import com.replaymod.replaystudio.pathing.interpolation.Interpolator;
+import com.replaymod.replaystudio.pathing.path.Keyframe;
+import com.replaymod.replaystudio.pathing.path.Path;
+import com.replaymod.replaystudio.pathing.path.PathSegment;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.property.Property;
+import com.replaymod.replaystudio.replay.ReplayFile;
+
+import java.io.*;
+import java.util.*;
+
+public class TimelineSerialization {
+    private static final String FILE_ENTRY = "timelines.json";
+
+    private final PathingRegistry registry;
+    private final ReplayFile replayFile;
+
+    public TimelineSerialization(PathingRegistry registry, ReplayFile replayFile) {
+        this.registry = registry;
+        this.replayFile = replayFile;
+    }
+
+    public void save(Map<String, Timeline> timelines) throws IOException {
+        String serialized = serialize(timelines);
+        try (OutputStream out = replayFile.write(FILE_ENTRY)) {
+            out.write(serialized.getBytes(Charsets.UTF_8));
+        }
+    }
+
+    public Map<String, Timeline> load() throws IOException {
+        Map<String, Timeline> timelines = new LinkedHashMap<>(LegacyTimelineConverter.convert(registry, replayFile));
+
+        Optional<InputStream> optionalIn = replayFile.get(FILE_ENTRY);
+        if (optionalIn.isPresent()) {
+            String serialized;
+            try (InputStream in = optionalIn.get()) {
+                serialized = CharStreams.toString(new InputStreamReader(in, Charsets.UTF_8));
+            }
+            Map<String, Timeline> deserialized = deserialize(serialized);
+            timelines.putAll(deserialized);
+        }
+        return timelines;
+    }
+
+    public String serialize(Map<String, Timeline> timelines) throws IOException {
+        StringWriter stringWriter = new StringWriter();
+        JsonWriter writer = new JsonWriter(stringWriter);
+        writer.beginObject();
+        for (Map.Entry<String, Timeline> entry : timelines.entrySet()) {
+            Timeline timeline = entry.getValue();
+            writer.name(entry.getKey()).beginArray();
+            for (Path path : timeline.getPaths()) {
+                writer.beginObject();
+                writer.name("keyframes").beginArray();
+                for (Keyframe keyframe : path.getKeyframes()) {
+                    writer.beginObject();
+                    writer.name("time").value(keyframe.getTime());
+                    writer.name("properties").beginObject();
+                    for (Property<?> property : keyframe.getProperties()) {
+                        writer.name((property.getGroup() == null ? "" : property.getGroup().getId() + ":") + property.getId());
+                        writeProperty(writer, keyframe, property);
+                    }
+                    writer.endObject();
+                    writer.endObject();
+                }
+                writer.endArray();
+                Map<Interpolator, Integer> interpolators = new LinkedHashMap<>();
+                writer.name("segments").beginArray();
+                for (PathSegment segment : path.getSegments()) {
+                    Interpolator interpolator = segment.getInterpolator();
+                    if (interpolator == null) {
+                        writer.nullValue();
+                    } else {
+                        Integer index = interpolators.get(interpolator);
+                        if (index == null) {
+                            interpolators.put(interpolator, index = interpolators.size());
+                        }
+                        writer.value(index);
+                    }
+                }
+                writer.endArray();
+                writer.name("interpolators").beginArray();
+                for (Interpolator interpolator : interpolators.keySet()) {
+                    writer.beginObject();
+                    writer.name("type");
+                    registry.serializeInterpolator(writer, interpolator);
+                    writer.name("properties").beginArray();
+                    for (Property<?> property : interpolator.getKeyframeProperties()) {
+                        writer.value((property.getGroup() == null ? "" : property.getGroup().getId() + ":") + property.getId());
+                    }
+                    writer.endArray();
+                    writer.endObject();
+                }
+                writer.endArray();
+                writer.endObject();
+            }
+            writer.endArray();
+        }
+        writer.endObject();
+        writer.flush();
+        return stringWriter.toString();
+    }
+
+    private static <T> void writeProperty(JsonWriter writer, Keyframe keyframe, Property<T> property) throws IOException {
+        property.toJson(writer, keyframe.getValue(property).get());
+    }
+
+    public Map<String, Timeline> deserialize(String serialized) throws IOException {
+        JsonReader reader = new JsonReader(new StringReader(serialized));
+        Map<String, Timeline> timelines = new LinkedHashMap<>();
+        reader.beginObject();
+        while (reader.hasNext()) {
+            Timeline timeline = registry.createTimeline();
+            timelines.put(reader.nextName(), timeline);
+            reader.beginArray();
+            while (reader.hasNext()) {
+                Path path = timeline.createPath();
+                reader.beginObject();
+                List<Integer> segments = new ArrayList<>();
+                List<Interpolator> interpolators = new ArrayList<>();
+                while (reader.hasNext()) {
+                    switch (reader.nextName()) {
+                        case "keyframes":
+                            reader.beginArray();
+                            while (reader.hasNext()) {
+                                long time = 0;
+                                Map<Property, Object> properties = new HashMap<>();
+                                reader.beginObject();
+                                while (reader.hasNext()) {
+                                    switch (reader.nextName()) {
+                                        case "time":
+                                            time = reader.nextLong();
+                                            break;
+                                        case "properties":
+                                            reader.beginObject();
+                                            while (reader.hasNext()) {
+                                                String id = reader.nextName();
+                                                Property property = timeline.getProperty(id);
+                                                if (property == null) {
+                                                    throw new IOException("Unknown property: " + id);
+                                                }
+                                                Object value = property.fromJson(reader);
+                                                properties.put(property, value);
+                                            }
+                                            reader.endObject();
+                                            break;
+                                    }
+                                }
+                                reader.endObject();
+                                Keyframe keyframe = path.insert(time);
+                                for (Map.Entry<Property, Object> entry : properties.entrySet()) {
+                                    keyframe.setValue(entry.getKey(), entry.getValue());
+                                }
+                            }
+                            reader.endArray();
+                            break;
+                        case "segments":
+                            reader.beginArray();
+                            while (reader.hasNext()) {
+                                if (reader.peek() == JsonToken.NULL) {
+                                    reader.nextNull();
+                                    segments.add(null);
+                                } else {
+                                    segments.add(reader.nextInt());
+                                }
+                            }
+                            reader.endArray();
+                            break;
+                        case "interpolators":
+                            reader.beginArray();
+                            while (reader.hasNext()) {
+                                reader.beginObject();
+                                Interpolator interpolator = null;
+                                Set<String> properties = new HashSet<>();
+                                while (reader.hasNext()) {
+                                    switch (reader.nextName()) {
+                                        case "type":
+                                            interpolator = registry.deserializeInterpolator(reader);
+                                            break;
+                                        case "properties":
+                                            reader.beginArray();
+                                            while (reader.hasNext()) {
+                                                properties.add(reader.nextString());
+                                            }
+                                            reader.endArray();
+                                            break;
+                                    }
+                                }
+                                if (interpolator == null) {
+                                    throw new IOException("Missing interpolator type");
+                                }
+                                for (String propertyName : properties) {
+                                    Property property = timeline.getProperty(propertyName);
+                                    if (property == null) {
+                                        throw new IOException("Timeline does not know property '" + propertyName + "'");
+                                    }
+                                    interpolator.registerProperty(property);
+                                }
+                                interpolators.add(interpolator);
+                                reader.endObject();
+                            }
+                            reader.endArray();
+                            break;
+                    }
+                }
+                Iterator<Integer> iter = segments.iterator();
+                for (PathSegment segment : path.getSegments()) {
+                    Integer next = iter.next();
+                    if (next != null) {
+                        segment.setInterpolator(interpolators.get(next));
+                    }
+                }
+                reader.endObject();
+            }
+            reader.endArray();
+        }
+        reader.endObject();
+        return timelines;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/Packet.java b/src/main/java/com/replaymod/replaystudio/protocol/Packet.java
new file mode 100644
index 0000000000000000000000000000000000000000..c4565536d382f74a813c0bdb06f2f332db6f0e05
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/Packet.java
@@ -0,0 +1,404 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.buffer.ByteBufOutputStream;
+import io.netty.buffer.Unpooled;
+import com.github.steveice10.opennbt.NBTIO;
+import com.github.steveice10.opennbt.tag.TagCreateException;
+import com.github.steveice10.opennbt.tag.TagRegistry;
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.github.steveice10.opennbt.tag.builtin.Tag;
+import com.github.steveice10.packetlib.io.NetInput;
+import com.github.steveice10.packetlib.io.NetOutput;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetInput;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetOutput;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.data.StringOrNbtText;
+import com.replaymod.replaystudio.util.IGlobalPosition;
+import com.replaymod.replaystudio.util.IOConsumer;
+import com.replaymod.replaystudio.util.IOSupplier;
+import com.replaymod.replaystudio.util.IPosition;
+
+import java.io.*;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.List;
+import java.util.Objects;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+
+public class Packet {
+    private final PacketTypeRegistry registry;
+    private final int id;
+    private final PacketType type;
+    private final ByteBuf buf;
+
+    public Packet(PacketTypeRegistry registry, PacketType type) {
+        this(registry, type, Unpooled.buffer());
+    }
+
+    public Packet(PacketTypeRegistry registry, PacketType type, ByteBuf buf) {
+        this(registry, registry.getId(type), type, buf);
+    }
+
+    public Packet(PacketTypeRegistry registry, int packetId, ByteBuf buf) {
+        this(registry, packetId, registry.getType(packetId), buf);
+    }
+
+    public Packet(PacketTypeRegistry registry, int id, PacketType type, ByteBuf buf) {
+        this.registry = registry;
+        this.id = id;
+        this.type = type;
+        this.buf = buf;
+    }
+
+    public PacketTypeRegistry getRegistry() {
+        return registry;
+    }
+
+    public ProtocolVersion getProtocolVersion() {
+        return registry.getVersion();
+    }
+
+    public int getId() {
+        return id;
+    }
+
+    public PacketType getType() {
+        return type;
+    }
+
+    public ByteBuf getBuf() {
+        return buf;
+    }
+
+    public Packet retain() {
+        buf.retain();
+        return this;
+    }
+
+    public Packet copy() {
+        return new Packet(registry, id, type, buf.retainedSlice());
+    }
+
+    public boolean release() {
+        return buf.release();
+    }
+
+    public Reader reader() {
+        return new Reader(this, buf);
+    }
+
+    public Writer overwrite() {
+        buf.writerIndex(buf.readerIndex());
+        return new Writer(this, buf);
+    }
+
+    public boolean atLeast(ProtocolVersion protocolVersion) {
+        return registry.atLeast(protocolVersion);
+    }
+
+    public boolean atMost(ProtocolVersion protocolVersion) {
+        return registry.atMost(protocolVersion);
+    }
+
+    public boolean olderThan(ProtocolVersion protocolVersion) {
+        return registry.olderThan(protocolVersion);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        Packet packet = (Packet) o;
+        return id == packet.id &&
+                registry.equals(packet.registry) &&
+                buf.equals(packet.buf);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(registry, id, buf);
+    }
+
+    public static class Reader extends ByteBufNetInput implements AutoCloseable {
+        private final Packet packet;
+        private final ByteBuf buf;
+        private int orgReaderIndex;
+
+        Reader(Packet packet, ByteBuf buf) {
+            super(buf);
+            this.packet = packet;
+            this.buf = buf;
+            this.orgReaderIndex = buf.readerIndex();
+        }
+
+        @Override
+        public void close() {
+            buf.readerIndex(orgReaderIndex);
+        }
+
+        public IPosition readPosition() throws IOException {
+            return readPosition(packet.registry, this);
+        }
+
+        public static IPosition readPosition(PacketTypeRegistry registry, NetInput in) throws IOException {
+            long val = in.readLong();
+            long x, y, z;
+            if (registry.atLeast(ProtocolVersion.v1_14)) {
+                x = val >> 38;
+                y = val;
+                z = val >> 12;
+            } else {
+                x = val >> 38;
+                y = val >> 26;
+                z = val;
+            }
+            return new IPosition((int) (x << 38 >> 38), (int) (y << 52 >> 52), (int) (z << 38 >> 38));
+        }
+
+        public IGlobalPosition readGlobalPosition() throws IOException {
+            return readGlobalPosition(packet.registry, this);
+        }
+
+        public static IGlobalPosition readGlobalPosition(PacketTypeRegistry registry, NetInput in) throws IOException {
+            String dimension = in.readString();
+            return new IGlobalPosition(dimension, readPosition(registry, in));
+        }
+
+        public CompoundTag readNBT() throws IOException {
+            return readNBT(packet.registry, this);
+        }
+
+        public static CompoundTag readNBT(PacketTypeRegistry registry, NetInput in) throws IOException {
+            if (registry.atLeast(ProtocolVersion.v1_8)) {
+                byte type = in.readByte();
+                if (type == 0) {
+                    return null;
+                } else {
+                    return NBTIO.readTag(new InputStream() {
+                        private int read;
+
+                        @Override
+                        public int read() throws IOException {
+                            int index = read++;
+                            if (index == 0) {
+                                return type & 0xff;
+                            }  else if ((index == 1 || index == 2) && registry.atLeast(ProtocolVersion.v1_20_2)) {
+                                return 0; // length of empty name
+                            } else {
+                                return in.readUnsignedByte();
+                            }
+                        }
+                    });
+                }
+            } else {
+                short length = in.readShort();
+                if (length < 0) {
+                    return null;
+                } else {
+                    return NBTIO.readTag(new GZIPInputStream(new ByteArrayInputStream(in.readBytes(length))));
+                }
+            }
+        }
+
+        public BitSet readBitSet() throws IOException {
+            return readBitSet(packet.registry, this);
+        }
+
+        public static BitSet readBitSet(PacketTypeRegistry registry, NetInput in) throws IOException {
+            if (registry.atLeast(ProtocolVersion.v1_17)) {
+                return BitSet.valueOf(in.readLongs(in.readVarInt()));
+            } else if (registry.atLeast(ProtocolVersion.v1_9)) {
+                int value = in.readVarInt();
+                // There appear to be some broken server implementations which write the lower 31 bits as they should be
+                // but then have the 32nd bit set (i.e. the whole number is negative).
+                // Pre-1.18 only ever reads the first 18 bits (for PacketUpdateLight) or 16 bits (for PacketChunkData),
+                // so this issue does not affect vanilla playback. It does affect our parsing though cause we take the
+                // masks at face value.
+                // So, to work around these broken masks, we ignore the highest bit.
+                value = value & ~0x80000000;
+                return BitSet.valueOf(new long[] { value });
+            } else {
+                return BitSet.valueOf(new long[] { in.readUnsignedShort() });
+            }
+        }
+
+        public <T> List<T> readList(IOSupplier<T> entryReader) throws IOException {
+            return readList(packet.registry, this, entryReader);
+        }
+
+        public static <T> List<T> readList(PacketTypeRegistry registry, NetInput in, IOSupplier<T> entryReader) throws IOException {
+            int len = in.readVarInt();
+            List<T> result = new ArrayList<>(len);
+            for (int i = 0; i < len; i++) {
+                result.add(entryReader.get());
+            }
+            return result;
+        }
+
+        public StringOrNbtText readText() throws IOException {
+            if (packet.atLeast(ProtocolVersion.v1_20_3)) {
+                Tag tag;
+                    int id = readByte();
+                    if (id == 0) {
+                        tag = null;
+                    } else {
+                        try {
+                            tag = TagRegistry.createInstance(id);
+                        } catch (TagCreateException e) {
+                            throw new IOException("Failed to create tag.", e);
+                        }
+                        tag.read(new DataInputStream(new ByteBufInputStream(buf)));
+                    }
+                return new StringOrNbtText(tag);
+            } else {
+                return new StringOrNbtText(readString());
+            }
+        }
+    }
+
+    public static class Writer extends ByteBufNetOutput implements AutoCloseable {
+        private final Packet packet;
+        private final ByteBuf buf;
+
+        private Writer(Packet packet, ByteBuf buf) {
+            super(buf);
+            this.packet = packet;
+            this.buf = buf;
+        }
+
+        @Override
+        public void close() {
+        }
+
+        public void writePosition(IPosition pos) throws IOException {
+            writePosition(packet.registry, this, pos);
+        }
+
+        public static void writePosition(PacketTypeRegistry registry, NetOutput out, IPosition pos) throws IOException {
+            long x = pos.getX() & 0x3ffffff;
+            long y = pos.getY() & 0xfff;
+            long z = pos.getZ() & 0x3ffffff;
+            if (registry.atLeast(ProtocolVersion.v1_14)) {
+                out.writeLong(x << 38 | z << 12 | y);
+            } else {
+                out.writeLong(x << 38 | y << 26 | z);
+            }
+        }
+
+        public void writeGlobalPosition(IGlobalPosition pos) throws IOException {
+            writeGlobalPosition(packet.registry, this, pos);
+        }
+
+        public static void writeGlobalPosition(PacketTypeRegistry registry, NetOutput out, IGlobalPosition pos) throws IOException {
+            out.writeString(pos.getDimension());
+            writePosition(registry, out, pos.getPosition());
+        }
+
+        public void writeNBT(CompoundTag tag) throws IOException {
+            writeNBT(packet.registry, this, tag);
+        }
+
+        public static void writeNBT(PacketTypeRegistry registry, NetOutput out, CompoundTag tag) throws IOException {
+            if (registry.atLeast(ProtocolVersion.v1_8)) {
+                if(tag == null) {
+                    out.writeByte(0);
+                } else {
+                    NBTIO.writeTag(new OutputStream() {
+                        private int written;
+
+                        @Override
+                        public void write(int b) throws IOException {
+                            int index = written++;
+                            // Skip empty name
+                            if ((index == 1 || index == 2) && registry.atLeast(ProtocolVersion.v1_20_2)) {
+                                return;
+                            }
+                            out.writeByte(b);
+                        }
+                    }, tag);
+                }
+            } else {
+                ByteArrayOutputStream output = new ByteArrayOutputStream();
+                GZIPOutputStream gzip = new GZIPOutputStream(output);
+                NBTIO.writeTag(gzip, tag);
+                gzip.close();
+                output.close();
+                byte[] bytes = output.toByteArray();
+                out.writeShort(bytes.length);
+                out.writeBytes(bytes);
+            }
+        }
+
+        public void writeBitSet(BitSet bitSet) throws IOException {
+            writeBitSet(packet.registry, this, bitSet);
+        }
+
+        public static void writeBitSet(PacketTypeRegistry registry, NetOutput out, BitSet bitSet) throws IOException {
+            if (registry.atLeast(ProtocolVersion.v1_17)) {
+                long[] longs = bitSet.toLongArray();
+                out.writeVarInt(longs.length);
+                out.writeLongs(longs);
+            } else {
+                long[] longs = bitSet.toLongArray();
+                long value;
+                if (longs.length == 0) {
+                    value = 0;
+                } else if (longs.length == 1) {
+                    value = longs[0];
+                } else {
+                    throw new IllegalArgumentException("Pre-1.17 bitset cannot encode more than 64 bits.");
+                }
+                if (registry.atLeast(ProtocolVersion.v1_9)) {
+                    out.writeVarInt((int) value);
+                } else {
+                    out.writeShort((int) value);
+                }
+            }
+        }
+
+        public <T> void writeList(List<T> list, IOConsumer<T> entryWriter) throws IOException {
+            writeList(packet.registry, this, list, entryWriter);
+        }
+
+        public static <T> void writeList(PacketTypeRegistry registry, NetOutput out, List<T> list, IOConsumer<T> entryWriter) throws IOException {
+            out.writeVarInt(list.size());
+            for (T entry : list) {
+                entryWriter.consume(entry);
+            }
+        }
+
+        public void writeText(StringOrNbtText value) throws IOException {
+            if (packet.atLeast(ProtocolVersion.v1_20_3)) {
+                if (value.nbt == null) {
+                    writeByte(0);
+                } else {
+                    writeByte(value.nbt.getTagId());
+                    value.nbt.write(new DataOutputStream(new ByteBufOutputStream(buf)));
+                }
+            } else {
+                writeString(value.str);
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/PacketType.java b/src/main/java/com/replaymod/replaystudio/protocol/PacketType.java
new file mode 100644
index 0000000000000000000000000000000000000000..564c88674f405268f205db292e6427ae86ed6545
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/PacketType.java
@@ -0,0 +1,165 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol;
+
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+// Note: Intentionally non-exhaustive (except 1.7.6 PLAY). Only contains what our filters need.
+public enum PacketType {
+	UnknownLogin(ProtocolVersion.v1_7_6, -1, State.LOGIN), // cause you can't switch over null
+	UnknownConfiguration(ProtocolVersion.v1_20_2, -1, State.CONFIGURATION), // cause you can't switch over null
+	UnknownPlay(ProtocolVersion.v1_7_6, -1), // cause you can't switch over null
+	LoginSuccess(ProtocolVersion.v1_7_6, 0x02, State.LOGIN),
+	ConfigDisconnect(ProtocolVersion.v1_20_2, 0x01, State.CONFIGURATION),
+	ConfigFinish(ProtocolVersion.v1_20_2, 0x02, State.CONFIGURATION),
+	ConfigKeepAlive(ProtocolVersion.v1_20_2, 0x03, State.CONFIGURATION),
+	ConfigPing(ProtocolVersion.v1_20_2, 0x04, State.CONFIGURATION),
+	ConfigRegistries(ProtocolVersion.v1_20_2, 0x05, State.CONFIGURATION),
+	ConfigFeatures(ProtocolVersion.v1_20_2, 0x07, State.CONFIGURATION),
+	ConfigTags(ProtocolVersion.v1_20_2, 0x08, State.CONFIGURATION),
+    KeepAlive(ProtocolVersion.v1_7_6, 0x00),
+	JoinGame(ProtocolVersion.v1_7_6, 0x01),
+	Chat(ProtocolVersion.v1_7_6, 0x02),
+	UpdateTime(ProtocolVersion.v1_7_6, 0x03),
+	EntityEquipment(ProtocolVersion.v1_7_6, 0x04),
+	SpawnPosition(ProtocolVersion.v1_7_6, 0x05),
+	UpdateHealth(ProtocolVersion.v1_7_6, 0x06),
+	Respawn(ProtocolVersion.v1_7_6, 0x07),
+	PlayerPositionRotation(ProtocolVersion.v1_7_6, 0x08),
+	ChangeHeldItem(ProtocolVersion.v1_7_6, 0x09),
+	PlayerUseBed(ProtocolVersion.v1_7_6, 0x0a), // removed in 1.14
+	EntityAnimation(ProtocolVersion.v1_7_6, 0x0b),
+	SpawnPlayer(ProtocolVersion.v1_7_6, 0x0c), // removed in 1.20.2 in favor of SpawnObject
+	EntityCollectItem(ProtocolVersion.v1_7_6, 0x0d),
+	SpawnObject(ProtocolVersion.v1_7_6, 0x0e),
+	SpawnMob(ProtocolVersion.v1_7_6, 0x0f), // removed in 1.19 in favor of SpawnObject
+	SpawnPainting(ProtocolVersion.v1_7_6, 0x10),
+	SpawnExpOrb(ProtocolVersion.v1_7_6, 0x11),
+	EntityVelocity(ProtocolVersion.v1_7_6, 0x12),
+	DestroyEntities(ProtocolVersion.v1_7_6, 0x13), // removed in 1.17, re-added in 1.17.1
+	EntityMovement(ProtocolVersion.v1_7_6, 0x14), // removed in 1.17
+	EntityPosition(ProtocolVersion.v1_7_6, 0x15),
+	EntityRotation(ProtocolVersion.v1_7_6, 0x16),
+	EntityPositionRotation(ProtocolVersion.v1_7_6, 0x17),
+	EntityTeleport(ProtocolVersion.v1_7_6, 0x18),
+	EntityHeadLook(ProtocolVersion.v1_7_6, 0x19),
+	EntityStatus(ProtocolVersion.v1_7_6, 0x1a),
+	EntityAttach(ProtocolVersion.v1_7_6, 0x1b),
+	EntityMetadata(ProtocolVersion.v1_7_6, 0x1c),
+	EntityEffect(ProtocolVersion.v1_7_6, 0x1d),
+	EntityRemoveEffect(ProtocolVersion.v1_7_6, 0x1e),
+	SetExperience(ProtocolVersion.v1_7_6, 0x1f),
+	EntityProperties(ProtocolVersion.v1_7_6, 0x20),
+	ChunkData(ProtocolVersion.v1_7_6, 0x21),
+	MultiBlockChange(ProtocolVersion.v1_7_6, 0x22),
+	BlockChange(ProtocolVersion.v1_7_6, 0x23),
+	BlockValue(ProtocolVersion.v1_7_6, 0x24),
+	BlockBreakAnim(ProtocolVersion.v1_7_6, 0x25),
+	BulkChunkData(ProtocolVersion.v1_7_6, 0x26),
+	Explosion(ProtocolVersion.v1_7_6, 0x27),
+	PlayEffect(ProtocolVersion.v1_7_6, 0x28),
+	PlaySound(ProtocolVersion.v1_7_6, 0x29),
+	SpawnParticle(ProtocolVersion.v1_7_6, 0x2a),
+	NotifyClient(ProtocolVersion.v1_7_6, 0x2b),
+	SpawnGlobalEntity(ProtocolVersion.v1_7_6, 0x2c),
+	OpenWindow(ProtocolVersion.v1_7_6, 0x2d),
+	CloseWindow(ProtocolVersion.v1_7_6, 0x2e),
+	SetSlot(ProtocolVersion.v1_7_6, 0x2f),
+	WindowItems(ProtocolVersion.v1_7_6, 0x30),
+	WindowProperty(ProtocolVersion.v1_7_6, 0x31),
+	ConfirmTransaction(ProtocolVersion.v1_7_6, 0x32),
+	UpdateSign(ProtocolVersion.v1_7_6, 0x33),
+	MapData(ProtocolVersion.v1_7_6, 0x34),
+	UpdateTileEntity(ProtocolVersion.v1_7_6, 0x35),
+	OpenTileEntityEditor(ProtocolVersion.v1_7_6, 0x36),
+	Statistics(ProtocolVersion.v1_7_6, 0x37),
+	PlayerListEntry(ProtocolVersion.v1_7_6, 0x38),
+	PlayerAbilities(ProtocolVersion.v1_7_6, 0x39),
+	TabComplete(ProtocolVersion.v1_7_6, 0x3a),
+	ScoreboardObjective(ProtocolVersion.v1_7_6, 0x3b),
+	UpdateScore(ProtocolVersion.v1_7_6, 0x3c),
+	DisplayScoreboard(ProtocolVersion.v1_7_6, 0x3d),
+	Team(ProtocolVersion.v1_7_6, 0x3e),
+	PluginMessage(ProtocolVersion.v1_7_6, 0x3f),
+	Disconnect(ProtocolVersion.v1_7_6, 0x40),
+
+	Difficulty(ProtocolVersion.v1_8, 0x41),
+	Combat(ProtocolVersion.v1_8, 0x42), // removed in 1.17
+	SwitchCamera(ProtocolVersion.v1_8, 0x43),
+	WorldBorder(ProtocolVersion.v1_8, 0x44),
+	EntityNBTUpdate(ProtocolVersion.v1_8, 0x49), // removed in 1.9
+
+	UnloadChunk(ProtocolVersion.v1_9, 0x1d),
+	SetPassengers(ProtocolVersion.v1_9, 0x40),
+
+    OpenHorseWindow(ProtocolVersion.v1_14, 0x1f),
+	UpdateLight(ProtocolVersion.v1_14, 0x24),
+	TradeList(ProtocolVersion.v1_14, 0x27),
+	UpdateViewPosition(ProtocolVersion.v1_14, 0x40),
+	UpdateViewDistance(ProtocolVersion.v1_14, 0x41),
+    EntitySoundEffect(ProtocolVersion.v1_14, 0x50),
+    Tags(ProtocolVersion.v1_14, 0x5b),
+	PlayerActionAck(ProtocolVersion.v1_14, 0x5c),
+
+    CombatEnd(ProtocolVersion.v1_17, 0x33),
+    CombatEnter(ProtocolVersion.v1_17, 0x34),
+    CombatEntityDead(ProtocolVersion.v1_17, 0x35),
+	DestroyEntity(ProtocolVersion.v1_17, 0x3a), // removed in 1.17.1, that didn't last long
+
+	UpdateSimulationDistance(ProtocolVersion.v1_18, 0x57),
+
+	Features(ProtocolVersion.v1_19_3, 0x67), // removed in 1.20.2 in favor of ConfigFeatures
+	PlayerListEntryRemove(ProtocolVersion.v1_19_3, 0x35),
+
+	Bundle(ProtocolVersion.v1_19_4, 0x00),
+
+	Reconfigure(ProtocolVersion.v1_20_2, 0x65),
+	;
+
+    private final State state;
+    private final ProtocolVersion initialVersion;
+    private final int initialId;
+
+	PacketType(ProtocolVersion initialVersion, int initialId) {
+		this(initialVersion, initialId, State.PLAY);
+    }
+
+	PacketType(ProtocolVersion initialVersion, int initialId, State state) {
+		this.state = state;
+        this.initialVersion = initialVersion;
+        this.initialId = initialId;
+    }
+
+	public State getState() {
+		return state;
+	}
+
+	public ProtocolVersion getInitialVersion() {
+        return initialVersion;
+    }
+
+    public int getInitialId() {
+        return initialId;
+    }
+
+    public boolean isUnknown() {
+		return initialId == -1;
+	}
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/PacketTypeRegistry.java b/src/main/java/com/replaymod/replaystudio/protocol/PacketTypeRegistry.java
new file mode 100644
index 0000000000000000000000000000000000000000..6ce73e883424590a63c9c6e61adfbcc7d5f9405a
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/PacketTypeRegistry.java
@@ -0,0 +1,282 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol;
+
+import com.google.common.collect.Lists;
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.connection.UserConnection;
+import com.viaversion.viaversion.api.protocol.AbstractProtocol;
+import com.viaversion.viaversion.api.protocol.ProtocolPathEntry;
+import com.viaversion.viaversion.api.protocol.packet.ClientboundPacketType;
+import com.viaversion.viaversion.api.protocol.packet.PacketWrapper;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.viaversion.viaversion.api.protocol.Protocol;
+import com.viaversion.viaversion.api.protocol.packet.mapping.PacketMapping;
+import com.viaversion.viaversion.api.protocol.packet.mapping.PacketMappings;
+import com.viaversion.viaversion.api.protocol.packet.provider.PacketTypeMap;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.viaversion.viaversion.protocols.protocol1_14to1_13_2.Protocol1_14To1_13_2;
+import com.viaversion.viaversion.protocols.protocol1_16to1_15_2.Protocol1_16To1_15_2;
+import com.viaversion.viaversion.protocols.protocol1_17_1to1_17.Protocol1_17_1To1_17;
+import com.viaversion.viaversion.protocols.protocol1_17to1_16_4.Protocol1_17To1_16_4;
+import com.viaversion.viaversion.protocols.protocol1_19to1_18_2.Protocol1_19To1_18_2;
+import com.viaversion.viaversion.protocols.protocol1_20_3to1_20_2.Protocol1_20_3To1_20_2;
+import com.viaversion.viaversion.protocols.protocol1_9to1_8.Protocol1_9To1_8;
+import com.replaymod.replaystudio.viaversion.CustomViaManager;
+import org.apache.commons.lang3.tuple.Pair;
+
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.EnumMap;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class PacketTypeRegistry {
+    private static Map<ProtocolVersion, EnumMap<State, PacketTypeRegistry>> forVersionAndState = new HashMap<>();
+    private static Field clientbound;
+
+    static {
+        CustomViaManager.initialize();
+        for (ProtocolVersion version : ProtocolVersion.getProtocols()) {
+            if (ProtocolVersion.getIndex(version) < ProtocolVersion.getIndex(ProtocolVersion.v1_7_1)) {
+                continue;
+            }
+            EnumMap<State, PacketTypeRegistry> forState = new EnumMap<>(State.class);
+            for (State state : State.values()) {
+                forState.put(state, new PacketTypeRegistry(version, state));
+            }
+            forVersionAndState.put(version, forState);
+        }
+    }
+
+    public static PacketTypeRegistry get(ProtocolVersion version, State state) {
+        EnumMap<State, PacketTypeRegistry> forState = forVersionAndState.get(version);
+        return forState != null ? forState.get(state) : new PacketTypeRegistry(version, state);
+    }
+
+    private final ProtocolVersion version;
+    private final State state;
+    private final PacketType unknown;
+    private final Map<Integer, PacketType> typeForId = new HashMap<>();
+    private final Map<PacketType, Integer> idForType = new HashMap<>();
+
+    private PacketTypeRegistry(ProtocolVersion version, State state) {
+        this.version = version;
+        this.state = state;
+
+        PacketType unknown = null;
+        int versionIndex = ProtocolVersion.getIndex(version);
+        packets: for (PacketType packetType : PacketType.values()) {
+            if (packetType.getState() != state) {
+                continue; // incorrect protocol state (e.g. LOGIN vs PLAY)
+            }
+
+            if (packetType.isUnknown()) {
+                unknown = packetType;
+                continue; // "unknown" type exists for all versions
+            }
+
+            if (ProtocolVersion.getIndex(packetType.getInitialVersion()) > versionIndex) {
+                continue; // packet didn't yet exist in this version
+            }
+
+            List<ProtocolPathEntry> protocolPath = getProtocolPath(version.getVersion(), packetType.getInitialVersion().getVersion());
+            if (protocolPath == null) {
+                continue; // no path from packet version to current version (current version is not supported)
+            }
+
+            int id = packetType.getInitialId();
+            for (ProtocolPathEntry entry : Lists.reverse(protocolPath)) {
+                Protocol<?, ?, ?, ?> protocol = entry.getProtocol();
+                boolean wasReplaced = false;
+                for (Pair<Integer, Integer> idMapping : getIdMappings(protocol, state)) {
+                    int oldId = idMapping.getKey();
+                    int newId = idMapping.getValue();
+                    if (oldId == id) {
+                        if (newId == -1) {
+                            // Packet no longer exists in this version.
+
+                            // Special case: Minecraft replaces the DestroyEntities packet in 1.17 with a singe-entity
+                            //               variant, only to revert that change in 1.17.1. So let's keep that around
+                            //               if we are not stopping at 1.17.
+                            if (protocol instanceof Protocol1_17To1_16_4 && packetType == PacketType.DestroyEntities && version != ProtocolVersion.v1_17) {
+                                // ViaVersion maps the newly introduced DestroyEntity back to the good old
+                                // DestroyEntities in 1.17.1, but not the other way around (cause it has to emit many
+                                // packets for one), so if we just manually map to DestroyEntity here, it'll map back
+                                // in 1.17.1 for us.
+                                id = PacketType.DestroyEntity.getInitialId();
+                                wasReplaced = false;
+                                break;
+                            }
+
+                            continue packets;
+                        }
+                        id = newId;
+                        wasReplaced = false;
+                        break;
+                    }
+                    if (newId == id) {
+                        wasReplaced = true;
+                    }
+                }
+
+                // Special case: Multiple packets get merged into Spawn Object in 1.19, we want to drop those and
+                //               preserve the original type.
+                if (protocol instanceof Protocol1_19To1_18_2) {
+                    switch (packetType) {
+                        case SpawnPainting:
+                        case SpawnMob:
+                            continue packets;
+                        case SpawnObject:
+                            wasReplaced = false;
+                            id = 0;
+                            break;
+                    }
+                }
+
+                // Special case: ViaVersion remaps the Spawn Global Entity packet into a Spawn Entity, though they're
+                //               logically distinct packets for us.
+                if (protocol instanceof Protocol1_16To1_15_2 && packetType == PacketType.SpawnGlobalEntity) {
+                    wasReplaced = true;
+                }
+
+                // Special case: ViaVersion remaps the Use Bed packet into a Entity Metadata, though they're logically
+                //               distinct packets for us.
+                if (protocol instanceof Protocol1_14To1_13_2 && packetType == PacketType.PlayerUseBed) {
+                    wasReplaced = true;
+                }
+
+                // Special case: ViaVersion cancels the Update Entity NBT packets unconditionally, instead of setting
+                //               their newId to -1.
+                if (protocol instanceof Protocol1_9To1_8 && packetType == PacketType.EntityNBTUpdate) {
+                    wasReplaced = true;
+                }
+
+                // Special case: ViaVersion remaps the DestroyEntity packet into a DestroyEntities. thought they're
+                //               logically distinct packets for us.
+                if (protocol instanceof Protocol1_17_1To1_17 && packetType == PacketType.DestroyEntity) {
+                    wasReplaced = true;
+                }
+
+                // FIXME: ViaVersion doesn't yet use proper mapping for config-phase packets
+                //        https://github.com/ViaVersion/ViaVersion/blob/45d08e9066802e5ae478b9efe97df73443005f77/common/src/main/java/com/viaversion/viaversion/protocols/protocol1_20_3to1_20_2/Protocol1_20_3To1_20_2.java#L327
+                if (protocol instanceof Protocol1_20_3To1_20_2 && state == State.CONFIGURATION && id >= 7) {
+                    id++;
+                }
+
+                if (wasReplaced) {
+                    continue packets; // packet no longer exists in this version
+                }
+            }
+
+            typeForId.put(id, packetType);
+            idForType.put(packetType, id);
+        }
+        this.unknown = unknown;
+    }
+
+    private static List<ProtocolPathEntry> getProtocolPath(int clientVersion, int serverVersion) {
+        // ViaVersion doesn't officially support 1.7.6 but luckily there weren't any (client-bound) packet id changes
+        if (serverVersion == ProtocolVersion.v1_7_6.getVersion()) {
+            return getProtocolPath(clientVersion, ProtocolVersion.v1_8.getVersion());
+        }
+        if (clientVersion == ProtocolVersion.v1_7_6.getVersion()) {
+            return getProtocolPath(ProtocolVersion.v1_8.getVersion(), serverVersion);
+        }
+        // The trivial case
+        if (clientVersion == serverVersion) {
+            return Collections.emptyList();
+        }
+        // otherwise delegate to ViaVersion
+        return Via.getManager().getProtocolManager().getProtocolPath(clientVersion, serverVersion);
+    }
+
+    public ProtocolVersion getVersion() {
+        return version;
+    }
+
+    public State getState() {
+        return state;
+    }
+
+    public Integer getId(PacketType type) {
+        return idForType.get(type);
+    }
+
+    public PacketType getType(int id) {
+        return typeForId.getOrDefault(id, unknown);
+    }
+
+    public boolean atLeast(ProtocolVersion protocolVersion) {
+        return version.getVersion() >= protocolVersion.getVersion();
+    }
+
+    public boolean atMost(ProtocolVersion protocolVersion) {
+        return version.getVersion() <= protocolVersion.getVersion();
+    }
+
+    public boolean olderThan(ProtocolVersion protocolVersion) {
+        return version.getVersion() < protocolVersion.getVersion();
+    }
+
+    public PacketTypeRegistry withState(State state) {
+        return PacketTypeRegistry.get(version, state);
+    }
+
+    public PacketTypeRegistry withLoginSuccess() {
+        return withState(atLeast(ProtocolVersion.v1_20_2) ? State.CONFIGURATION : State.PLAY);
+    }
+
+    private static List<Pair<Integer, Integer>> getIdMappings(Protocol<?, ?, ?, ?> protocol, State state) {
+        List<Pair<Integer, Integer>> result = new ArrayList<>();
+        try {
+            if (clientbound == null) {
+                clientbound = AbstractProtocol.class.getDeclaredField("clientboundMappings");
+                clientbound.setAccessible(true);
+            }
+            PacketMappings mappings = (PacketMappings) clientbound.get(protocol);
+
+            PacketTypeMap<? extends ClientboundPacketType> packetTypeMap =
+                    protocol.getPacketTypesProvider().unmappedClientboundPacketTypes().get(state);
+            if (packetTypeMap == null) {
+                return result;
+            }
+
+            PacketWrapper dummyPacketWrapper = PacketWrapper.create(null, (UserConnection) null);
+            for (ClientboundPacketType unmappedPacketType : packetTypeMap.types()) {
+                PacketMapping packetMapping = mappings.mappedPacket(state, unmappedPacketType.getId());
+                if (packetMapping == null) {
+                    continue;
+                }
+
+                dummyPacketWrapper.setPacketType(null);
+                packetMapping.applyType(dummyPacketWrapper);
+
+                int oldId = unmappedPacketType.getId();
+                int newId = dummyPacketWrapper.getId();
+                result.add(Pair.of(oldId, newId));
+            }
+        } catch (NoSuchFieldException | IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/data/StringOrNbtText.java b/src/main/java/com/replaymod/replaystudio/protocol/data/StringOrNbtText.java
new file mode 100644
index 0000000000000000000000000000000000000000..b8d0ebabbe568310d06d2ec0111dc4d0be4815ea
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/data/StringOrNbtText.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2023
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.protocol.data;
+
+import com.github.steveice10.opennbt.tag.builtin.Tag;
+
+public class StringOrNbtText {
+    public String str; // 1.20.2-
+    public Tag nbt; // 1.20.3+
+
+    public StringOrNbtText(String str) {
+        this.str = str;
+    }
+
+    public StringOrNbtText(Tag nbt) {
+        this.nbt = nbt;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/EntityId.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/EntityId.java
new file mode 100644
index 0000000000000000000000000000000000000000..007cf5a5e27b79d3dcd4a76e5f6ab532b1dae13d
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/EntityId.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+public class EntityId {
+    public static List<Integer> getEntityIds(Packet packet) throws IOException {
+        switch (packet.getType()) {
+            case EntityCollectItem: try (Packet.Reader in = packet.reader()) {
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    return Arrays.asList(in.readVarInt(), in.readVarInt());
+                } else {
+                    return Arrays.asList(in.readInt(), in.readInt());
+                }
+            }
+            case DestroyEntities:
+                return PacketDestroyEntities.getEntityIds(packet);
+            case SetPassengers: try (Packet.Reader in = packet.reader()) {
+                int entityId = in.readVarInt();
+                int len = in.readVarInt();
+                List<Integer> result = new ArrayList<>(len + 1);
+                result.add(entityId);
+                for (int i = 0; i < len; i++) {
+                    result.add(in.readVarInt());
+                }
+                return result;
+            }
+            case EntityAttach: try (Packet.Reader in = packet.reader()) {
+                return Arrays.asList(in.readInt(), in.readInt());
+            }
+            case Combat: try (Packet.Reader in = packet.reader()) {
+                int event = in.readVarInt();
+                if (event == 1) { // end combat
+                    in.readVarInt(); // duration
+                    return Collections.singletonList(in.readInt());
+                } else if (event == 2) { // entity dead
+                    return Arrays.asList(in.readVarInt(), in.readInt());
+                }
+                return Collections.emptyList();
+            }
+            case CombatEntityDead: try (Packet.Reader in = packet.reader()) {
+                if (packet.atLeast(ProtocolVersion.v1_20)) {
+                    return Collections.singletonList(in.readVarInt());
+                } else {
+                    return Arrays.asList(in.readVarInt(), in.readInt());
+                }
+            }
+            default:
+                Integer entityId = getEntityId(packet);
+                if (entityId != null) {
+                    return Collections.singletonList(entityId);
+                } else {
+                    return Collections.emptyList();
+                }
+        }
+    }
+
+    public static Integer getEntityId(Packet packet) throws IOException {
+        switch (packet.getType()) {
+            case OpenHorseWindow: try (Packet.Reader in = packet.reader()) {
+                in.readByte();
+                in.readVarInt();
+                return in.readInt();
+            }
+            case EntitySoundEffect: try (Packet.Reader in = packet.reader()) {
+                in.readVarInt();
+                in.readVarInt();
+                return in.readVarInt();
+            }
+            case EntityEffect:
+            case EntityRemoveEffect:
+            case EntityEquipment:
+            case EntityHeadLook:
+            case EntityMetadata:
+            case EntityMovement:
+            case EntityPosition:
+            case EntityRotation:
+            case EntityPositionRotation:
+            case EntityAnimation:
+            case EntityNBTUpdate:
+            case EntityProperties:
+            case EntityTeleport:
+            case EntityVelocity:
+            case SwitchCamera:
+            case PlayerUseBed: try (Packet.Reader in = packet.reader()) {
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    return in.readVarInt();
+                } else {
+                    return in.readInt();
+                }
+            }
+            case BlockBreakAnim:
+            case DestroyEntity:
+            case SpawnPlayer:
+            case SpawnObject:
+            case SpawnPainting:
+            case SpawnMob:
+            case SpawnGlobalEntity:
+            case SpawnExpOrb: try (Packet.Reader in = packet.reader()) {
+                return in.readVarInt();
+            }
+            case EntityStatus: try (Packet.Reader in = packet.reader()) {
+                return in.readInt();
+            }
+            case CombatEnd: try (Packet.Reader in = packet.reader()) {
+                in.readVarInt(); // duration
+                if (packet.atLeast(ProtocolVersion.v1_20)) {
+                    return null;
+                } else {
+                    return in.readInt();
+                }
+            }
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketBlockChange.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketBlockChange.java
new file mode 100644
index 0000000000000000000000000000000000000000..91376d7329ef5f53971ae29ee236caf7002cec1f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketBlockChange.java
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.util.IPosition;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+
+public class PacketBlockChange {
+    private IPosition pos;
+    private int id;
+
+    private PacketBlockChange() {}
+    public PacketBlockChange(IPosition pos, int id) {
+        this.pos = pos;
+        this.id = id;
+    }
+
+    public static PacketBlockChange read(Packet packet) throws IOException {
+        PacketBlockChange p = new PacketBlockChange();
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                p.pos = in.readPosition();
+                p.id = in.readVarInt();
+            } else {
+                int x = in.readInt();
+                int y = in.readUnsignedByte();
+                int z = in.readInt();
+                p.pos = new IPosition(x, y, z);
+                p.id = (in.readVarInt() << 4) | (in.readUnsignedByte() & 0xf);
+            }
+        }
+        return p;
+    }
+
+    public static Packet write(PacketTypeRegistry registry, IPosition pos, int id) throws IOException {
+        return new PacketBlockChange(pos, id).write(registry);
+    }
+
+    public Packet write(PacketTypeRegistry registry) throws IOException {
+        Packet packet = new Packet(registry, PacketType.BlockChange);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writePosition(pos);
+                out.writeVarInt(id);
+            } else {
+                out.writeInt(pos.getX());
+                out.writeByte(pos.getY());
+                out.writeInt(pos.getZ());
+                out.writeVarInt(id >> 4);
+                out.writeByte(id & 0xf);
+            }
+        }
+        return packet;
+    }
+
+    public static List<PacketBlockChange> readBulk(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            int chunkX;
+            int chunkY;
+            int chunkZ;
+            if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                long coord = in.readLong();
+                chunkX = (int)(coord >> 42);
+                chunkY = (int)(coord << 44 >> 44);
+                chunkZ = (int)(coord << 22 >> 42);
+                if (packet.olderThan(ProtocolVersion.v1_20)) {
+                    in.readBoolean(); // we don't care about "skip light updates"
+                }
+            } else {
+                chunkX = in.readInt();
+                chunkY = 0;
+                chunkZ = in.readInt();
+            }
+            PacketBlockChange[] result;
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                result = new PacketBlockChange[in.readVarInt()];
+            } else {
+                result = new PacketBlockChange[in.readShort()];
+                in.readInt(); // Unneeded size variable
+            }
+            for(int index = 0; index < result.length; index++) {
+                PacketBlockChange p = new PacketBlockChange();
+
+                if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                    long change = in.readVarLong();
+                    int x = (chunkX << 4) + (int) (change >> 8 & 15);
+                    int y = (chunkY << 4) + (int) (change & 15);
+                    int z = (chunkZ << 4) + (int) (change >> 4 & 15);
+                    p.pos = new IPosition(x, y, z);
+                    p.id = (int) (change >>> 12);
+                } else {
+                    short coords = in.readShort();
+                    int x = (chunkX << 4) + (coords >> 12 & 15);
+                    int y = coords & 255;
+                    int z = (chunkZ << 4) + (coords >> 8 & 15);
+                    p.pos = new IPosition(x, y, z);
+
+                    if (packet.atLeast(ProtocolVersion.v1_8)) {
+                        p.id = in.readVarInt();
+                    } else {
+                        p.id = in.readShort();
+                    }
+                }
+
+                result[index] = p;
+            }
+            return Arrays.asList(result);
+        }
+    }
+
+    public static List<PacketBlockChange> readSingleOrBulk(Packet packet) throws IOException {
+        if (packet.getType() == PacketType.BlockChange) {
+            return Collections.singletonList(read(packet));
+        } else {
+            return readBulk(packet);
+        }
+    }
+
+    public IPosition getPosition() {
+        return pos;
+    }
+
+    public int getId() {
+        return id;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketChunkData.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketChunkData.java
new file mode 100644
index 0000000000000000000000000000000000000000..ed1da9cb9fc7778195c3c3c567352d6cb2016da5
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketChunkData.java
@@ -0,0 +1,1061 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.github.steveice10.packetlib.io.NetInput;
+import com.github.steveice10.packetlib.io.NetOutput;
+import com.github.steveice10.packetlib.io.stream.StreamNetInput;
+import com.github.steveice10.packetlib.io.stream.StreamNetOutput;
+import com.viaversion.viaversion.api.minecraft.chunks.PaletteType;
+import com.viaversion.viaversion.api.minecraft.metadata.ChunkPosition;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.util.Utils;
+import org.apache.commons.lang3.tuple.Pair;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.List;
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
+public class PacketChunkData {
+    private Column column;
+
+    private boolean isUnload;
+    private int unloadX;
+    private int unloadZ;
+
+    public static PacketChunkData read(Packet packet, int sections) throws IOException {
+        PacketChunkData chunkData = new PacketChunkData();
+        try (Packet.Reader reader = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_9)) {
+                if (packet.getType() == PacketType.UnloadChunk) {
+                    chunkData.readUnload(packet, reader);
+                } else {
+                    chunkData.readLoad(packet, reader, sections);
+                }
+            } else {
+                chunkData.readLoad(packet, reader, sections);
+            }
+        }
+        return chunkData;
+    }
+
+    public static PacketChunkData readUnload(Packet packet) throws IOException {
+        PacketChunkData chunkData = new PacketChunkData();
+        try (Packet.Reader reader = packet.reader()) {
+            chunkData.readUnload(packet, reader);
+        }
+        return chunkData;
+    }
+
+    public Packet write(PacketTypeRegistry registry) throws IOException {
+        PacketType packetType;
+        boolean atLeastV1_9 = ProtocolVersion.getIndex(registry.getVersion()) >= ProtocolVersion.getIndex(ProtocolVersion.v1_9);
+        if (atLeastV1_9) {
+            packetType = isUnload ? PacketType.UnloadChunk : PacketType.ChunkData;
+        } else {
+            // On these versions, there's an ambiguity between the unload packet and a packet which loads an empty chunk
+            // because the latter is special cased to unload rather than load. The only way to load an empty chunk
+            // therefore is to use the BulkChunkData packet, which doesn't have this special handling.
+            packetType = !isUnload && column.looksLikeUnloadOnMC1_8() ? PacketType.BulkChunkData : PacketType.ChunkData;
+        }
+        Packet packet = new Packet(registry, packetType);
+        try (Packet.Writer writer = packet.overwrite()) {
+            if (atLeastV1_9) {
+                if (isUnload) {
+                    writeUnload(packet, writer);
+                } else {
+                    writeLoad(packet, writer);
+                }
+            } else {
+                if (packetType == PacketType.BulkChunkData) {
+                    if (packet.atLeast(ProtocolVersion.v1_8)) {
+                        writeBulkV1_8(packet, writer, Collections.singletonList(column));
+                    } else {
+                        writeBulkV1_7(packet, writer, Collections.singletonList(column));
+                    }
+                } else {
+                    writeLoad(packet, writer);
+                }
+            }
+        }
+        return packet;
+    }
+
+    public static List<Column> readBulk(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                return readBulkV1_8(packet, in);
+            } else {
+                return readBulkV1_7(packet, in);
+            }
+        }
+    }
+
+    private static List<Column> readBulkV1_8(Packet packet, Packet.Reader in) throws IOException {
+        List<Column> result = new ArrayList<>();
+
+        boolean skylight = in.readBoolean();
+        int columns = in.readVarInt();
+
+        int[] xs = new int[columns];
+        int[] zs = new int[columns];
+        BitSet[] masks = new BitSet[columns];
+        int[] lengths = new int[columns];
+        for (int column = 0; column < columns; column++) {
+            xs[column] = in.readInt();
+            zs[column] = in.readInt();
+            masks[column] = in.readBitSet();
+            int nChunks = masks[column].cardinality();
+            int length = (nChunks * ((4096 * 2) + 2048)) + (skylight ? nChunks * 2048 : 0) + 256;
+            lengths[column] = length;
+        }
+
+        for (int column = 0; column < columns; column++) {
+            byte[] buf = new byte[lengths[column]];
+            in.readBytes(buf);
+            result.add(readColumn(packet, buf, xs[column], zs[column], true, skylight, masks[column], new BitSet(), null, null, false));
+        }
+        return result;
+    }
+
+    private static void writeBulkV1_8(Packet packet, Packet.Writer out, List<Column> columns) throws IOException {
+        out.writeBoolean(columns.stream().anyMatch(Column::hasSkyLightV1_8));
+        out.writeVarInt(columns.size());
+
+        for (Column column : columns) {
+            out.writeInt(column.x);
+            out.writeInt(column.z);
+            out.writeBitSet(column.getChunkMask());
+        }
+
+        for (Column column : columns) {
+            writeColumn(packet, out, column, true);
+        }
+    }
+
+    private static List<Column> readBulkV1_7(Packet packet, Packet.Reader in) throws IOException {
+        List<Column> result = new ArrayList<>();
+
+        // Read packet base data.
+        short columns = in.readShort();
+        int deflatedLength = in.readInt();
+        boolean skylight = in.readBoolean();
+        byte[] deflatedBytes = in.readBytes(deflatedLength);
+        // Inflate chunk data.
+        byte[] inflated = new byte[196864 * columns];
+        Inflater inflater = new Inflater();
+        inflater.setInput(deflatedBytes, 0, deflatedLength);
+        try {
+            inflater.inflate(inflated);
+        } catch(DataFormatException e) {
+            throw new IOException("Bad compressed data format");
+        } finally {
+            inflater.end();
+        }
+
+        // Cycle through and read all columns.
+        int pos = 0;
+        for(int count = 0; count < columns; count++) {
+            // Read column-specific data.
+            int x = in.readInt();
+            int z = in.readInt();
+            BitSet chunkMask = in.readBitSet();
+            BitSet extendedChunkMask = in.readBitSet();
+            // Determine column data length.
+            int chunks = chunkMask.cardinality();
+            int extended = extendedChunkMask.cardinality();
+
+            int length = (8192 * chunks + 256) + (2048 * extended);
+            if(skylight) {
+                length += 2048 * chunks;
+            }
+
+            // Copy column data into a new array.
+            byte[] buf = new byte[length];
+            System.arraycopy(inflated, pos, buf, 0, length);
+            // Read data into chunks and biome data.
+            result.add(readColumn(packet, buf, x, z, true, skylight, chunkMask, extendedChunkMask, null, null, false));
+            pos += length;
+        }
+
+        return result;
+    }
+
+    private static void writeBulkV1_7(Packet packet, Packet.Writer out, List<Column> columns) throws IOException {
+        throw new UnsupportedOperationException("writeBulkV1_7 is not yet implemented");
+    }
+
+    public static PacketChunkData load(Column column) {
+        PacketChunkData chunkData = new PacketChunkData();
+        chunkData.column = column;
+        return chunkData;
+    }
+
+    public static PacketChunkData unload(int chunkX, int chunkZ) {
+        PacketChunkData chunkData = new PacketChunkData();
+        chunkData.isUnload = true;
+
+        // Post 1.9
+        chunkData.unloadX = chunkX;
+        chunkData.unloadZ = chunkZ;
+
+        // Pre 1.9
+        chunkData.column = new Column(chunkX, chunkZ, new Chunk[16], new byte[256], null, null, null, false, null);
+
+        return chunkData;
+    }
+
+    private PacketChunkData() {
+    }
+
+    public Column getColumn() {
+        return column;
+    }
+
+    public boolean isUnload() {
+        return isUnload;
+    }
+
+    public int getUnloadX() {
+        return unloadX;
+    }
+
+    public int getUnloadZ() {
+        return unloadZ;
+    }
+
+    private void readUnload(Packet packet, NetInput in) throws IOException {
+        this.isUnload = true;
+        if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+            this.unloadZ = in.readInt();
+            this.unloadX = in.readInt();
+        } else {
+            this.unloadX = in.readInt();
+            this.unloadZ = in.readInt();
+        }
+    }
+
+    private void writeUnload(Packet packet, Packet.Writer out) throws IOException {
+        if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+            out.writeInt(this.unloadZ);
+            out.writeInt(this.unloadX);
+        } else {
+            out.writeInt(this.unloadX);
+            out.writeInt(this.unloadZ);
+        }
+    }
+
+    private void readLoad(Packet packet, Packet.Reader in, int sections) throws IOException {
+        int x = in.readInt();
+        int z = in.readInt();
+        boolean fullChunk;
+        if (packet.atLeast(ProtocolVersion.v1_17)) {
+            fullChunk = true;
+        } else {
+            fullChunk = in.readBoolean();
+        }
+        boolean useExistingLightData = fullChunk;
+        if (packet.atLeast(ProtocolVersion.v1_16) && !packet.atLeast(ProtocolVersion.v1_16_2)) {
+            useExistingLightData = in.readBoolean();
+        }
+        BitSet chunkMask;
+        if (packet.atLeast(ProtocolVersion.v1_18)) {
+            // With 1.18, MC always sends all sections. You might think that we may be able to infer the number of
+            // sections based on how many bytes are left and while that does sound reasonable, there's one major issue:
+            // The vanilla packet sizing code is broken. It allocates one byte for the IdListPalette even though that
+            // one does not send any data. As a result there may be garbage padding at the end (it's just vanilla which
+            // is buggy, e.g. ViaVersion is sized properly; so we can't just rely on exception that either).
+            chunkMask = new BitSet();
+            chunkMask.set(0, sections);
+        } else {
+            chunkMask = in.readBitSet();
+        }
+        BitSet extendedChunkMask;
+        if (packet.atLeast(ProtocolVersion.v1_8)) {
+            extendedChunkMask = new BitSet();
+        } else {
+            extendedChunkMask = BitSet.valueOf(new long[] { in.readUnsignedShort() });
+        }
+        CompoundTag heightmaps = null;
+        if (packet.atLeast(ProtocolVersion.v1_14)) {
+            heightmaps = in.readNBT();
+        }
+        int[] biomes = null;
+        if (packet.atLeast(ProtocolVersion.v1_15) && packet.olderThan(ProtocolVersion.v1_18) && fullChunk) {
+            if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                biomes = new int[in.readVarInt()];
+                for (int i = 0; i < biomes.length; i++) {
+                    biomes[i] = in.readVarInt();
+                }
+            } else {
+                biomes = in.readInts(1024);
+            }
+        }
+
+        byte[] data;
+        if (packet.atLeast(ProtocolVersion.v1_8)) {
+            data = in.readBytes(in.readVarInt());
+        } else {
+            byte[] deflated = in.readBytes(in.readInt());
+            // Determine inflated data length.
+            int len = 12288 * chunkMask.cardinality();
+            if (fullChunk) {
+                len += 256;
+            }
+            data = new byte[len];
+            // Inflate chunk data.
+            Inflater inflater = new Inflater();
+            inflater.setInput(deflated, 0, deflated.length);
+            try {
+                inflater.inflate(data);
+            } catch (DataFormatException e) {
+                throw new IOException("Bad compressed data format");
+            } finally {
+                inflater.end();
+            }
+        }
+        this.column = readColumn(packet, data, x, z, fullChunk, false, chunkMask, extendedChunkMask, heightmaps, biomes, useExistingLightData);
+
+        if (packet.atLeast(ProtocolVersion.v1_9_3)) {
+            TileEntity[] tileEntities = new TileEntity[in.readVarInt()];
+            for (int i = 0; i < tileEntities.length; i++) {
+                tileEntities[i] = new TileEntity(packet, in);
+            }
+            this.column.tileEntities = tileEntities;
+        }
+
+        if (packet.atLeast(ProtocolVersion.v1_18)) {
+            this.column.lightData = PacketUpdateLight.readData(packet, in);
+        }
+
+        if (packet.atMost(ProtocolVersion.v1_8) && fullChunk && chunkMask.isEmpty()) {
+            isUnload = true;
+            unloadX = x;
+            unloadZ = z;
+        }
+    }
+
+    private void writeLoad(Packet packet, Packet.Writer out) throws IOException {
+        ByteArrayOutputStream byteOut = new ByteArrayOutputStream();
+        NetOutput netOut = new StreamNetOutput(byteOut);
+        Pair<BitSet, BitSet> masks = writeColumn(packet, netOut, this.column, this.column.isFull());
+        BitSet mask = masks.getKey();
+        BitSet extendedMask = masks.getValue();
+
+        out.writeInt(this.column.x);
+        out.writeInt(this.column.z);
+        if (packet.olderThan(ProtocolVersion.v1_17)) {
+            out.writeBoolean(this.column.isFull());
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16) && !packet.atLeast(ProtocolVersion.v1_16_2)) {
+            out.writeBoolean(this.column.useExistingLightData);
+        }
+        if (packet.olderThan(ProtocolVersion.v1_18)) {
+            out.writeBitSet(mask);
+        }
+        if (!packet.atLeast(ProtocolVersion.v1_8)) {
+            out.writeBitSet(extendedMask);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_14)) {
+            out.writeNBT(this.column.heightMaps);
+        }
+        int[] biomes = this.column.biomes;
+        if (packet.atLeast(ProtocolVersion.v1_15) && packet.olderThan(ProtocolVersion.v1_18) && biomes != null) {
+            if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                out.writeVarInt(biomes.length);
+                for (int biome : biomes) {
+                    out.writeVarInt(biome);
+                }
+            } else {
+                out.writeInts(biomes);
+            }
+        }
+        int len;
+        byte[] data;
+        if (packet.atLeast(ProtocolVersion.v1_8)) {
+            len = byteOut.size();
+            data = byteOut.toByteArray();
+        } else {
+            Deflater deflater = new Deflater(-1);
+            len = byteOut.size();
+            data = new byte[len];
+            try {
+                deflater.setInput(byteOut.toByteArray(), 0, len);
+                deflater.finish();
+                len = deflater.deflate(data);
+            } finally {
+                deflater.end();
+            }
+        }
+        out.writeVarInt(len);
+        out.writeBytes(data, len);
+        if (packet.atLeast(ProtocolVersion.v1_9_3)) {
+            out.writeVarInt(this.column.tileEntities.length);
+            for (TileEntity tileEntity : this.column.tileEntities) {
+                tileEntity.write(packet, out);
+            }
+        }
+        if (packet.atLeast(ProtocolVersion.v1_18)) {
+            PacketUpdateLight.writeData(packet, out, this.column.lightData);
+        }
+    }
+
+    private static Column readColumn(Packet packet, byte[] data, int x, int z, boolean fullChunk, boolean hasSkylight, BitSet mask, BitSet extendedMask, CompoundTag heightmaps, int[] biomes, boolean useExistingLightData) throws IOException {
+        NetInput in = new StreamNetInput(new ByteArrayInputStream(data));
+        if (packet.atLeast(ProtocolVersion.v1_17)) {
+            Chunk[] chunks = new Chunk[mask.length()];
+            for (int index = 0; index < chunks.length; index++) {
+                if (mask.get(index)) {
+                    chunks[index] = new Chunk(packet, in);
+                }
+            }
+            return new Column(x, z, chunks, null, null, heightmaps, biomes, useExistingLightData, null);
+        }
+
+        // Pre 1.17
+        Throwable ex = null;
+        Column column = null;
+        try {
+            Chunk[] chunks = new Chunk[16];
+            for(int index = 0; index < chunks.length; index++) {
+                if (mask.get(index)) {
+                    Chunk chunk;
+                    if (packet.atLeast(ProtocolVersion.v1_9)) {
+                        chunk = new Chunk(packet, in);
+                        if (packet.atMost(ProtocolVersion.v1_13_2)) {
+                            chunk.blockLight = in.readBytes(2048);
+                            chunk.skyLight = hasSkylight ? in.readBytes(2048) : null;
+                        }
+                    } else {
+                        chunk = new Chunk(packet);
+                    }
+                    chunks[index] = chunk;
+                }
+            }
+
+            if (!packet.atLeast(ProtocolVersion.v1_9)) {
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    for (Chunk chunk : chunks) {
+                        if (chunk != null) chunk.blocks.storage = FlexibleStorage.from(packet.getRegistry(), 0, 4096, in.readLongs(1024));
+                    }
+                } else {
+                    for (Chunk chunk : chunks) {
+                        if (chunk != null) chunk.blocks.storage = FlexibleStorage.from(packet.getRegistry(), 0, 4096, in.readLongs(512));
+                    }
+                    for (Chunk chunk : chunks) {
+                        if (chunk != null) chunk.blocks.metadata = in.readLongs(256);
+                    }
+                }
+                for (Chunk chunk : chunks) {
+                    if (chunk != null) chunk.blockLight = in.readBytes(2048);
+                }
+                if (hasSkylight) {
+                    for (Chunk chunk : chunks) {
+                        if (chunk != null) chunk.skyLight = in.readBytes(2048);
+                    }
+                }
+                // extendedMask should be 0 for 1.8+
+                for (int index = 0; index < chunks.length; index++) {
+                    if (extendedMask.get(index)) {
+                        if (chunks[index] == null) {
+                            in.readLongs(256);
+                        } else {
+                            chunks[index].blocks.extended = in.readLongs(256);
+                        }
+                    }
+                }
+            }
+
+            byte[] biomeData = null;
+            if (fullChunk && in.available() > 0 && !packet.atLeast(ProtocolVersion.v1_15)) {
+                biomeData = in.readBytes(packet.atLeast(ProtocolVersion.v1_13) ? 1024 : 256);
+            }
+
+            column = new Column(x, z, chunks, biomeData, null, heightmaps, biomes, useExistingLightData, null);
+        } catch(Throwable e) {
+            ex = e;
+        }
+
+        // Unfortunately, this is needed to detect whether the chunks contain skylight or not.
+        if((in.available() > 0 || ex != null) && !hasSkylight) {
+            return readColumn(packet, data, x, z, fullChunk, true, mask, extendedMask, heightmaps, biomes, useExistingLightData);
+        } else if(ex != null) {
+            throw new IOException("Failed to read chunk data.", ex);
+        }
+
+        return column;
+    }
+
+    private static Pair<BitSet, BitSet> writeColumn(Packet packet, NetOutput out, Column column, boolean fullChunk) throws IOException {
+        BitSet mask = new BitSet();
+        BitSet extendedMask = new BitSet();
+        Chunk[] chunks = column.chunks;
+        for (int index = 0; index < chunks.length; index++) {
+            Chunk chunk = chunks[index];
+            if (chunk != null) {
+                mask.set(index);
+                if (packet.atLeast(ProtocolVersion.v1_9)) {
+                    chunk.write(packet, out);
+                    if (packet.atMost(ProtocolVersion.v1_13_2)) {
+                        out.writeBytes(chunk.blockLight);
+                        if (chunk.skyLight != null) {
+                            out.writeBytes(chunk.skyLight);
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!packet.atLeast(ProtocolVersion.v1_9)) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                for (Chunk chunk : chunks) {
+                    if (chunk != null) out.writeLongs(chunk.blocks.storage.data);
+                }
+            } else {
+                for (Chunk chunk : chunks) {
+                    if (chunk != null) out.writeLongs(chunk.blocks.storage.data);
+                }
+                for (Chunk chunk : chunks) {
+                    if (chunk != null) out.writeLongs(chunk.blocks.metadata);
+                }
+            }
+            for (Chunk chunk : chunks) {
+                if (chunk != null) out.writeBytes(chunk.blockLight);
+            }
+            for (Chunk chunk : chunks) {
+                if (chunk != null && chunk.skyLight != null) out.writeBytes(chunk.skyLight);
+            }
+            // extended should be null for 1.8+
+            for (int index = 0; index < chunks.length; index++) {
+                if (chunks[index] != null && chunks[index].blocks.extended != null) {
+                    extendedMask.set(index);
+                    out.writeLongs(chunks[index].blocks.extended);
+                }
+            }
+        }
+
+        if (fullChunk && column.biomeData != null && !packet.atLeast(ProtocolVersion.v1_15)) {
+            out.writeBytes(column.biomeData);
+        }
+
+        return Pair.of(mask, extendedMask);
+    }
+
+    public static class Column {
+        public int x;
+        public int z;
+        public Chunk[] chunks;
+        public byte[] biomeData; // pre 1.15
+        public TileEntity[] tileEntities;
+        public CompoundTag heightMaps;
+        public int[] biomes; // 1.15+ pre 1.18
+        public boolean useExistingLightData; // 1.16+
+        public PacketUpdateLight.Data lightData; // 1.18+
+
+        public Column(int x, int z, Chunk[] chunks, byte[] biomeData, TileEntity[] tileEntities, CompoundTag heightmaps, int[] biomes, boolean useExistingLightData, PacketUpdateLight.Data lightData) {
+            this.x = x;
+            this.z = z;
+            this.chunks = chunks;
+            this.biomeData = biomeData;
+            this.tileEntities = tileEntities;
+            this.heightMaps = heightmaps;
+            this.biomes = biomes;
+            this.useExistingLightData = useExistingLightData;
+            this.lightData = lightData;
+        }
+
+        public boolean isFull() {
+            return this.biomeData != null || this.biomes != null || (this.lightData != null && this.tileEntities != null);
+        }
+
+        public boolean looksLikeUnloadOnMC1_8() {
+            return isFull() && Utils.containsOnlyNull(chunks);
+        }
+
+        public BitSet getChunkMask() {
+            BitSet mask = new BitSet();
+            for (int index = 0; index < chunks.length; index++) {
+                if (chunks[index] != null) {
+                    mask.set(index);
+                }
+            }
+            return mask;
+        }
+
+        public boolean hasSkyLightV1_8() {
+            for (Chunk chunk : chunks) {
+                if (chunk != null && chunk.skyLight != null) {
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        public static long coordToLong(int x, int z) {
+            return (long)x << 32 | (long)z & 0xFFFFFFFFL;
+        }
+
+        public static int longToX(long v) {
+            return (int) (v >> 32);
+        }
+
+        public static int longToZ(long v) {
+            return (int) (v & 0xFFFFFFFFL);
+        }
+
+        public long coordToLong() {
+            return coordToLong(x, z);
+        }
+    }
+
+    public static class Chunk {
+        private final int blockCount;
+        public final PalettedStorage blocks;
+        public final PalettedStorage biomes; // 1.18+
+        public byte[] blockLight; // pre 1.14
+        public byte[] skyLight; // pre 1.14
+
+        private Chunk(Chunk from) {
+            this.blockCount = from.blockCount;
+            this.blocks = from.blocks != null ? from.blocks.copy() : null;
+            this.biomes = from.biomes != null ? from.biomes.copy() : null;
+            this.blockLight = from.blockLight != null ? from.blockLight.clone() : null;
+            this.skyLight = from.skyLight != null ? from.skyLight.clone() : null;
+        }
+
+        /**
+         * 1.9+
+         */
+        public Chunk(PacketTypeRegistry registry) {
+            this.blockCount = 0;
+            this.blocks = new PalettedStorage(PaletteType.BLOCKS, registry);
+            if (registry.atLeast(ProtocolVersion.v1_18)) {
+                this.biomes = new PalettedStorage(PaletteType.BIOMES, registry);
+            } else {
+                this.biomes = null;
+            }
+        }
+
+        // 1.7-1.8
+        Chunk(Packet packet) {
+            this.blockCount = 0;
+            this.blocks = new PalettedStorage(PaletteType.BLOCKS, packet);
+            this.biomes = null;
+        }
+
+        // 1.9+
+        Chunk(Packet packet, NetInput in) throws IOException {
+            this.blockCount = packet.atLeast(ProtocolVersion.v1_14) ? in.readShort() : 0;
+            this.blocks = new PalettedStorage(PaletteType.BLOCKS, packet, in);
+            if (packet.atLeast(ProtocolVersion.v1_18)) {
+                this.biomes = new PalettedStorage(PaletteType.BIOMES, packet, in);
+            } else {
+                this.biomes = null;
+            }
+        }
+
+        // 1.9+
+        void write(Packet packet, NetOutput out) throws IOException {
+            if (packet.atLeast(ProtocolVersion.v1_14)) {
+                out.writeShort(this.blockCount + this.blocks.countDelta);
+            }
+            this.blocks.write(packet, out);
+            if (this.biomes != null) {
+                this.biomes.write(packet, out);
+            }
+        }
+
+        public Chunk copy() {
+            return new Chunk(this);
+        }
+    }
+
+    public static class PalettedStorage {
+        private final PaletteType type;
+        private final PacketTypeRegistry registry;
+        private int countDelta;
+        private int bitsPerEntry;
+        private List<Integer> states;
+        private FlexibleStorage storage;
+        private long[] metadata; // 1.7 only
+        private long[] extended; // 1.7 only
+
+        private PalettedStorage(PalettedStorage from) {
+            this.type = from.type;
+            this.registry = from.registry;
+            this.countDelta = from.countDelta;
+            this.bitsPerEntry = from.bitsPerEntry;
+            if (from.states != null) {
+                this.states = new ArrayList<>(from.states);
+            }
+            if (from.storage != null) {
+                this.storage = FlexibleStorage.from(registry, bitsPerEntry, from.storage.entries, from.storage.data.clone());
+            }
+            if (from.metadata != null) {
+                this.metadata = from.metadata.clone();
+            }
+            if (from.extended != null) {
+                this.extended = from.extended.clone();
+            }
+        }
+
+        /**
+         * 1.9+
+         */
+        public PalettedStorage(PaletteType type, PacketTypeRegistry registry) {
+            this.type = type;
+            this.registry = registry;
+            this.bitsPerEntry = type == PaletteType.BLOCKS ? 4 : 0;
+
+            this.states = new ArrayList<>();
+            this.states.add(0);
+
+            this.storage = FlexibleStorage.empty(registry, bitsPerEntry, type.size());
+        }
+
+        // 1.7-1.8
+        PalettedStorage(PaletteType type, Packet packet) {
+            this.type = type;
+            this.registry = packet.getRegistry();
+            this.bitsPerEntry = type.highestBitsPerValue() + 1; // these versions never use a local palette
+        }
+
+        // 1.9+
+        PalettedStorage(PaletteType type, Packet packet, NetInput in) throws IOException {
+            this.type = type;
+            this.registry = packet.getRegistry();
+            this.bitsPerEntry = in.readUnsignedByte();
+            this.states = new ArrayList<>();
+            int stateCount;
+            if (this.bitsPerEntry > type.highestBitsPerValue() && packet.atLeast(ProtocolVersion.v1_13)) {
+                stateCount = 0;
+            } else if (this.bitsPerEntry == 0 && packet.atLeast(ProtocolVersion.v1_18)) {
+                stateCount = 1;
+            } else {
+                stateCount = in.readVarInt();
+            }
+            for(int i = 0; i < stateCount; ++i) {
+                this.states.add(in.readVarInt());
+            }
+
+            this.storage = FlexibleStorage.from(registry, bitsPerEntry, type.size(), in.readLongs(in.readVarInt()));
+        }
+
+        // 1.9+
+        void write(Packet packet, NetOutput out) throws IOException {
+            out.writeByte(this.bitsPerEntry);
+            if (this.bitsPerEntry == 0 && packet.atLeast(ProtocolVersion.v1_18)) {
+                out.writeVarInt(this.states.get(0));
+            } else if (this.bitsPerEntry <= type.highestBitsPerValue() || !packet.atLeast(ProtocolVersion.v1_13)) {
+                out.writeVarInt(this.states.size());
+                for (Integer state : this.states) {
+                    out.writeVarInt(state);
+                }
+            }
+
+            out.writeVarInt(storage.data.length);
+            out.writeLongs(storage.data);
+        }
+
+        private int index(int x, int y, int z) {
+            if (this.type == PaletteType.BIOMES) {
+                return y << 4 | z << 2 | x;
+            } else {
+                return y << 8 | z << 4 | x;
+            }
+        }
+
+        /**
+         * Only 1.8+
+         */
+        public int get(int x, int y, int z) {
+            if (this.bitsPerEntry == 0) {
+                return this.states.get(0);
+            }
+            int id = this.storage.get(index(x, y, z));
+            return this.bitsPerEntry <= type.highestBitsPerValue() ? (id >= 0 && id < this.states.size() ? this.states.get(id) : 0) : id;
+        }
+
+        /**
+         * Only 1.8+
+         */
+        public void set(int x, int y, int z, int state) {
+            int id = this.bitsPerEntry <= type.highestBitsPerValue() ? this.states.indexOf(state) : state;
+            if(id == -1) {
+                this.states.add(state);
+                if(this.states.size() > 1 << this.bitsPerEntry) {
+                    this.bitsPerEntry++;
+
+                    List<Integer> oldStates = this.states;
+                    if(this.bitsPerEntry > type.highestBitsPerValue()) {
+                        oldStates = new ArrayList<Integer>(this.states);
+                        this.states.clear();
+                        // These match the size of the vanilla global palette and may be incorrect when it comes to
+                        // modded servers.
+                        // Unfortunately there is no easy way to determine what the actual size of the global palette
+                        // should be without having to parse the mod loader handshake. Which is annoying, so it has not
+                        // yet been implemented.
+                        if (registry.atLeast(ProtocolVersion.v1_16)) {
+                            this.bitsPerEntry = 15;
+                        } else if (registry.atLeast(ProtocolVersion.v1_13)) {
+                            this.bitsPerEntry = 14;
+                        } else {
+                            this.bitsPerEntry = 13;
+                        }
+
+                        // Luckily, we currently only modify the block storage for internal tracking, and as long as
+                        // we don't send it, the actual size we use doesn't really matter and we can just increase it
+                        // if it turns out to have been too small.
+                        // We do this here initially, and then also below immediately before `set` if the new id is OOB.
+                        int bitsUsed = (1 << this.bitsPerEntry) - 1;
+                        for (int i = 0; i < this.storage.entries; i++) {
+                            bitsUsed |= this.storage.get(i);
+                        }
+                        this.bitsPerEntry = 32 - Integer.numberOfLeadingZeros(bitsUsed);
+                    }
+
+                    FlexibleStorage oldStorage = this.storage;
+                    this.storage = FlexibleStorage.empty(this.registry, this.bitsPerEntry, this.storage.entries);
+                    for(int index = 0; index < this.storage.entries; index++) {
+                        this.storage.set(index, oldStorage.get(index));
+                    }
+                }
+
+                id = this.bitsPerEntry <= type.highestBitsPerValue() ? this.states.indexOf(state) : state;
+            }
+
+            if (this.bitsPerEntry == 0) {
+                return;
+            }
+
+            int ind = index(x, y, z);
+            int curr = this.storage.get(ind);
+            if(state != 0 && curr == 0) {
+                countDelta++;
+            } else if(state == 0 && curr != 0) {
+                countDelta--;
+            }
+
+            if (this.bitsPerEntry > type.highestBitsPerValue() && id > this.storage.maxEntryValue) {
+                // Workaround for us not knowing the size of the global palette. See the two comment blocks above.
+                // Determine how many bits we need per entry to fit this id
+                this.bitsPerEntry = 32 - Integer.numberOfLeadingZeros(id);
+                // Convert old storage to new entry size
+                FlexibleStorage oldStorage = this.storage;
+                this.storage = FlexibleStorage.empty(this.registry, this.bitsPerEntry, this.storage.entries);
+                for (int i = 0; i < this.storage.entries; i++) {
+                    this.storage.set(i, oldStorage.get(i));
+                }
+            }
+            this.storage.set(ind, id);
+        }
+
+        public PalettedStorage copy() {
+            return new PalettedStorage(this);
+        }
+    }
+
+    private static abstract class FlexibleStorage {
+        protected final long[] data;
+        protected final int bitsPerEntry;
+        protected final int entries;
+        protected final long maxEntryValue;
+
+        protected FlexibleStorage(long[] data, int bitsPerEntry, int entries) {
+            this.data = data;
+            this.bitsPerEntry = bitsPerEntry;
+            this.entries = entries;
+            this.maxEntryValue = (1L << this.bitsPerEntry) - 1;
+        }
+
+        public abstract int get(int index);
+        public abstract void set(int index, int value);
+
+        static FlexibleStorage empty(PacketTypeRegistry registry, int bitsPerEntry, int entries) {
+            if (registry.atLeast(ProtocolVersion.v1_16)) {
+                return new PaddedFlexibleStorage(bitsPerEntry, entries);
+            } else {
+                return new CompactFlexibleStorage(bitsPerEntry, entries);
+            }
+        }
+
+        static FlexibleStorage from(PacketTypeRegistry registry, int bitsPerEntry, int entries, long[] data) {
+            if (registry.atLeast(ProtocolVersion.v1_16)) {
+                return new PaddedFlexibleStorage(bitsPerEntry, entries, data);
+            } else {
+                return new CompactFlexibleStorage(bitsPerEntry, entries, data);
+            }
+        }
+    }
+
+    private static class PaddedFlexibleStorage extends FlexibleStorage {
+        private final int entriesPerLong;
+
+        public PaddedFlexibleStorage(int bitsPerEntry, int entries) {
+            this(bitsPerEntry, entries, new long[longsForEntries(bitsPerEntry, entries)]);
+        }
+
+        public PaddedFlexibleStorage(int bitsPerEntry, int entries, long[] data) {
+            super(data, bitsPerEntry, entries);
+            this.entriesPerLong = bitsPerEntry == 0 ? 0 : 64 / bitsPerEntry;
+        }
+
+        private static int longsForEntries(int bitsPerEntry, int entries) {
+            if (bitsPerEntry == 0) {
+                return 0;
+            }
+            int entriesPerLong = 64 / bitsPerEntry;
+            return (entries + entriesPerLong - 1) / entriesPerLong;
+        }
+
+        @Override
+        public int get(int index) {
+            if (index < 0 || index > this.entries - 1) {
+                throw new IndexOutOfBoundsException();
+            }
+            if (this.bitsPerEntry == 0) {
+                return 0;
+            }
+
+            int blockIndex = index / this.entriesPerLong;
+            int subIndex = index % this.entriesPerLong;
+            int subIndexBits = subIndex * this.bitsPerEntry;
+            return (int) (this.data[blockIndex] >>> subIndexBits & this.maxEntryValue);
+        }
+
+        @Override
+        public void set(int index, int value) {
+            if (index < 0 || index > this.entries - 1) {
+                throw new IndexOutOfBoundsException();
+            }
+
+            if (value < 0 || value > this.maxEntryValue) {
+                throw new IllegalArgumentException("Value cannot be outside of accepted range.");
+            }
+
+            int blockIndex = index / this.entriesPerLong;
+            int subIndex = index % this.entriesPerLong;
+            int subIndexBits = subIndex * this.bitsPerEntry;
+            this.data[blockIndex] = this.data[blockIndex] & ~(this.maxEntryValue << subIndexBits) | ((long) value & this.maxEntryValue) << subIndexBits;
+        }
+    }
+
+    private static class CompactFlexibleStorage extends FlexibleStorage {
+        public CompactFlexibleStorage(int bitsPerEntry, int entries) {
+            this(bitsPerEntry, entries, new long[roundToNearest(entries * bitsPerEntry, 64) / 64]);
+        }
+
+        public CompactFlexibleStorage(int bitsPerEntry, int entries, long[] data) {
+            super(data, bitsPerEntry, entries);
+        }
+
+        private static int roundToNearest(int value, int roundTo) {
+            if(roundTo == 0) {
+                return 0;
+            } else if(value == 0) {
+                return roundTo;
+            } else {
+                if(value < 0) {
+                    roundTo *= -1;
+                }
+
+                int remainder = value % roundTo;
+                return remainder != 0 ? value + roundTo - remainder : value;
+            }
+        }
+
+        @Override
+        public int get(int index) {
+            if(index < 0 || index > this.entries - 1) {
+                throw new IndexOutOfBoundsException();
+            }
+            if (this.bitsPerEntry == 0) {
+                return 0;
+            }
+
+            int bitIndex = index * this.bitsPerEntry;
+            int startIndex = bitIndex / 64;
+            int endIndex = ((index + 1) * this.bitsPerEntry - 1) / 64;
+            int startBitSubIndex = bitIndex % 64;
+            if(startIndex == endIndex) {
+                return (int) (this.data[startIndex] >>> startBitSubIndex & this.maxEntryValue);
+            } else {
+                int endBitSubIndex = 64 - startBitSubIndex;
+                return (int) ((this.data[startIndex] >>> startBitSubIndex | this.data[endIndex] << endBitSubIndex) & this.maxEntryValue);
+            }
+        }
+
+        @Override
+        public void set(int index, int value) {
+            if(index < 0 || index > this.entries - 1) {
+                throw new IndexOutOfBoundsException();
+            }
+
+            if(value < 0 || value > this.maxEntryValue) {
+                throw new IllegalArgumentException("Value cannot be outside of accepted range.");
+            }
+
+            int bitIndex = index * this.bitsPerEntry;
+            int startIndex = bitIndex / 64;
+            int endIndex = ((index + 1) * this.bitsPerEntry - 1) / 64;
+            int startBitSubIndex = bitIndex % 64;
+            this.data[startIndex] = this.data[startIndex] & ~(this.maxEntryValue << startBitSubIndex) | ((long) value & this.maxEntryValue) << startBitSubIndex;
+            if(startIndex != endIndex) {
+                int endBitSubIndex = 64 - startBitSubIndex;
+                this.data[endIndex] = this.data[endIndex] >>> endBitSubIndex << endBitSubIndex | ((long) value & this.maxEntryValue) >> endBitSubIndex;
+            }
+        }
+    }
+
+    public static class TileEntity {
+        public byte xz; // 1.18+
+        public short y; // 1.18+
+        public int type; // 1.18+
+        public CompoundTag tag;
+
+        TileEntity(Packet packet, Packet.Reader in) throws IOException {
+            if (packet.atLeast(ProtocolVersion.v1_18)) {
+                this.xz = in.readByte();
+                this.y = in.readShort();
+                this.type = in.readVarInt();
+            }
+            this.tag = in.readNBT();
+        }
+
+        void write(Packet packet, Packet.Writer out) throws IOException {
+            if (packet.atLeast(ProtocolVersion.v1_18)) {
+                out.writeByte(this.xz);
+                out.writeShort(this.y);
+                out.writeVarInt(this.type);
+            }
+            out.writeNBT(this.tag);
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketConfigRegistries.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketConfigRegistries.java
new file mode 100644
index 0000000000000000000000000000000000000000..7994e7292407a46bf4244f0c1e9fcde281fd3668
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketConfigRegistries.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2023
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import java.io.IOException;
+
+public class PacketConfigRegistries {
+    public static CompoundTag read(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readNBT();
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, CompoundTag registries) throws IOException {
+        Packet packet = new Packet(registry, PacketType.ConfigRegistries);
+        try (Packet.Writer writer = packet.overwrite()) {
+            writer.writeNBT(registries);
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketDestroyEntities.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketDestroyEntities.java
new file mode 100644
index 0000000000000000000000000000000000000000..bbd076b549982720cbf61689d92f2898a1dd67c5
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketDestroyEntities.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+public class PacketDestroyEntities {
+    public static List<Integer> getEntityIds(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.getType() == PacketType.DestroyEntity) {
+                return Collections.singletonList(in.readVarInt());
+            }
+            int len = packet.atLeast(ProtocolVersion.v1_8) ? in.readVarInt() : in.readByte();
+            List<Integer> result = new ArrayList<>(len);
+            for (int i = 0; i < len; i++) {
+                result.add(packet.atLeast(ProtocolVersion.v1_8) ? in.readVarInt() : in.readInt());
+            }
+            return result;
+        }
+    }
+
+    public static Collection<Packet> write(PacketTypeRegistry registry, int...entityIds) throws IOException {
+        if (registry.atLeast(ProtocolVersion.v1_17) && registry.olderThan(ProtocolVersion.v1_17_1)) {
+            List<Packet> packets = new ArrayList<>(entityIds.length);
+            for (int entityId : entityIds) {
+                packets.add(write(registry, entityId));
+            }
+            return packets;
+        } else {
+            return Collections.singletonList(writeDestroyEntities(registry, entityIds));
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int entityId) throws IOException {
+        if (registry.atLeast(ProtocolVersion.v1_17) && registry.olderThan(ProtocolVersion.v1_17_1)) {
+            Packet packet = new Packet(registry, PacketType.DestroyEntity);
+            try (Packet.Writer out = packet.overwrite()) {
+                out.writeVarInt(entityId);
+            }
+            return packet;
+        } else {
+            return writeDestroyEntities(registry, entityId);
+        }
+    }
+
+    // All versions except 1.17.0
+    private static Packet writeDestroyEntities(PacketTypeRegistry registry, int...entityIds) throws IOException {
+        Packet packet = new Packet(registry, PacketType.DestroyEntities);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writeVarInt(entityIds.length);
+            } else {
+                out.writeByte(entityIds.length);
+            }
+            for (int entityId : entityIds) {
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    out.writeVarInt(entityId);
+                } else {
+                    out.writeInt(entityId);
+                }
+            }
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityHeadLook.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityHeadLook.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ea66904e0a3b397a61e52ef14bb3446ae7511dd
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityHeadLook.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.util.Location;
+
+import java.io.IOException;
+
+public class PacketEntityHeadLook {
+    public static float getYaw(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                in.readVarInt(); // entity id
+            } else {
+                in.readInt(); // entity id
+            }
+            return in.readByte() / 256f * 360;
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int entityId, float yaw) throws IOException {
+        Packet packet = new Packet(registry, PacketType.EntityHeadLook);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writeVarInt(entityId);
+            } else {
+                out.writeInt(entityId);
+            }
+            out.writeByte((int) (yaw / 360 * 256));
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityMovement.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityMovement.java
new file mode 100644
index 0000000000000000000000000000000000000000..f5aa79de40ad45496002f70b936c10c0c785df0b
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityMovement.java
@@ -0,0 +1,118 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.util.DPosition;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.commons.lang3.tuple.Triple;
+
+import java.io.IOException;
+
+public class PacketEntityMovement {
+    public static Triple<DPosition, Pair<Float, Float>, Boolean> getMovement(Packet packet) throws IOException {
+        PacketType type = packet.getType();
+        boolean hasPos = type == PacketType.EntityPosition || type == PacketType.EntityPositionRotation;
+        boolean hasRot = type == PacketType.EntityRotation || type == PacketType.EntityPositionRotation;
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                in.readVarInt(); // entity id
+            } else {
+                in.readInt(); // entity id
+            }
+            DPosition pos = null;
+            if (hasPos) {
+                if (packet.atLeast(ProtocolVersion.v1_9)) {
+                    pos = new DPosition(
+                            in.readShort() / 4096.0,
+                            in.readShort() / 4096.0,
+                            in.readShort() / 4096.0
+                    );
+                } else {
+                    pos = new DPosition(
+                            in.readByte() / 32.0,
+                            in.readByte() / 32.0,
+                            in.readByte() / 32.0
+                    );
+                }
+            }
+            Pair<Float, Float> yawPitch = null;
+            if (hasRot) {
+                yawPitch = Pair.of(
+                        in.readByte() / 256f * 360,
+                        in.readByte() / 256f * 360
+                );
+            }
+            boolean onGround = true;
+            if (packet.atLeast(ProtocolVersion.v1_8) && (hasPos || hasRot)) {
+                onGround = in.readBoolean();
+            }
+            return Triple.of(pos, yawPitch, onGround);
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int entityId, DPosition deltaPos, Pair<Float, Float> yawPitch, boolean onGround) throws IOException {
+        boolean hasPos = deltaPos != null;
+        boolean hasRot = yawPitch != null;
+        PacketType type;
+        if (hasPos) {
+            if (hasRot) {
+                type = PacketType.EntityPositionRotation;
+            } else {
+                type = PacketType.EntityPosition;
+            }
+        } else {
+            if (hasRot) {
+                type = PacketType.EntityRotation;
+            } else {
+                type = PacketType.EntityMovement;
+            }
+        }
+        Packet packet = new Packet(registry, type);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writeVarInt(entityId);
+            } else {
+                out.writeInt(entityId);
+            }
+            if (hasPos) {
+                if (packet.atLeast(ProtocolVersion.v1_9)) {
+                    out.writeShort((int) (deltaPos.getX() * 4096));
+                    out.writeShort((int) (deltaPos.getY() * 4096));
+                    out.writeShort((int) (deltaPos.getZ() * 4096));
+                } else {
+                    out.writeByte((int) (deltaPos.getX() * 32));
+                    out.writeByte((int) (deltaPos.getY() * 32));
+                    out.writeByte((int) (deltaPos.getZ() * 32));
+                }
+            }
+            if (hasRot) {
+                out.writeByte((int) (yawPitch.getKey() / 360 * 256));
+                out.writeByte((int) (yawPitch.getValue() / 360 * 256));
+            }
+            if (packet.atLeast(ProtocolVersion.v1_8) && (hasPos || hasRot)) {
+                out.writeBoolean(onGround);
+            }
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityTeleport.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityTeleport.java
new file mode 100644
index 0000000000000000000000000000000000000000..dbe451468e0bd813f5fb1ad3d266bed575f84c77
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketEntityTeleport.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.util.Location;
+
+import java.io.IOException;
+
+public class PacketEntityTeleport {
+    public static Location getLocation(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                in.readVarInt(); // entity id
+            } else {
+                in.readInt(); // entity id
+            }
+            return SpawnEntity.readXYZYaPi(packet, in, false);
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int entityId, Location location, boolean onGround) throws IOException {
+        Packet packet = new Packet(registry, PacketType.EntityTeleport);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writeVarInt(entityId);
+            } else {
+                out.writeInt(entityId);
+            }
+            SpawnEntity.writeXYZYaPi(packet, out, location);
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writeBoolean(onGround);
+            }
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketJoinGame.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketJoinGame.java
new file mode 100644
index 0000000000000000000000000000000000000000..619943ea1c2f90f236af3fc0920ebb77d0506b99
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketJoinGame.java
@@ -0,0 +1,313 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.github.steveice10.opennbt.tag.builtin.ListTag;
+import com.github.steveice10.opennbt.tag.builtin.StringTag;
+import com.github.steveice10.opennbt.tag.builtin.Tag;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.protocol.registry.DimensionType;
+import com.replaymod.replaystudio.util.IGlobalPosition;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+public class PacketJoinGame {
+    public int entityId;
+    public boolean hardcore;
+    public byte gameMode;
+    public byte prevGameMode; // 1.16+
+    public List<String> dimensions; // 1.16+
+    public CompoundTag registries; // 1.16+, no longer transmitted as of 1.20.2 but still required for decoding
+    public DimensionType dimensionType;
+    public String dimension;
+    public long seed; // 1.15+
+    public int difficulty; // pre 1.14
+    public int maxPlayers;
+    public int viewDistance; // 1.14+
+    public int simulationDistance; // 1.18+
+    public boolean reducedDebugInfo; // 1.8+
+    public boolean respawnScreen; // 1.15+
+    public boolean limitedCrafting; // 1.22.2+
+    public boolean debugWorld; // 1.16+
+    public boolean flatWorld; // 1.16+
+    public IGlobalPosition lastDeathPosition; // 1.19+
+    public int portalCooldown; // 1.20+
+
+    public PacketJoinGame() {
+    }
+
+    public PacketJoinGame(PacketJoinGame other) {
+        this.entityId = other.entityId;
+        this.hardcore = other.hardcore;
+        this.gameMode = other.gameMode;
+        this.prevGameMode = other.prevGameMode;
+        this.dimensions = other.dimensions;
+        this.registries = other.registries;
+        this.dimensionType = other.dimensionType;
+        this.dimension = other.dimension;
+        this.seed = other.seed;
+        this.difficulty = other.difficulty;
+        this.maxPlayers = other.maxPlayers;
+        this.viewDistance = other.viewDistance;
+        this.simulationDistance = other.simulationDistance;
+        this.reducedDebugInfo = other.reducedDebugInfo;
+        this.respawnScreen = other.respawnScreen;
+        this.limitedCrafting = other.limitedCrafting;
+        this.debugWorld = other.debugWorld;
+        this.flatWorld = other.flatWorld;
+        this.lastDeathPosition = other.lastDeathPosition;
+        this.portalCooldown = other.portalCooldown;
+    }
+
+    public static PacketJoinGame read(Packet packet, /* 1.20.2+ */ CompoundTag registries) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            PacketJoinGame joinGame = new PacketJoinGame();
+            joinGame.registries = registries;
+            joinGame.read(packet, in);
+            return joinGame;
+        }
+    }
+
+    public void read(Packet packet, Packet.Reader in) throws IOException {
+        this.entityId = in.readInt();
+        if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+            this.hardcore = in.readBoolean();
+            if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+                this.gameMode = in.readByte();
+            }
+        } else {
+            int flags = in.readByte();
+            this.hardcore = (flags & 0x8) != 0;
+            this.gameMode = (byte) (flags & ~0x8);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+                this.prevGameMode = in.readByte();
+            }
+            int count = in.readVarInt();
+            this.dimensions = new ArrayList<>(count);
+            for (int i = 0; i < count; i++) {
+                this.dimensions.add(in.readString());
+            }
+            if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+                this.registries = in.readNBT();
+                if (packet.atLeast(ProtocolVersion.v1_19)) {
+                    this.dimensionType = getDimensionType(this.registries, in.readString());
+                } else if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                    this.dimensionType = new DimensionType(in.readNBT());
+                } else {
+                    this.dimensionType = new DimensionType(in.readString());
+                }
+            }
+        }
+
+        if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+            if (packet.atLeast(ProtocolVersion.v1_16)) {
+                this.dimension = in.readString();
+            } else if (packet.atLeast(ProtocolVersion.v1_9_1)) {
+                this.dimension = String.valueOf(in.readInt());
+            } else {
+                this.dimension = String.valueOf(in.readByte());
+            }
+
+            if (packet.atLeast(ProtocolVersion.v1_15)) {
+                this.seed = in.readLong();
+            }
+        }
+        if (packet.olderThan(ProtocolVersion.v1_14)) {
+            this.difficulty = in.readByte();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+            this.maxPlayers = in.readVarInt();
+        } else {
+            this.maxPlayers = in.readByte();
+        }
+        if (packet.olderThan(ProtocolVersion.v1_16)) {
+            this.dimensionType = new DimensionType(in.readString());
+        }
+        if (packet.atLeast(ProtocolVersion.v1_14)) {
+            this.viewDistance = in.readVarInt();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_18)) {
+            this.simulationDistance = in.readVarInt();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_8)) {
+            this.reducedDebugInfo = in.readBoolean();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_15)) {
+            this.respawnScreen = in.readBoolean();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+            this.limitedCrafting = in.readBoolean();
+            this.dimensionType = getDimensionType(this.registries, in.readString());
+            this.dimension = in.readString();
+            this.seed = in.readLong();
+            this.gameMode = in.readByte();
+            this.prevGameMode = in.readByte();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            this.debugWorld = in.readBoolean();
+            this.flatWorld = in.readBoolean();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_19)) {
+            if (in.readBoolean()) {
+                this.lastDeathPosition = in.readGlobalPosition();
+            }
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20)) {
+            this.portalCooldown = in.readVarInt();
+        }
+    }
+
+    public Packet write(PacketTypeRegistry registry) throws IOException {
+        Packet packet = new Packet(registry, PacketType.JoinGame);
+        try (Packet.Writer out = packet.overwrite()) {
+            write(packet, out);
+        }
+        return packet;
+    }
+
+    public void write(Packet packet, Packet.Writer out) throws IOException {
+        out.writeInt(this.entityId);
+        if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+            out.writeBoolean(this.hardcore);
+            if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+                out.writeByte(this.gameMode);
+            }
+        } else {
+            out.writeByte((this.hardcore ? 0x8 : 0) | this.gameMode);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+                out.writeByte(this.prevGameMode);
+            }
+            out.writeVarInt(this.dimensions.size());
+            for (String dimension : this.dimensions) {
+                out.writeString(dimension);
+            }
+            if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+                out.writeNBT(this.registries);
+                if (packet.atLeast(ProtocolVersion.v1_19)) {
+                    out.writeString(this.dimensionType.getName());
+                } else if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                    out.writeNBT(this.dimensionType.getTag());
+                } else {
+                    out.writeString(this.dimensionType.getName());
+                }
+            }
+        }
+
+        if (packet.olderThan(ProtocolVersion.v1_20_2)) {
+            if (packet.atLeast(ProtocolVersion.v1_16)) {
+                out.writeString(this.dimension);
+            } else if (packet.atLeast(ProtocolVersion.v1_9_1)) {
+                out.writeInt(Integer.parseInt(this.dimension));
+            } else {
+                out.writeByte(Integer.parseInt(this.dimension));
+            }
+
+            if (packet.atLeast(ProtocolVersion.v1_15)) {
+                out.writeLong(this.seed);
+            }
+        }
+        if (packet.olderThan(ProtocolVersion.v1_14)) {
+            out.writeByte(this.difficulty);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+            out.writeVarInt(this.maxPlayers);
+        } else {
+            out.writeByte(this.maxPlayers);
+        }
+        if (packet.olderThan(ProtocolVersion.v1_16)) {
+            out.writeString(this.dimensionType.getName());
+        }
+        if (packet.atLeast(ProtocolVersion.v1_14)) {
+            out.writeVarInt(this.viewDistance);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_18)) {
+            out.writeVarInt(this.simulationDistance);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_8)) {
+            out.writeBoolean(this.reducedDebugInfo);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_15)) {
+            out.writeBoolean(this.respawnScreen);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+            out.writeBoolean(this.limitedCrafting);
+            out.writeString(this.dimensionType.getName());
+            out.writeString(this.dimension);
+            out.writeLong(this.seed);
+            out.writeByte(this.gameMode);
+            out.writeByte(this.prevGameMode);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            out.writeBoolean(this.debugWorld);
+            out.writeBoolean(this.flatWorld);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_19)) {
+            if (this.lastDeathPosition != null) {
+                out.writeBoolean(true);
+                out.writeGlobalPosition(this.lastDeathPosition);
+            } else {
+                out.writeBoolean(false);
+            }
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20)) {
+            out.writeVarInt(this.portalCooldown);
+        }
+    }
+
+    public static ListTag getRegistry(CompoundTag registries, String id) {
+        if (registries == null) {
+            return null;
+        }
+        CompoundTag entry = registries.get(id);
+        if (entry == null) {
+            return null;
+        }
+        return entry.get("value");
+    }
+
+    public static CompoundTag getRegistryEntry(CompoundTag registries, String registryId, String entryId) {
+        ListTag entries = getRegistry(registries, registryId);
+        if (entries == null) return null;
+        for (Tag entry : entries) {
+            StringTag name = ((CompoundTag) entry).get("name");
+            if (name != null && name.getValue().equals(entryId)) {
+                return ((CompoundTag) entry).get("element");
+            }
+        }
+        return null;
+    }
+
+    public static DimensionType getDimensionType(CompoundTag registries, String id) {
+        CompoundTag tag = getRegistryEntry(registries, "minecraft:dimension_type", id);
+        if (tag == null) {
+            tag = new CompoundTag();
+        }
+        return new DimensionType(tag, id);
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketLoginSuccess.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketLoginSuccess.java
new file mode 100644
index 0000000000000000000000000000000000000000..2081c359083affedf53eb2eb2cdd76cc814a69b6
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketLoginSuccess.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.util.Property;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.UUID;
+
+public class PacketLoginSuccess {
+    private final UUID id;
+    private final String name;
+    private final List<Property> properties; // 1.19+
+
+    public PacketLoginSuccess(UUID id, String name, List<Property> properties) {
+        this.id = id;
+        this.name = name;
+        this.properties = properties;
+    }
+
+    public static PacketLoginSuccess read(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            UUID id;
+            if (packet.atLeast(ProtocolVersion.v1_16)) {
+                id = in.readUUID();
+            } else {
+                id = UUID.fromString(in.readString());
+            }
+            String name = in.readString();
+            List<Property> properties = null;
+            if (packet.atLeast(ProtocolVersion.v1_19)) {
+                properties = in.readList(() -> Property.read(in));
+            }
+            return new PacketLoginSuccess(id, name, properties);
+        }
+    }
+
+    public Packet write(PacketTypeRegistry registry) throws IOException {
+        Packet packet = new Packet(registry, PacketType.LoginSuccess);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_16)) {
+                out.writeUUID(id);
+            } else {
+                out.writeString(id.toString());
+            }
+            out.writeString(name);
+            if (packet.atLeast(ProtocolVersion.v1_19)) {
+                out.writeList(properties, it -> it.write(out));
+            }
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketMapData.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketMapData.java
new file mode 100644
index 0000000000000000000000000000000000000000..378e66a25b95a10194699b9e7f892376748180e4
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketMapData.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+
+public class PacketMapData {
+    public static int getMapId(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readVarInt();
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketNotifyClient.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketNotifyClient.java
new file mode 100644
index 0000000000000000000000000000000000000000..1851901d13beef36d973b5ff6ad64dd6022bc7c7
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketNotifyClient.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import java.io.IOException;
+
+public class PacketNotifyClient {
+    public enum Action {
+        INVALID_BED,
+        START_RAIN,
+        STOP_RAIN,
+        CHANGE_GAMEMODE,
+        ENTER_CREDITS,
+        DEMO_MESSAGE,
+        ARROW_HIT_PLAYER,
+        RAIN_STRENGTH,
+        THUNDER_STRENGTH,
+        AFFECTED_BY_PUFFERFISH,
+        AFFECTED_BY_ELDER_GUARDIAN,
+        IMMEDIATE_RESPAWN,
+        LIMITED_CRAFTING,
+        INITIAL_CHUNKS_COMING,
+        ;
+    }
+
+    public static Action getAction(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return Action.values()[in.readUnsignedByte()];
+        }
+    }
+
+    public static float getValue(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            in.readUnsignedByte(); // action
+            return in.readFloat();
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, Action action, float value) throws IOException {
+        Packet packet = new Packet(registry, PacketType.NotifyClient);
+        try (Packet.Writer out = packet.overwrite()) {
+            out.writeByte(action.ordinal());
+            out.writeFloat(value);
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketPlayerListEntry.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketPlayerListEntry.java
new file mode 100644
index 0000000000000000000000000000000000000000..67c1364acdabe9a75de8c6f7b63664a13259ac4d
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketPlayerListEntry.java
@@ -0,0 +1,418 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.data.StringOrNbtText;
+import com.replaymod.replaystudio.util.Property;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.EnumSet;
+import java.util.List;
+import java.util.Set;
+import java.util.UUID;
+
+public class PacketPlayerListEntry {
+    public enum Action {
+        ADD,
+        CHAT_KEY, // 1.19.3+
+        GAMEMODE, // 1.8+
+        LISTED, // 1.19.3+
+        LATENCY, // 1.8+
+        DISPLAY_NAME, // 1.8+
+        REMOVE,
+        ;
+
+        private static final List<Action> VALUES_1_19_3 = Arrays.asList(ADD, CHAT_KEY, GAMEMODE, LISTED, LATENCY, DISPLAY_NAME);
+        private static final List<Action> VALUES_1_8 = Arrays.asList(ADD, GAMEMODE, LATENCY, DISPLAY_NAME, REMOVE);
+        private static final List<Action> VALUES_1_7 = Arrays.asList(ADD, REMOVE);
+
+        public static Set<Action> init(PacketTypeRegistry registry) {
+            if (registry.atLeast(ProtocolVersion.v1_19_3)) {
+                return EnumSet.copyOf(VALUES_1_19_3);
+            } else {
+                return EnumSet.of(ADD);
+            }
+        }
+
+        public static List<Action> values(PacketTypeRegistry registry) {
+            if (registry.atLeast(ProtocolVersion.v1_19_3)) {
+                return VALUES_1_19_3;
+            } else if (registry.atLeast(ProtocolVersion.v1_8)) {
+                return VALUES_1_8;
+            } else {
+                return VALUES_1_7;
+            }
+        }
+
+        // 1.19.3+
+        public static EnumSet<Action> readSet(Packet.Reader in, List<Action> values) throws IOException {
+            BitSet bitSet = BitSet.valueOf(in.readBytes((values.size() + 7) / 8));
+            EnumSet<Action> set = EnumSet.noneOf(Action.class);
+            for (int i = 0; i < values.size(); i++) {
+                if (bitSet.get(i)) {
+                    set.add(values.get(i));
+                }
+            }
+            return set;
+        }
+
+        // 1.19.3+
+        public static void writeSet(Packet.Writer out, Set<Action> actions, List<Action> values) throws IOException {
+            BitSet bitSet = new BitSet();
+            for (int i = 0; i < values.size(); i++) {
+                if (actions.contains(values.get(i))) {
+                    bitSet.set(i);
+                }
+            }
+            out.writeBytes(Arrays.copyOf(bitSet.toByteArray(), (values.size() + 7) / 8));
+        }
+    }
+
+    private UUID uuid; // any action (1.8+)
+    private String name; // only in ADD (or 1.7.10 REMOVE)
+    private List<Property> properties; // only in ADD (1.8+)
+    private StringOrNbtText displayName; // ADD (pre 1.19.3) or DISPLAY_NAME, nullable (1.8+)
+    private int gamemode; // ADD (pre 1.19.3) or GAMEMODE (1.8+)
+    private boolean listed; // LISTED (1.19.3+)
+    private int latency; // ADD (pre 1.19.3) or latency
+    private SigData sigData; // ADD (1.19+; pre 1.19.3) or CHAT_KEY (1.19.3+)
+
+    public static PacketPlayerListEntry updateChatKey(PacketPlayerListEntry entry, SigData sigData) {
+        entry = new PacketPlayerListEntry(entry);
+        entry.sigData = sigData;
+        return entry;
+    }
+
+    public static PacketPlayerListEntry updateGamemode(PacketPlayerListEntry entry, int gamemode) {
+        entry = new PacketPlayerListEntry(entry);
+        entry.gamemode = gamemode;
+        return entry;
+    }
+
+    public static PacketPlayerListEntry updateListed(PacketPlayerListEntry entry, boolean listed) {
+        entry = new PacketPlayerListEntry(entry);
+        entry.listed = listed;
+        return entry;
+    }
+
+    public static PacketPlayerListEntry updateLatency(PacketPlayerListEntry entry, int latency) {
+        entry = new PacketPlayerListEntry(entry);
+        entry.latency = latency;
+        return entry;
+    }
+
+    public static PacketPlayerListEntry updateDisplayName(PacketPlayerListEntry entry, StringOrNbtText displayName) {
+        entry = new PacketPlayerListEntry(entry);
+        entry.displayName = displayName;
+        return entry;
+    }
+
+    public static Set<Action> getActions(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                if (packet.getType() == PacketType.PlayerListEntryRemove) {
+                    return Collections.singleton(Action.REMOVE);
+                }
+                return Action.readSet(in, Action.VALUES_1_19_3);
+            } else if (packet.atLeast(ProtocolVersion.v1_8)) {
+                return Collections.singleton(Action.VALUES_1_8.get(in.readVarInt()));
+            } else {
+                in.readString(); // name
+                if (in.readBoolean()) {
+                    return Collections.singleton(Action.ADD);
+                } else {
+                    return Collections.singleton(Action.REMOVE);
+                }
+            }
+        }
+    }
+
+    public static List<PacketPlayerListEntry> read(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                Set<Action> actions;
+                if (packet.getType() == PacketType.PlayerListEntryRemove) {
+                    actions = Collections.singleton(Action.REMOVE);
+                } else if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                    actions = Action.readSet(in, Action.VALUES_1_19_3);
+                } else {
+                    actions = Collections.singleton(Action.VALUES_1_8.get(in.readVarInt()));
+                }
+                int count = in.readVarInt();
+                List<PacketPlayerListEntry> result = new ArrayList<>(count);
+                for (int i = 0; i < count; i++) {
+                    PacketPlayerListEntry entry = new PacketPlayerListEntry();
+                    entry.uuid = in.readUUID();
+                    for (Action action : actions) {
+                        switch (action) {
+                            case ADD:
+                                entry.name = in.readString();
+                                entry.properties = in.readList(() -> Property.read(in));
+                                if (packet.olderThan(ProtocolVersion.v1_19_3)) {
+                                    entry.gamemode = in.readVarInt();
+                                    entry.latency = in.readVarInt();
+                                    if (in.readBoolean()) {
+                                        entry.displayName = in.readText();
+                                    }
+                                    if (packet.atLeast(ProtocolVersion.v1_19)) {
+                                        if (in.readBoolean()) {
+                                            entry.sigData = SigData.read(packet, in);
+                                        }
+                                    }
+                                }
+                                break;
+                            case CHAT_KEY:
+                                if (in.readBoolean()) {
+                                    entry.sigData = SigData.read(packet, in);
+                                }
+                                break;
+                            case GAMEMODE:
+                                entry.gamemode = in.readVarInt();
+                                break;
+                            case LISTED:
+                                entry.listed = in.readBoolean();
+                                break;
+                            case LATENCY:
+                                entry.latency = in.readVarInt();
+                                break;
+                            case DISPLAY_NAME:
+                                if (in.readBoolean()) {
+                                    entry.displayName = in.readText();
+                                }
+                                break;
+                        }
+                    }
+                    result.add(entry);
+                }
+                return result;
+            } else {
+                PacketPlayerListEntry entry = new PacketPlayerListEntry();
+                entry.name = in.readString();
+                in.readBoolean(); // action
+                entry.latency = in.readShort();
+                return Collections.singletonList(entry);
+            }
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, Set<Action> actions, PacketPlayerListEntry entry) throws IOException {
+        return write(registry, actions, Collections.singletonList(entry)).get(0);
+    }
+
+    public static List<Packet> write(PacketTypeRegistry registry, Set<Action> actions, List<PacketPlayerListEntry> entries) throws IOException {
+        if (registry.atLeast(ProtocolVersion.v1_8)) {
+            return Collections.singletonList(write_1_8(registry, actions, entries));
+        } else {
+            List<Packet> packets = new ArrayList<>(entries.size());
+            for (PacketPlayerListEntry it : entries) {
+                packets.add(write_1_7(registry, actions.iterator().next(), it));
+            }
+            return packets;
+        }
+    }
+
+    private static Packet write_1_8(PacketTypeRegistry registry, Set<Action> actions, List<PacketPlayerListEntry> entries) throws IOException {
+        if (registry.atLeast(ProtocolVersion.v1_19_3) && actions.contains(Action.REMOVE)) {
+            Packet packet = new Packet(registry, PacketType.PlayerListEntry);
+            try (Packet.Writer out = packet.overwrite()) {
+                out.writeList(entries, entry -> out.writeUUID(entry.uuid));
+            }
+            return packet;
+        }
+        Packet packet = new Packet(registry, PacketType.PlayerListEntry);
+        try (Packet.Writer out = packet.overwrite()) {
+            if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                Action.writeSet(out, actions, Action.VALUES_1_19_3);
+            } else {
+                out.writeVarInt(Action.VALUES_1_8.indexOf(actions.iterator().next()));
+            }
+            out.writeVarInt(entries.size());
+            for (PacketPlayerListEntry entry : entries) {
+                out.writeUUID(entry.uuid);
+                for (Action action : actions) {
+                    switch (action) {
+                        case ADD:
+                            out.writeString(entry.name);
+                            out.writeList(entry.properties, it -> it.write(out));
+                            if (packet.olderThan(ProtocolVersion.v1_19_3)) {
+                                out.writeVarInt(entry.gamemode);
+                                out.writeVarInt(entry.latency);
+                                if (entry.displayName != null) {
+                                    out.writeBoolean(true);
+                                    out.writeText(entry.displayName);
+                                } else {
+                                    out.writeBoolean(false);
+                                }
+                                if (packet.atLeast(ProtocolVersion.v1_19)) {
+                                    if (entry.sigData != null) {
+                                        out.writeBoolean(true);
+                                        entry.sigData.write(packet, out);
+                                    } else {
+                                        out.writeBoolean(false);
+                                    }
+                                }
+                            }
+                            break;
+                        case CHAT_KEY:
+                            if (entry.sigData != null) {
+                                out.writeBoolean(true);
+                                entry.sigData.write(packet, out);
+                            } else {
+                                out.writeBoolean(false);
+                            }
+                            break;
+                        case GAMEMODE:
+                            out.writeVarInt(entry.gamemode);
+                            break;
+                        case LISTED:
+                            out.writeBoolean(entry.listed);
+                            break;
+                        case LATENCY:
+                            out.writeVarInt(entry.latency);
+                            break;
+                        case DISPLAY_NAME:
+                            if (entry.displayName != null) {
+                                out.writeBoolean(true);
+                                out.writeText(entry.displayName);
+                            } else {
+                                out.writeBoolean(false);
+                            }
+                            break;
+                    }
+                }
+            }
+        }
+        return packet;
+    }
+
+    private static Packet write_1_7(PacketTypeRegistry registry, Action action, PacketPlayerListEntry entry) throws IOException {
+        Packet packet = new Packet(registry, PacketType.PlayerListEntry);
+        try (Packet.Writer out = packet.overwrite()) {
+            out.writeString(entry.name);
+            if (action == Action.ADD) {
+                out.writeBoolean(true);
+            } else if (action == Action.REMOVE) {
+                out.writeBoolean(false);
+            } else {
+                throw new IllegalStateException("1.7 only supports ADD or REMOVE");
+            }
+            out.writeShort(entry.latency);
+        }
+        return packet;
+    }
+
+    private PacketPlayerListEntry() {}
+    private PacketPlayerListEntry(PacketPlayerListEntry from) {
+        this.uuid = from.uuid;
+        this.name = from.name;
+        this.properties = from.properties;
+        this.displayName = from.displayName;
+        this.gamemode = from.gamemode;
+        this.listed = from.listed;
+        this.latency = from.latency;
+        this.sigData = from.sigData;
+    }
+
+    public UUID getUuid() {
+        return uuid;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public List<Property> getProperties() {
+        return properties;
+    }
+
+    public StringOrNbtText getDisplayName() {
+        return displayName;
+    }
+
+    public int getGamemode() {
+        return gamemode;
+    }
+
+    public boolean isListed() {
+        return listed;
+    }
+
+    public int getLatency() {
+        return latency;
+    }
+
+    public SigData getSigData() {
+        return sigData;
+    }
+
+    /**
+     * Returns the key identifying the player which this packet relates to.
+     * In 1.8+ that is the UUID, in 1.7 it's the name.
+     * @see PacketSpawnPlayer#getPlayerListEntryId(Packet)
+     */
+    public String getId() {
+        return uuid != null ? uuid.toString() : name;
+    }
+
+    public static class SigData {
+        private final UUID sessionUuid; // 1.19.3+
+        private final long expireTimestamp;
+        private final byte[] publicKey;
+        private final byte[] signature;
+
+        public SigData(UUID sessionUuid, long expireTimestamp, byte[] publicKey, byte[] signature) {
+            this.sessionUuid = sessionUuid;
+            this.expireTimestamp = expireTimestamp;
+            this.publicKey = publicKey;
+            this.signature = signature;
+        }
+
+        public static SigData read(Packet packet, Packet.Reader in) throws IOException {
+            UUID sessionUuid;
+            if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                sessionUuid = in.readUUID();
+            } else {
+                sessionUuid = null;
+            }
+            long expireTimestamp = in.readLong();
+            byte[] publicKey = in.readBytes(in.readVarInt());
+            byte[] signature = in.readBytes(in.readVarInt());
+            return new SigData(sessionUuid, expireTimestamp, publicKey, signature);
+        }
+
+        public void write(Packet packet, Packet.Writer out) throws IOException {
+            if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                out.writeUUID(sessionUuid);
+            }
+            out.writeLong(expireTimestamp);
+            out.writeVarInt(publicKey.length);
+            out.writeBytes(publicKey);
+            out.writeVarInt(signature.length);
+            out.writeBytes(signature);
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketRespawn.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketRespawn.java
new file mode 100644
index 0000000000000000000000000000000000000000..ec13b1a39b4317de096b2a2c4217a1f03c266aaa
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketRespawn.java
@@ -0,0 +1,171 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.protocol.registry.DimensionType;
+import com.replaymod.replaystudio.util.IGlobalPosition;
+
+import java.io.IOException;
+
+import static com.replaymod.replaystudio.protocol.packets.PacketJoinGame.getDimensionType;
+
+public class PacketRespawn {
+    public byte gameMode;
+    public byte prevGameMode; // 1.16+
+    public DimensionType dimensionType;
+    public String dimension;
+    public long seed; // 1.15+
+    public int difficulty; // pre 1.14
+    public boolean debugWorld; // 1.16+
+    public boolean flatWorld; // 1.16+
+    public boolean keepPlayerAttributes; // 1.16+
+    public boolean keepPlayerDataTracker; // 1.19.3+
+    public IGlobalPosition lastDeathPosition; // 1.19+
+    public int portalCooldown; // 1.20+
+
+    public static PacketRespawn read(Packet packet, CompoundTag registries) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            PacketRespawn respawn = new PacketRespawn();
+            respawn.read(packet, in, registries);
+            return respawn;
+        }
+    }
+
+    public void read(Packet packet, Packet.Reader in, CompoundTag registries) throws IOException {
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            if (packet.atLeast(ProtocolVersion.v1_19)) {
+                this.dimensionType = getDimensionType(registries, in.readString());
+            } else if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                this.dimensionType = new DimensionType(in.readNBT());
+            } else {
+                this.dimensionType = new DimensionType(in.readString());
+            }
+            this.dimension = in.readString();
+        } else {
+            this.dimension = String.valueOf(in.readInt());
+        }
+        if (packet.atLeast(ProtocolVersion.v1_15)) {
+            this.seed = in.readLong();
+        }
+        if (packet.olderThan(ProtocolVersion.v1_14)) {
+            this.difficulty = in.readByte();
+        }
+        this.gameMode = in.readByte();
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            this.prevGameMode = in.readByte();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            this.debugWorld = in.readBoolean();
+            this.flatWorld = in.readBoolean();
+            if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+                // Now at the end of the packet
+            } else if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                int flags = in.readByte();
+                this.keepPlayerAttributes = (flags & 0x01) != 0;
+                this.keepPlayerDataTracker = (flags & 0x02) != 0;
+            } else {
+                this.keepPlayerAttributes = in.readBoolean();
+            }
+        } else {
+            this.dimensionType = new DimensionType(in.readString());
+        }
+        if (packet.atLeast(ProtocolVersion.v1_19)) {
+            if (in.readBoolean()) {
+                this.lastDeathPosition = in.readGlobalPosition();
+            }
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20)) {
+            this.portalCooldown = in.readVarInt();
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+            int flags = in.readByte();
+            this.keepPlayerAttributes = (flags & 0x01) != 0;
+            this.keepPlayerDataTracker = (flags & 0x02) != 0;
+        }
+    }
+
+    public Packet write(PacketTypeRegistry registry) throws IOException {
+        Packet packet = new Packet(registry, PacketType.Respawn);
+        try (Packet.Writer out = packet.overwrite()) {
+            write(packet, out);
+        }
+        return packet;
+    }
+
+    public void write(Packet packet, Packet.Writer out) throws IOException {
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            if (packet.atLeast(ProtocolVersion.v1_19)) {
+                out.writeString(this.dimensionType.getName());
+            } else if (packet.atLeast(ProtocolVersion.v1_16_2)) {
+                out.writeNBT(this.dimensionType.getTag());
+            } else {
+                out.writeString(this.dimensionType.getName());
+            }
+            out.writeString(this.dimension);
+        } else {
+            out.writeInt(Integer.parseInt(this.dimension));
+        }
+        if (packet.atLeast(ProtocolVersion.v1_15)) {
+            out.writeLong(this.seed);
+        }
+        if (packet.olderThan(ProtocolVersion.v1_14)) {
+            out.writeByte(this.difficulty);
+        }
+        out.writeByte(this.gameMode);
+        if (packet.atLeast(ProtocolVersion.v1_16)) {
+            out.writeByte(this.prevGameMode);
+            out.writeBoolean(this.debugWorld);
+            out.writeBoolean(this.flatWorld);
+            if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+                // Now at the end of the packet
+            } else if (packet.atLeast(ProtocolVersion.v1_19_3)) {
+                int flags = 0;
+                if (this.keepPlayerAttributes) flags |= 0x01;
+                if (this.keepPlayerDataTracker) flags |= 0x02;
+                out.writeByte(flags);
+            } else {
+                out.writeBoolean(this.keepPlayerAttributes);
+            }
+        } else {
+            out.writeString(this.dimensionType.getName());
+        }
+        if (packet.atLeast(ProtocolVersion.v1_19)) {
+            if (this.lastDeathPosition != null) {
+                out.writeBoolean(true);
+                out.writeGlobalPosition(this.lastDeathPosition);
+            } else {
+                out.writeBoolean(false);
+            }
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20)) {
+            out.writeVarInt(this.portalCooldown);
+        }
+        if (packet.atLeast(ProtocolVersion.v1_20_2)) {
+            int flags = 0;
+            if (this.keepPlayerAttributes) flags |= 0x01;
+            if (this.keepPlayerDataTracker) flags |= 0x02;
+            out.writeByte(flags);
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketSetSlot.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketSetSlot.java
new file mode 100644
index 0000000000000000000000000000000000000000..33aed97573177d3aadb3a9c5308a8bf4b7327cc4
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketSetSlot.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+
+public class PacketSetSlot {
+    public static int getWindowId(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readUnsignedByte();
+        }
+    }
+
+    public static int getSlot(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            in.readUnsignedByte(); // window id
+            if (packet.atLeast(ProtocolVersion.v1_17_1)) {
+                in.readVarInt(); // revision
+            }
+            return in.readShort();
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketSpawnPlayer.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketSpawnPlayer.java
new file mode 100644
index 0000000000000000000000000000000000000000..e48df25dbcc90f357e4ea0c0c8960eecc138bd09
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketSpawnPlayer.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+import java.io.IOException;
+
+public class PacketSpawnPlayer extends SpawnEntity {
+    /**
+     * @see PacketPlayerListEntry#getId()
+     */
+    public static String getPlayerListEntryId(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            in.readVarInt(); // id
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                return in.readUUID().toString(); // uuid
+            } else {
+                in.readString(); // uuid
+                return in.readString(); // name
+            }
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketTeam.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketTeam.java
new file mode 100644
index 0000000000000000000000000000000000000000..2ead4abee15c4d97b2375d26ff214d4bd7bacfe0
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketTeam.java
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.List;
+
+public class PacketTeam {
+    public enum Action {
+        CREATE,
+        REMOVE,
+        UPDATE,
+        ADD_PLAYER,
+        REMOVE_PLAYER,
+    }
+
+    public static String getName(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readString();
+        }
+    }
+
+    public static Action getAction(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            in.readString(); // name
+            return Action.values()[in.readByte()];
+        }
+    }
+
+    public static List<String> getPlayers(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            in.readString(); // name
+            Action action = Action.values()[in.readByte()];
+            if (action != Action.CREATE && action != Action.ADD_PLAYER && action != Action.REMOVE_PLAYER) {
+                return Collections.emptyList();
+            }
+
+            if (action == Action.CREATE) {
+                in.readText(); // display name
+                if (!packet.atLeast(ProtocolVersion.v1_13)) {
+                    in.readString(); // prefix
+                    in.readString(); // suffix
+                }
+                in.readByte(); // flags
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    in.readString(); // name tag visibility
+                    if (packet.atLeast(ProtocolVersion.v1_9)) {
+                        in.readString(); // collision rule
+                    }
+                    if (packet.atLeast(ProtocolVersion.v1_13)) {
+                        in.readVarInt(); // color
+                        in.readText(); // prefix
+                        in.readText(); // suffix
+                    } else {
+                        in.readByte(); // color
+                    }
+                }
+            }
+
+            int count;
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                count = in.readVarInt();
+            } else {
+                count = in.readShort();
+            }
+            List<String> result = new ArrayList<>(count);
+            for (int i = 0; i < count; i++) {
+                result.add(in.readString());
+            }
+            return result;
+        }
+    }
+
+    public static Packet addPlayers(PacketTypeRegistry registry, String name, Collection<String> players) throws IOException {
+        return addOrRemovePlayers(registry, name, Action.ADD_PLAYER, players);
+    }
+
+    public static Packet removePlayers(PacketTypeRegistry registry, String name, Collection<String> players) throws IOException {
+        return addOrRemovePlayers(registry, name, Action.REMOVE_PLAYER, players);
+    }
+
+    private static Packet addOrRemovePlayers(PacketTypeRegistry registry, String name, Action action, Collection<String> players) throws IOException {
+        Packet packet = new Packet(registry, PacketType.Team);
+        try (Packet.Writer out = packet.overwrite()) {
+            out.writeString(name);
+            out.writeByte(action.ordinal());
+            if (packet.atLeast(ProtocolVersion.v1_8)) {
+                out.writeVarInt(players.size());
+            } else {
+                out.writeShort(players.size());
+            }
+            for (String player : players) {
+                out.writeString(player);
+            }
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateLight.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateLight.java
new file mode 100644
index 0000000000000000000000000000000000000000..826bd851879dd860a681030560c8052c7c0914bc
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateLight.java
@@ -0,0 +1,230 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.List;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+public class PacketUpdateLight {
+    @SuppressWarnings("MismatchedReadAndWriteOfArray") // it's supposed to be empty. duh.
+    private static final byte[] EMPTY = new byte[2048];
+    private int x;
+    private int z;
+    private Data data;
+
+    public static PacketUpdateLight read(Packet packet) throws IOException {
+        if (packet.getType() != PacketType.UpdateLight) {
+            throw new IllegalArgumentException("Can only read packets of type UpdateLight.");
+        }
+        PacketUpdateLight updateLight = new PacketUpdateLight();
+        try (Packet.Reader reader = packet.reader()) {
+            updateLight.read(packet, reader);
+        }
+        return updateLight;
+    }
+
+    public Packet write(PacketTypeRegistry registry) throws IOException {
+        Packet packet = new Packet(registry, PacketType.UpdateLight);
+        try (Packet.Writer writer = packet.overwrite()) {
+            write(packet, writer);
+        }
+        return packet;
+    }
+
+    private PacketUpdateLight() {
+    }
+
+    public PacketUpdateLight(int x, int z, List<byte[]> skyLight, List<byte[]> blockLight) {
+        this(x, z, new Data(skyLight, blockLight));
+    }
+
+    public PacketUpdateLight(int x, int z, Data data) {
+        this.x = x;
+        this.z = z;
+        this.data = data;
+    }
+
+    public int getX() {
+        return this.x;
+    }
+
+    public int getZ() {
+        return this.z;
+    }
+
+    public Data getData() {
+        return this.data;
+    }
+
+    public List<byte[]> getSkyLight() {
+        return this.data.skyLight;
+    }
+
+    public List<byte[]> getBlockLight() {
+        return this.data.blockLight;
+    }
+
+    private void read(Packet packet, Packet.Reader in) throws IOException {
+        this.x = in.readVarInt();
+        this.z = in.readVarInt();
+        this.data = readData(packet, in);
+    }
+
+    static Data readData(Packet packet, Packet.Reader in) throws IOException {
+        Data data = new Data();
+
+        if (packet.atLeast(ProtocolVersion.v1_16) && packet.olderThan(ProtocolVersion.v1_20)) {
+            in.readBoolean(); // unknown
+        }
+
+        BitSet skyLightMask = in.readBitSet();
+        BitSet blockLightMask = in.readBitSet();
+        BitSet emptySkyLightMask = in.readBitSet();
+        BitSet emptyBlockLightMask = in.readBitSet();
+
+        int skySections = Math.max(skyLightMask.length(), emptySkyLightMask.length());
+        int blockSections = Math.max(blockLightMask.length(), emptyBlockLightMask.length());
+
+        if (packet.atLeast(ProtocolVersion.v1_17)) {
+            int skyLightsSent = in.readVarInt();
+            if (skyLightMask.cardinality() != skyLightsSent) {
+                throw new IOException("Expected " + skyLightMask.cardinality() + " sky light sections but got " + skyLightsSent);
+            }
+        }
+        data.skyLight = new ArrayList<>(skySections);
+        for (int i = 0; i < skySections; i++) {
+            if (skyLightMask.get(i)) {
+                if (in.readVarInt() != 2048) {
+                    throw new IOException("Expected sky light byte array to be of length 2048");
+                }
+                data.skyLight.add(in.readBytes(2048)); // 2048 bytes read = 4096 entries
+            } else if (emptySkyLightMask.get(i)) {
+                data.skyLight.add(new byte[2048]);
+            } else {
+                data.skyLight.add(null);
+            }
+        }
+
+        if (packet.atLeast(ProtocolVersion.v1_17)) {
+            int blockLightsSent = in.readVarInt();
+            if (blockLightMask.cardinality() != blockLightsSent) {
+                throw new IOException("Expected " + blockLightMask.cardinality() + " block light sections but got " + blockLightsSent);
+            }
+        }
+        data.blockLight = new ArrayList<>(blockSections);
+        for (int i = 0; i < blockSections; i++) {
+            if (blockLightMask.get(i)) {
+                if (in.readVarInt() != 2048) {
+                    throw new IOException("Expected block light byte array to be of length 2048");
+                }
+                data.blockLight.add(in.readBytes(2048)); // 2048 bytes read = 4096 entries
+            } else if (emptyBlockLightMask.get(i)) {
+                data.blockLight.add(new byte[2048]);
+            } else {
+                data.blockLight.add(null);
+            }
+        }
+
+        return data;
+    }
+
+    private void write(Packet packet, Packet.Writer out) throws IOException {
+        out.writeVarInt(this.x);
+        out.writeVarInt(this.z);
+        writeData(packet, out, this.data);
+    }
+
+    static void writeData(Packet packet, Packet.Writer out, Data data) throws IOException {
+        if (packet.atLeast(ProtocolVersion.v1_16) && packet.olderThan(ProtocolVersion.v1_20)) {
+            out.writeBoolean(true); // unknown, ViaVersion always writes true, so we'll do so as well
+        }
+
+        BitSet skyLightMask = new BitSet();
+        BitSet blockLightMask = new BitSet();
+        BitSet emptySkyLightMask = new BitSet();
+        BitSet emptyBlockLightMask = new BitSet();
+        List<byte[]> skyLights = new ArrayList<>();
+        List<byte[]> blockLights = new ArrayList<>();
+
+        for (int i = 0; i < data.skyLight.size(); i++) {
+            byte[] skyLight = data.skyLight.get(i);
+            if (skyLight != null) {
+                if (Arrays.equals(EMPTY, skyLight)) {
+                    emptySkyLightMask.set(i);
+                } else {
+                    skyLightMask.set(i);
+                    skyLights.add(skyLight);
+                }
+            }
+        }
+        for (int i = 0; i < data.blockLight.size(); i++) {
+            byte[] blockLight = data.blockLight.get(i);
+            if (blockLight != null) {
+                if (Arrays.equals(EMPTY, blockLight)) {
+                    emptyBlockLightMask.set(i);
+                } else {
+                    blockLightMask.set(i);
+                    blockLights.add(blockLight);
+                }
+            }
+        }
+
+        out.writeBitSet(skyLightMask);
+        out.writeBitSet(blockLightMask);
+        out.writeBitSet(emptySkyLightMask);
+        out.writeBitSet(emptyBlockLightMask);
+
+        if (packet.atLeast(ProtocolVersion.v1_17)) {
+            out.writeVarInt(skyLights.size()); // dunno why Minecraft feels the need to send these
+        }
+        for (byte[] bytes : skyLights) {
+            out.writeVarInt(2048); // dunno why Minecraft feels the need to send these
+            out.writeBytes(bytes);
+        }
+
+        if (packet.atLeast(ProtocolVersion.v1_17)) {
+            out.writeVarInt(blockLights.size()); // dunno why Minecraft feels the need to send these
+        }
+        for (byte[] bytes : blockLights) {
+            out.writeVarInt(2048); // dunno why Minecraft feels the need to send these
+            out.writeBytes(bytes);
+        }
+    }
+
+    public static class Data {
+        public List<byte[]> skyLight;
+        public List<byte[]> blockLight;
+
+        public Data() {
+        }
+
+        public Data(List<byte[]> skyLight, List<byte[]> blockLight) {
+            this.skyLight = skyLight;
+            this.blockLight = blockLight;
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateSimulationDistance.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateSimulationDistance.java
new file mode 100644
index 0000000000000000000000000000000000000000..633b6b706c2cd759b80b139b178970ca698b2379
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateSimulationDistance.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import java.io.IOException;
+
+public class PacketUpdateSimulationDistance {
+    public static int getDistance(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readVarInt();
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int distance) throws IOException {
+        Packet packet = new Packet(registry, PacketType.UpdateSimulationDistance);
+        try (Packet.Writer out = packet.overwrite()) {
+            out.writeVarInt(distance);
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateViewDistance.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateViewDistance.java
new file mode 100644
index 0000000000000000000000000000000000000000..5eaf49527abe9346dc21b473c84ec324c1458f0c
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateViewDistance.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import java.io.IOException;
+
+public class PacketUpdateViewDistance {
+    public static int getDistance(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readVarInt();
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int distance) throws IOException {
+        Packet packet = new Packet(registry, PacketType.UpdateViewDistance);
+        try (Packet.Writer out = packet.overwrite()) {
+            out.writeVarInt(distance);
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateViewPosition.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateViewPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..0d3ff2762a3d8d6940771075b27b2843e0ddbb7b
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketUpdateViewPosition.java
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import java.io.IOException;
+
+public class PacketUpdateViewPosition {
+    public static int getChunkX(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readVarInt();
+        }
+    }
+
+    public static int getChunkZ(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            in.readVarInt();
+            return in.readVarInt();
+        }
+    }
+
+    public static Packet write(PacketTypeRegistry registry, int chunkX, int chunkZ) throws IOException {
+        Packet packet = new Packet(registry, PacketType.UpdateViewPosition);
+        try (Packet.Writer out = packet.overwrite()) {
+            out.writeVarInt(chunkX);
+            out.writeVarInt(chunkZ);
+        }
+        return packet;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketWindowItems.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketWindowItems.java
new file mode 100644
index 0000000000000000000000000000000000000000..2e7f377065aec5d9d68c01a18dda834c187a9bac
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/PacketWindowItems.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+
+public class PacketWindowItems {
+    public static int getWindowId(Packet packet) throws IOException {
+        try (Packet.Reader in = packet.reader()) {
+            return in.readUnsignedByte();
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/packets/SpawnEntity.java b/src/main/java/com/replaymod/replaystudio/protocol/packets/SpawnEntity.java
new file mode 100644
index 0000000000000000000000000000000000000000..7acf1c55a45c44a6f59bf20d642f97e9e91cb725
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/packets/SpawnEntity.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.protocol.packets;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketType;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.replaymod.replaystudio.util.IPosition;
+import com.replaymod.replaystudio.util.Location;
+
+import java.io.IOException;
+
+public class SpawnEntity {
+    public static Location getLocation(Packet packet) throws IOException {
+        PacketType type = packet.getType();
+        switch (type) {
+            case SpawnExpOrb: try (Packet.Reader in = packet.reader()) {
+                in.readVarInt(); // id
+                if (packet.atLeast(ProtocolVersion.v1_9)) {
+                    return new Location(in.readDouble(), in.readDouble(), in.readDouble(), 0, 0);
+                } else {
+                    return new Location(in.readInt() / 32.0, in.readInt() / 32.0, in.readInt() / 32.0, 0, 0);
+                }
+            }
+            case SpawnObject:
+            case SpawnMob: try (Packet.Reader in = packet.reader()) {
+                in.readVarInt(); // id
+                if (packet.atLeast(ProtocolVersion.v1_9)) {
+                    in.readUUID(); // uuid
+                }
+                if (packet.atLeast(ProtocolVersion.v1_11)) {
+                    in.readVarInt(); // type
+                } else {
+                    in.readUnsignedByte(); // type
+                }
+                return readXYZYaPi(packet, in, type == PacketType.SpawnObject);
+            }
+            case SpawnPlayer: try (Packet.Reader in = packet.reader()) {
+                in.readVarInt(); // id
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    in.readUUID(); // uuid
+                } else {
+                    in.readString(); // uuid
+                    in.readString(); // name
+                    int properties = in.readVarInt();
+                    for (int i = 0; i < properties; i++) {
+                        in.readString(); // name
+                        in.readString(); // value
+                        in.readString(); // signature
+                    }
+                }
+                return readXYZYaPi(packet, in, false);
+            }
+            case SpawnPainting: try (Packet.Reader in = packet.reader()) {
+                in.readVarInt(); // id
+                if (packet.atLeast(ProtocolVersion.v1_9)) {
+                    in.readUUID(); // uuid
+                }
+                if (packet.atLeast(ProtocolVersion.v1_13)) {
+                    in.readVarInt(); // type
+                } else {
+                    in.readString(); // type
+                }
+                if (packet.atLeast(ProtocolVersion.v1_8)) {
+                    IPosition pos = in.readPosition();
+                    return new Location(pos.getX(), pos.getY(), pos.getZ(), 0 , 0);
+                } else {
+                    return new Location(in.readInt(), in.readInt(), in.readInt(), 0, 0);
+                }
+            }
+            default:
+                return null;
+        }
+    }
+
+    static Location readXYZYaPi(Packet packet, Packet.Reader in, boolean flippedYawPitch) throws IOException {
+        double x, y, z;
+        if (packet.atLeast(ProtocolVersion.v1_9)) {
+            x = in.readDouble();
+            y = in.readDouble();
+            z = in.readDouble();
+        } else {
+            x = in.readInt() / 32.0;
+            y = in.readInt() / 32.0;
+            z = in.readInt() / 32.0;
+        }
+        float yaw = in.readByte() / 256f * 360;
+        float pitch = in.readByte() / 256f * 360;
+        if (flippedYawPitch) {
+            float tmp = pitch;
+            pitch = yaw;
+            yaw = tmp;
+        }
+        return new Location(x, y, z, yaw, pitch);
+    }
+
+    static void writeXYZYaPi(Packet packet, Packet.Writer out, Location loc) throws IOException {
+        if (packet.atLeast(ProtocolVersion.v1_9)) {
+            out.writeDouble(loc.getX());
+            out.writeDouble(loc.getY());
+            out.writeDouble(loc.getZ());
+        } else {
+            out.writeInt((int) (loc.getX() * 32));
+            out.writeInt((int) (loc.getY() * 32));
+            out.writeInt((int) (loc.getZ() * 32));
+        }
+        out.writeByte((int) (loc.getYaw() / 360 * 256));
+        out.writeByte((int) (loc.getPitch() / 360 * 256));
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/registry/DimensionType.java b/src/main/java/com/replaymod/replaystudio/protocol/registry/DimensionType.java
new file mode 100644
index 0000000000000000000000000000000000000000..02471a1e8c3b5b49ecd4e7f6bdca5158722457bf
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/registry/DimensionType.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.protocol.registry;
+
+import com.github.steveice10.opennbt.tag.builtin.CompoundTag;
+import com.github.steveice10.opennbt.tag.builtin.NumberTag;
+import com.github.steveice10.opennbt.tag.builtin.Tag;
+
+import java.util.Objects;
+
+public class DimensionType {
+    private final CompoundTag tag;
+    private final String name;
+    private final int minY;
+    private final int height;
+
+    // pre 1.16.2
+    public DimensionType(String name) {
+        this(new CompoundTag(), name);
+    }
+
+    // 1.16.2+ pre 1.19
+    public DimensionType(CompoundTag tag) {
+        this(tag, "");
+    }
+
+    // 1.19+ (and internally all versions)
+    public DimensionType(CompoundTag tag, String name) {
+        this.tag = tag;
+        this.name = name;
+
+        Tag minY = tag.get("min_y");
+        this.minY = minY instanceof NumberTag ? ((NumberTag) minY).asInt() : 0;
+        Tag height = tag.get("height");
+        this.height = height instanceof NumberTag ? ((NumberTag) height).asInt() : 256;
+    }
+
+    // pre 1.16.2 and 1.19+
+    public String getName() {
+        return this.name;
+    }
+
+    // 1.16.2+
+    public CompoundTag getTag() {
+        return this.tag;
+    }
+
+    public int getMinY() {
+        return this.minY;
+    }
+
+    public int getMinSectionY() {
+        return this.minY >> 4;
+    }
+
+    public int getHeight() {
+        return this.height;
+    }
+
+    public int getSections() {
+        return this.height >> 4;
+    }
+
+    public int sectionYToIndex(int sectionY) {
+        return sectionY - this.getMinSectionY();
+    }
+
+    public int indexToSectionY(int index) {
+        return index + this.getMinSectionY();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        DimensionType that = (DimensionType) o;
+        return tag.equals(that.tag) && name.equals(that.name);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(tag, name);
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/ByteBufExtNetInput.java b/src/main/java/com/replaymod/replaystudio/protocol/util/ByteBufExtNetInput.java
new file mode 100644
index 0000000000000000000000000000000000000000..883e3abab9c81646555a2b54902b78435ee02380
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/ByteBufExtNetInput.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.util;
+
+import io.netty.buffer.ByteBuf;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetInput;
+
+public class ByteBufExtNetInput extends ByteBufNetInput {
+    private final ByteBuf buf;
+
+    public ByteBufExtNetInput(ByteBuf buf) {
+        super(buf);
+
+        this.buf = buf;
+    }
+
+    public ByteBuf getBuf() {
+        return buf;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/ByteBufExtNetOutput.java b/src/main/java/com/replaymod/replaystudio/protocol/util/ByteBufExtNetOutput.java
new file mode 100644
index 0000000000000000000000000000000000000000..716d27d302204226718a33e78dd5110220eac786
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/ByteBufExtNetOutput.java
@@ -0,0 +1,37 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.util;
+
+import io.netty.buffer.ByteBuf;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetOutput;
+
+public class ByteBufExtNetOutput extends ByteBufNetOutput {
+    private final ByteBuf buf;
+
+    public ByteBufExtNetOutput(ByteBuf buf) {
+        super(buf);
+
+        this.buf = buf;
+    }
+
+    public ByteBuf getBuf() {
+        return buf;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/DPosition.java b/src/main/java/com/replaymod/replaystudio/protocol/util/DPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..424226e64ac1511797af1ce7d99c152d2482e64a
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/DPosition.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+/**
+ * Position with double precision.
+ */
+public class DPosition {
+
+    public static final DPosition NULL = new DPosition(0, 0, 0);
+
+    private final double x, y, z;
+
+    public DPosition(double x, double y, double z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public double getX() {
+        return this.x;
+    }
+
+    public double getY() {
+        return this.y;
+    }
+
+    public double getZ() {
+        return this.z;
+    }
+
+    public boolean equals(Object o) {
+        if (o == this) return true;
+        if (!(o instanceof DPosition)) return false;
+        final DPosition other = (DPosition) o;
+        if (!other.canEqual(this)) return false;
+        if (Double.compare(this.x, other.x) != 0) return false;
+        if (Double.compare(this.y, other.y) != 0) return false;
+        if (Double.compare(this.z, other.z) != 0) return false;
+        return true;
+    }
+
+    public int hashCode() {
+        int result = 1;
+        final long x = Double.doubleToLongBits(this.x);
+        result = result * 59 + (int) (x >>> 32 ^ x);
+        final long y = Double.doubleToLongBits(this.y);
+        result = result * 59 + (int) (y >>> 32 ^ y);
+        final long z = Double.doubleToLongBits(this.z);
+        result = result * 59 + (int) (z >>> 32 ^ z);
+        return result;
+    }
+
+    protected boolean canEqual(Object other) {
+        return other instanceof DPosition;
+    }
+
+    public String toString() {
+        return "DPosition(x=" + this.x + ", y=" + this.y + ", z=" + this.z + ")";
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/EntityPositionTracker.java b/src/main/java/com/replaymod/replaystudio/protocol/util/EntityPositionTracker.java
new file mode 100644
index 0000000000000000000000000000000000000000..86ec49763e8422da172c44407dd9ad6d921885c5
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/EntityPositionTracker.java
@@ -0,0 +1,224 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import com.github.steveice10.packetlib.io.NetInput;
+import com.github.steveice10.packetlib.io.NetOutput;
+import com.github.steveice10.packetlib.io.stream.StreamNetInput;
+import com.github.steveice10.packetlib.io.stream.StreamNetOutput;
+import com.google.common.base.Optional;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.io.ReplayInputStream;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+import com.replaymod.replaystudio.replay.ReplayFile;
+import com.replaymod.replaystudio.replay.ReplayMetaData;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.NavigableMap;
+import java.util.TreeMap;
+import java.util.function.Consumer;
+
+/**
+ * An EntityPositionTracker knows every entity's position at any timestamp for a single Replay.
+ * To do so, it once reads the whole Replay and stores all packets that set or change an entity's position into memory.<br>
+ *     <br>
+ * While this significantly increases the Replay loading time, it's the only way to:<br>
+ *     1) Properly preview the Camera Path when an Entity is spectated<br>
+ *     2) Calculate a smooth Path from an Entity's Shoulder Cam perspective<br>
+ * Instances of this class should therefore only be initialized when needed.
+ * Results are also cached in the Replay file.<br>
+ * <br>
+ * This class is thread-safe. As such, it will synchronize on the ReplayFile object when using it.
+ */
+public class EntityPositionTracker {
+    private static final String CACHE_ENTRY = "entity_positions.bin";
+    private static final String OLD_CACHE_ENTRY = "entity_positions.json";
+
+    private final ReplayFile replayFile;
+
+    private volatile Map<Integer, NavigableMap<Long, Location>> entityPositions;
+
+    public EntityPositionTracker(ReplayFile replayFile) {
+        this.replayFile = replayFile;
+    }
+
+    /**
+     * Load the entity positions either from cache or from the packet data.
+     * @param progressMonitor Called with the current progress [0, 1] or not at all
+     * @throws IOException if an i/o error occurs
+     */
+    public void load(Consumer<Double> progressMonitor) throws IOException {
+        Optional<InputStream> cached;
+        synchronized (replayFile) {
+            Optional<InputStream> oldCache = replayFile.get(OLD_CACHE_ENTRY);
+            if (oldCache.isPresent()) {
+                oldCache.get().close();
+                replayFile.remove(OLD_CACHE_ENTRY);
+            }
+            cached = replayFile.getCache(CACHE_ENTRY);
+        }
+        if (cached.isPresent()) {
+            try (InputStream in = cached.get()) {
+                loadFromCache(in);
+            } catch (EOFException e) {
+                // Cache contains insufficient data, probably due to a previous crash / full disk
+                loadFromPacketData(progressMonitor);
+                synchronized (replayFile) {
+                    replayFile.removeCache(CACHE_ENTRY);
+                }
+                saveToCache();
+            }
+        } else {
+            loadFromPacketData(progressMonitor);
+            saveToCache();
+        }
+    }
+
+    private void loadFromCache(InputStream rawIn) throws IOException {
+        NetInput in = new StreamNetInput(rawIn);
+        entityPositions = new TreeMap<>();
+        for (int i = in.readVarInt(); i > 0; i--) {
+            int entityId = in.readVarInt();
+            TreeMap<Long, Location> locationMap = new TreeMap<>();
+            long time = 0;
+            for (int j = in.readVarInt(); j > 0; j--) {
+                time += in.readVarLong();
+                locationMap.put(time, new Location(
+                        in.readDouble(), in.readDouble(), in.readDouble(), in.readFloat(), in.readFloat()
+                ));
+            }
+            entityPositions.put(entityId, locationMap);
+        }
+    }
+
+    private void saveToCache() throws IOException {
+        synchronized (replayFile) {
+            Optional<InputStream> cached = replayFile.getCache(CACHE_ENTRY);
+            if (cached.isPresent()) {
+                // Someone was faster than we were
+                cached.get().close();
+                return;
+            }
+
+            try (OutputStream rawOut = replayFile.writeCache(CACHE_ENTRY)) {
+                NetOutput out = new StreamNetOutput(rawOut);
+                out.writeVarInt(entityPositions.size());
+                for (Map.Entry<Integer, NavigableMap<Long, Location>> entry : entityPositions.entrySet()) {
+                    out.writeVarInt(entry.getKey());
+                    out.writeVarInt(entry.getValue().size());
+                    long time = 0;
+                    for (Map.Entry<Long, Location> locEntry : entry.getValue().entrySet()) {
+                        out.writeVarLong(locEntry.getKey() - time);
+                        time = locEntry.getKey();
+                        Location loc = locEntry.getValue();
+                        out.writeDouble(loc.getX());
+                        out.writeDouble(loc.getY());
+                        out.writeDouble(loc.getZ());
+                        out.writeFloat(loc.getYaw());
+                        out.writeFloat(loc.getPitch());
+                    }
+                }
+            }
+        }
+    }
+
+    private void loadFromPacketData(Consumer<Double> progressMonitor) throws IOException {
+        // Get the packet data input stream
+        int replayLength;
+        ReplayInputStream origIn;
+        synchronized (replayFile) {
+            ReplayMetaData metaData = replayFile.getMetaData();
+            replayLength = Math.max(1, metaData.getDuration());
+            origIn = replayFile.getPacketData(PacketTypeRegistry.get(metaData.getProtocolVersion(), State.LOGIN));
+        }
+
+        Map<Integer, NavigableMap<Long, Location>> entityPositions = new HashMap<>();
+        try (ReplayInputStream in = origIn) {
+            PacketData packetData;
+            while ((packetData = in.readPacket()) != null) {
+                Packet packet = packetData.getPacket();
+
+                Integer entityID = PacketUtils.getEntityId(packet);
+                if (entityID == null) {
+                    packet.release();
+                    continue;
+                }
+
+                NavigableMap<Long, Location> positions = entityPositions.get(entityID);
+                if (positions == null) {
+                    entityPositions.put(entityID, positions = new TreeMap<>());
+                }
+
+                Location oldPosition = positions.isEmpty() ? null : positions.lastEntry().getValue();
+                Location newPosition = PacketUtils.updateLocation(oldPosition, packet);
+
+                if (newPosition != null) {
+                    positions.put(packetData.getTime(), newPosition);
+
+                    double progress = (double) packetData.getTime() / replayLength;
+                    progressMonitor.accept(Math.min(1, Math.max(0, progress)));
+                }
+
+                packet.release();
+            }
+        }
+
+        this.entityPositions = entityPositions;
+    }
+
+    /**
+     * @param entityID The ID of the entity
+     * @param timestamp The timestamp
+     * @return The position of the specified entity at the given timestamp
+     *          or {@code null} if the entity hasn't yet been spawned at that timestamp
+     * @throws IllegalStateException if {@link #load(Consumer)} hasn't been called or hasn't finished yet.
+     */
+    public Location getEntityPositionAtTimestamp(int entityID, long timestamp) {
+        if (entityPositions == null) {
+            throw new IllegalStateException("Not yet initialized.");
+        }
+
+        NavigableMap<Long, Location> positions = entityPositions.get(entityID);
+        if (positions == null) {
+            return null;
+        }
+        Map.Entry<Long, Location> lower = positions.floorEntry(timestamp);
+        Map.Entry<Long, Location> higher = positions.higherEntry(timestamp);
+        if (lower == null || higher == null) {
+            return null;
+        }
+        double r = (higher.getKey() - timestamp) / (higher.getKey() - lower.getKey());
+        Location l = lower.getValue();
+        Location h = higher.getValue();
+        return new Location(
+                l.getX() + (h.getX() - l.getX()) * r,
+                l.getY() + (h.getY() - l.getY()) * r,
+                l.getZ() + (h.getZ() - l.getZ()) * r,
+                l.getYaw() + (h.getYaw() - l.getYaw()) * (float) r,
+                l.getPitch() + (h.getPitch() - l.getPitch()) * (float) r
+        );
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/I18n.java b/src/main/java/com/replaymod/replaystudio/protocol/util/I18n.java
new file mode 100644
index 0000000000000000000000000000000000000000..21bbf53057a2b304f7d0f1addf796a64d1adedab
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/I18n.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+public class I18n {
+    private volatile static Impl impl;
+    public static void setI18n(Impl impl) {
+        I18n.impl = impl;
+    }
+
+    public static String format(String key, Object...args) {
+        return impl.format(key, args);
+    }
+
+    public interface Impl {
+        String format(String key, Object...args);
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/IGlobalPosition.java b/src/main/java/com/replaymod/replaystudio/protocol/util/IGlobalPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..07ad25b7fa77519b076767c5f2c3e0ba9537fb17
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/IGlobalPosition.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import java.util.Objects;
+
+/**
+ * Position with integer components and dimension id.
+ */
+public class IGlobalPosition {
+
+    private final String dimension;
+    private final IPosition position;
+
+    public IGlobalPosition(String dimension, IPosition position) {
+        this.dimension = dimension;
+        this.position = position;
+    }
+
+    public String getDimension() {
+        return dimension;
+    }
+
+    public IPosition getPosition() {
+        return position;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        IGlobalPosition that = (IGlobalPosition) o;
+        return dimension.equals(that.dimension) && position.equals(that.position);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(dimension, position);
+    }
+
+    @Override
+    public String toString() {
+        return "IGlobalPosition{" +
+                "dimension='" + dimension + '\'' +
+                ", position=" + position +
+                '}';
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/IOBiConsumer.java b/src/main/java/com/replaymod/replaystudio/protocol/util/IOBiConsumer.java
new file mode 100644
index 0000000000000000000000000000000000000000..7e568b6610f21d5e3774e2c8a88c53e619213e93
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/IOBiConsumer.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.util;
+
+import java.io.IOException;
+
+@FunctionalInterface
+public interface IOBiConsumer<T, U> {
+    void accept(T t, U u) throws IOException;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/IOConsumer.java b/src/main/java/com/replaymod/replaystudio/protocol/util/IOConsumer.java
new file mode 100644
index 0000000000000000000000000000000000000000..24d82b37f9264b06114767830b32c9a02b39da39
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/IOConsumer.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.util;
+
+import java.io.IOException;
+
+@FunctionalInterface
+public interface IOConsumer<T> {
+    void consume(T value) throws IOException;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/IOSupplier.java b/src/main/java/com/replaymod/replaystudio/protocol/util/IOSupplier.java
new file mode 100644
index 0000000000000000000000000000000000000000..1305788cd1ffe042d558fcb1b5b108bef147aa68
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/IOSupplier.java
@@ -0,0 +1,27 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.util;
+
+import java.io.IOException;
+
+@FunctionalInterface
+public interface IOSupplier<T> {
+    T get() throws IOException;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/IPosition.java b/src/main/java/com/replaymod/replaystudio/protocol/util/IPosition.java
new file mode 100644
index 0000000000000000000000000000000000000000..f52a0eb5c163b97bb2985824a619ed7a82263f21
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/IPosition.java
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import java.util.Objects;
+
+/**
+ * Position with integer components.
+ */
+public class IPosition {
+
+    public static final IPosition NULL = new IPosition(0, 0, 0);
+
+    private final int x, y, z;
+
+    public IPosition(int x, int y, int z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public int getX() {
+        return this.x;
+    }
+
+    public int getY() {
+        return this.y;
+    }
+
+    public int getZ() {
+        return this.z;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (o == null || getClass() != o.getClass()) return false;
+        IPosition iPosition = (IPosition) o;
+        return x == iPosition.x &&
+                y == iPosition.y &&
+                z == iPosition.z;
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(x, y, z);
+    }
+
+    public String toString() {
+        return "IPosition(x=" + this.x + ", y=" + this.y + ", z=" + this.z + ")";
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/Java8.java b/src/main/java/com/replaymod/replaystudio/protocol/util/Java8.java
new file mode 100644
index 0000000000000000000000000000000000000000..5c7124baf63bdf51e0fd811b2596ea2c99bafecd
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/Java8.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import com.google.common.base.Supplier;
+
+import java.util.Map;
+
+/**
+ * Class containing "back-ported" java 8 API features, mainly interface default methods.
+ */
+public class Java8 {
+
+    /**
+     * Java 8 Map interface default methods.
+     */
+    public static class Map8 {
+
+        /**
+         * Note: Not in java 8 API.
+         * Returns the value for the specified key from the map. If no such key exists in the map, this creates
+         * a new value using the specified supplier, puts it in the map and returns the new value.
+         * @param map The map
+         * @param key The key
+         * @param supplier The supplier
+         * @param <K> The type of keys
+         * @param <V> The type of values
+         * @return The value from the map or a new value
+         */
+        public static <K, V> V getOrCreate(Map<K, V> map, K key, Supplier<V> supplier) {
+            V value = map.get(key);
+            if (value == null) {
+                value = supplier.get();
+                map.put(key, value);
+            }
+            return value;
+        }
+
+        /**
+         * @see Map#putIfAbsent(Object, Object)
+         */
+        public static <K, V> void putIfAbsent(Map<K, V> map, K key, V value) {
+            if (!map.containsKey(key)) {
+                map.put(key, value);
+            }
+        }
+    }
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/Location.java b/src/main/java/com/replaymod/replaystudio/protocol/util/Location.java
new file mode 100644
index 0000000000000000000000000000000000000000..280934fc6612e738f5e03227c4d8879815baad62
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/Location.java
@@ -0,0 +1,112 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+
+/**
+ * Position and rotation (pitch and yaw, no roll) in three dimensional space.
+ */
+public class Location {
+
+    /**
+     * Location at 0/0/0 with 0 yaw and 0 pitch.
+     */
+    public static final Location NULL = new Location(0, 0, 0);
+
+    private final double x, y, z;
+    private final float yaw, pitch;
+
+    public Location(DPosition position) {
+        this(position, 0, 0);
+    }
+
+    public Location(DPosition position, float yaw, float pitch) {
+        this(position.getX(), position.getY(), position.getZ(), yaw, pitch);
+    }
+
+    public Location(double x, double y, double z) {
+        this(x, y, z, 0, 0);
+    }
+
+    public Location(double x, double y, double z, float yaw, float pitch) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+        this.yaw = yaw;
+        this.pitch = pitch;
+    }
+
+    public DPosition getDPosition() {
+        return new DPosition(x, y, z);
+    }
+
+    public double getX() {
+        return this.x;
+    }
+
+    public double getY() {
+        return this.y;
+    }
+
+    public double getZ() {
+        return this.z;
+    }
+
+    public float getYaw() {
+        return this.yaw;
+    }
+
+    public float getPitch() {
+        return this.pitch;
+    }
+
+    public boolean equals(Object o) {
+        if (o == this) return true;
+        if (!(o instanceof Location)) return false;
+        final Location other = (Location) o;
+        if (!other.canEqual(this)) return false;
+        if (Double.compare(this.x, other.x) != 0) return false;
+        if (Double.compare(this.y, other.y) != 0) return false;
+        if (Double.compare(this.z, other.z) != 0) return false;
+        if (Float.compare(this.yaw, other.yaw) != 0) return false;
+        if (Float.compare(this.pitch, other.pitch) != 0) return false;
+        return true;
+    }
+
+    public int hashCode() {
+        int result = 1;
+        final long x = Double.doubleToLongBits(this.x);
+        result = result * 59 + (int) (x >>> 32 ^ x);
+        final long y = Double.doubleToLongBits(this.y);
+        result = result * 59 + (int) (y >>> 32 ^ y);
+        final long z = Double.doubleToLongBits(this.z);
+        result = result * 59 + (int) (z >>> 32 ^ z);
+        result = result * 59 + Float.floatToIntBits(this.yaw);
+        result = result * 59 + Float.floatToIntBits(this.pitch);
+        return result;
+    }
+
+    protected boolean canEqual(Object other) {
+        return other instanceof Location;
+    }
+
+    public String toString() {
+        return "Location(x=" + this.x + ", y=" + this.y + ", z=" + this.z + ", yaw=" + this.yaw + ", pitch=" + this.pitch + ")";
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/Motion.java b/src/main/java/com/replaymod/replaystudio/protocol/util/Motion.java
new file mode 100644
index 0000000000000000000000000000000000000000..afde87b667939bc9a8b943f2f91bb52914bf038f
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/Motion.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+/**
+ * Motion data for entities.
+ */
+public class Motion {
+
+    public static final Motion NULL = new Motion(0, 0, 0);
+
+    private final double x, y, z;
+
+    public Motion(double x, double y, double z) {
+        this.x = x;
+        this.y = y;
+        this.z = z;
+    }
+
+    public double getX() {
+        return this.x;
+    }
+
+    public double getY() {
+        return this.y;
+    }
+
+    public double getZ() {
+        return this.z;
+    }
+
+    public boolean equals(Object o) {
+        if (o == this) return true;
+        if (!(o instanceof Motion)) return false;
+        final Motion other = (Motion) o;
+        if (!other.canEqual(this)) return false;
+        if (Double.compare(this.x, other.x) != 0) return false;
+        if (Double.compare(this.y, other.y) != 0) return false;
+        if (Double.compare(this.z, other.z) != 0) return false;
+        return true;
+    }
+
+    public int hashCode() {
+        int result = 1;
+        final long x = Double.doubleToLongBits(this.x);
+        result = result * 59 + (int) (x >>> 32 ^ x);
+        final long y = Double.doubleToLongBits(this.y);
+        result = result * 59 + (int) (y >>> 32 ^ y);
+        final long z = Double.doubleToLongBits(this.z);
+        result = result * 59 + (int) (z >>> 32 ^ z);
+        return result;
+    }
+
+    protected boolean canEqual(Object other) {
+        return other instanceof Motion;
+    }
+
+    public String toString() {
+        return "Motion(x=" + this.x + ", y=" + this.y + ", z=" + this.z + ")";
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/PacketUtils.java b/src/main/java/com/replaymod/replaystudio/protocol/util/PacketUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e89c5558170250e00dfd02a0afb577beae5573c
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/PacketUtils.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.packets.EntityId;
+import com.replaymod.replaystudio.protocol.packets.PacketEntityMovement;
+import com.replaymod.replaystudio.protocol.packets.PacketEntityTeleport;
+import com.replaymod.replaystudio.protocol.packets.SpawnEntity;
+import org.apache.commons.lang3.tuple.Pair;
+import org.apache.commons.lang3.tuple.Triple;
+
+import java.io.IOException;
+import java.util.List;
+
+/**
+ * Contains utilities for working with packets.
+ */
+public class PacketUtils {
+
+    public static boolean isSpawnEntityPacket(Packet packet) {
+        switch (packet.getType()) {
+            case SpawnPlayer:
+            case SpawnMob:
+            case SpawnObject:
+            case SpawnExpOrb:
+            case SpawnPainting:
+            case SpawnGlobalEntity:
+                return true;
+            default:
+                return false;
+        }
+    }
+
+    /**
+     * Returns the entity id in the specified packet.
+     * If no entity is associated with the packet this returns {@code null}.
+     * For packets which have multiple entities associated with them use {@link #getEntityIds(Packet)})} instead.
+     * @return Entity id or {@code null}
+     */
+    public static Integer getEntityId(Packet packet) throws IOException {
+        return EntityId.getEntityId(packet);
+    }
+
+    /**
+     * Returns entity ids in the specified packet.
+     * If no entity is associated with the packet this returns an empty list.
+     * @return List of entity ids
+     */
+    public static List<Integer> getEntityIds(Packet packet) throws IOException {
+        return EntityId.getEntityIds(packet);
+    }
+
+    /**
+     * Update (or initialize) a location with the movement (or spawn) data in the specified packet.
+     * @param loc The location (may be {@code null} in case of spawn or absolute movement packets)
+     * @param packet The packet
+     * @return The new location or {@code null} when the packet could not be handled
+     */
+    public static Location updateLocation(Location loc, Packet packet) throws IOException {
+        Location spawnLocation = SpawnEntity.getLocation(packet);
+        if (spawnLocation != null) {
+            return spawnLocation;
+        }
+
+        switch (packet.getType()) {
+            case EntityMovement:
+            case EntityPosition:
+            case EntityRotation:
+            case EntityPositionRotation:
+                if (loc == null) {
+                    loc = Location.NULL;
+                }
+                Triple<DPosition, Pair<Float, Float>, Boolean> movement = PacketEntityMovement.getMovement(packet);
+                DPosition deltaPos = movement.getLeft();
+                Pair<Float, Float> yawPitch = movement.getMiddle();
+                double x = loc.getX();
+                double y = loc.getY();
+                double z = loc.getZ();
+                if (deltaPos != null) {
+                    x += deltaPos.getX();
+                    y += deltaPos.getY();
+                    z += deltaPos.getZ();
+                }
+                float yaw = yawPitch != null ? yawPitch.getKey() : loc.getYaw();
+                float pitch = yawPitch != null ? yawPitch.getValue() : loc.getPitch();
+
+                return new Location(x, y, z, yaw, pitch);
+            case EntityTeleport:
+                return PacketEntityTeleport.getLocation(packet);
+            default:
+                return null;
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/Property.java b/src/main/java/com/replaymod/replaystudio/protocol/util/Property.java
new file mode 100644
index 0000000000000000000000000000000000000000..03642b5fd999006241c999103432be95039f2e42
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/Property.java
@@ -0,0 +1,57 @@
+/*
+ * Copyright (c) 2022
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.util;
+
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+
+public class Property {
+    private final String name;
+    private final String value;
+    private final String signature;
+
+    public Property(String name, String value, String signature) {
+        this.name = name;
+        this.value = value;
+        this.signature = signature;
+    }
+
+    public static Property read(Packet.Reader in) throws IOException {
+        String name = in.readString();
+        String value = in.readString();
+        String signature = null;
+        if (in.readBoolean()) {
+            signature = in.readString();
+        }
+        return new Property(name, value, signature);
+    }
+
+    public void write(Packet.Writer out) throws IOException {
+        out.writeString(name);
+        out.writeString(value);
+        if (signature != null) {
+            out.writeBoolean(true);
+            out.writeString(signature);
+        } else {
+            out.writeBoolean(false);
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/ThreadLocalOutputStream.java b/src/main/java/com/replaymod/replaystudio/protocol/util/ThreadLocalOutputStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..796c8d624d797162ee119b6a782dfc800db52a44
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/ThreadLocalOutputStream.java
@@ -0,0 +1,90 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import java.io.IOException;
+import java.io.OutputStream;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+/**
+ * Output stream which uses a different underlying output stream depending on the current thread.
+ */
+public class ThreadLocalOutputStream extends OutputStream {
+
+    /**
+     * The default output stream.
+     */
+    private OutputStream def;
+
+    /**
+     * All thread local output streams.
+     */
+    private final ThreadLocal<OutputStream> outputs = new ThreadLocal<>();
+
+    /**
+     * Creates a new thread local output stream with the specified output stream as a default.
+     * @param def The default output stream
+     */
+    public ThreadLocalOutputStream(OutputStream def) {
+        this.def = checkNotNull(def);
+    }
+
+    /**
+     * Returns the default output stream used for all threads which don't have their own set.
+     * @return The default output stream
+     */
+    public OutputStream getDefault() {
+        return def;
+    }
+
+    /**
+     * Sets the default output stream used for all threads which don't have their own set.
+     * @param def The default output stream
+     */
+    public void setDefault(OutputStream def) {
+        this.def = checkNotNull(def);
+    }
+
+    /**
+     * Sets the output stream to use for the current thread.
+     * @param output The output stream
+     */
+    public void setOutput(OutputStream output) {
+        this.outputs.set(output);
+    }
+
+    @Override
+    public void write(int b) throws IOException {
+        OutputStream out = outputs.get();
+        if (out == null) {
+            out = def;
+        }
+        out.write(b);
+    }
+
+    @Override
+    public void write(byte b[], int off, int len) throws IOException {
+        OutputStream out = outputs.get();
+        if (out == null) {
+            out = def;
+        }
+        out.write(b, off, len);
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/replaymod/replaystudio/protocol/util/Utils.java b/src/main/java/com/replaymod/replaystudio/protocol/util/Utils.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ffd33ada67e565153a10fae2069f3dfcab2fb02
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/protocol/util/Utils.java
@@ -0,0 +1,278 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.util;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.util.ReferenceCountUtil;
+import com.github.steveice10.packetlib.io.NetInput;
+import com.github.steveice10.packetlib.io.NetOutput;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetInput;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetOutput;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.replaymod.replaystudio.protocol.Packet;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.zip.Deflater;
+import java.util.zip.Inflater;
+
+/**
+ * Various utilities.
+ */
+public class Utils {
+
+    /**
+     * Reads an integer from the input stream.
+     * @param in The input stream
+     * @return The integer
+     * @throws IOException if an I/O error occurs.
+     */
+    public static int readInt(InputStream in) throws IOException {
+        int b0 = in.read();
+        int b1 = in.read();
+        int b2 = in.read();
+        int b3 = in.read();
+        if ((b0 | b1 | b2 | b3) < 0) {
+            return -1;
+        }
+        return b0 << 24 | b1 << 16 | b2 << 8 | b3;
+    }
+
+    /**
+     * Writes an integer to the output stream.
+     * @param out The output stream
+     * @param x The integer
+     * @throws IOException if an I/O error occurs.
+     */
+    public static void writeInt(OutputStream out, int x) throws IOException {
+        out.write((x >>> 24) & 0xFF);
+        out.write((x >>> 16) & 0xFF);
+        out.write((x >>>  8) & 0xFF);
+        out.write(x & 0xFF);
+    }
+
+    /**
+     * Checks whether the specified array contains only {@code null} elements.
+     * If there is one element that is not null in the array, this method will return {@code false}.
+     * @param array The array
+     * @return {@code true} if this array contains only {@code null} entries
+     */
+    public static boolean containsOnlyNull(Object[] array) {
+        for (Object o : array) {
+            if (o != null) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Make sure that the returned value is within the specified bounds (inclusive).
+     * If the value is greater than {@code max} then {@code max} is returned.
+     * If the value is smaller than {@code min} then {@code min} is returned.
+     * @param i The value
+     * @param min Lower bound
+     * @param max Upper bound
+     * @return The value within max and min
+     */
+    public static long within(long i, long min, long max) {
+        if (i > max) {
+            return max;
+        }
+        if (i < min) {
+            return min;
+        }
+        return i;
+    }
+
+    /**
+     * Create a new input stream delegating to the specified source.
+     * The new input stream has its own closed state and does not close the
+     * source stream.
+     * @param source The source input stream
+     * @return The delegating input stream
+     */
+    public static InputStream notCloseable(InputStream source) {
+        return new InputStream() {
+            boolean closed;
+
+            @Override
+            public void close() throws IOException {
+                closed = true;
+            }
+
+            @Override
+            public int read() throws IOException {
+                if (closed) {
+                    return -1;
+                }
+                return source.read();
+            }
+
+            @Override
+            public int read(byte[] b, int off, int len) throws IOException {
+                if (closed) {
+                    return -1;
+                }
+                return source.read(b, off, len);
+            }
+
+            @Override
+            public int available() throws IOException {
+                return source.available();
+            }
+
+            @Override
+            public long skip(long n) throws IOException {
+                if (closed) {
+                    return 0;
+                }
+                return source.skip(n);
+            }
+
+            @Override
+            public synchronized void mark(int readlimit) {
+                source.mark(readlimit);
+            }
+
+            @Override
+            public synchronized void reset() throws IOException {
+                source.reset();
+            }
+
+            @Override
+            public boolean markSupported() {
+                return source.markSupported();
+            }
+
+            @Override
+            public int read(byte[] b) throws IOException {
+                if (closed) {
+                    return -1;
+                }
+                return source.read(b);
+            }
+        };
+    }
+
+    public static void copy(InputStream in, OutputStream out) throws IOException {
+        byte[] buffer = new byte[1024];
+        int read;
+        while ((read = in.read(buffer)) > -1) {
+            out.write(buffer, 0, read);
+        }
+        in.close();
+    }
+
+    public static ByteBuf readRetainedSlice(NetInput in, int len) throws IOException {
+        if (in instanceof ByteBufExtNetInput) {
+            ByteBuf inBuf = ((ByteBufExtNetInput) in).getBuf();
+            return inBuf.readRetainedSlice(len);
+        }
+        return Unpooled.wrappedBuffer(in.readBytes(len));
+    }
+
+    public static void writeBytes(NetOutput out, ByteBuf buf) throws IOException {
+        if (out instanceof ByteBufExtNetOutput) {
+            ByteBuf outBuf = ((ByteBufExtNetOutput) out).getBuf();
+            outBuf.writeBytes(buf);
+            return;
+        }
+
+        byte[] bytes = new byte[buf.readableBytes()];
+        buf.getBytes(buf.readerIndex(), bytes);
+        out.writeBytes(bytes);
+    }
+
+    public static Packet readCompressedPacket(PacketTypeRegistry registry, NetInput in) throws IOException {
+        ByteBuf byteBuf = null;
+        try {
+            int prefix = in.readVarInt();
+            int len = prefix >> 1;
+            if ((prefix & 1) == 1) {
+                int fullLen = in.readVarInt();
+                byteBuf = Unpooled.buffer(fullLen);
+
+                Inflater inflater = new Inflater();
+                inflater.setInput(in.readBytes(len));
+                inflater.inflate(byteBuf.array(), byteBuf.arrayOffset(), fullLen);
+                byteBuf.writerIndex(fullLen);
+            } else {
+                byteBuf = readRetainedSlice(in, len);
+            }
+
+            int id = new ByteBufNetInput(byteBuf).readVarInt();
+            int stateId = id >> 24;
+            int packetId = id << 24 >> 24;
+            return new Packet(registry.withState(State.values()[4 - stateId]), packetId, byteBuf.retain());
+        } catch (IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        } finally {
+            ReferenceCountUtil.release(byteBuf);
+        }
+    }
+
+    public static void writeCompressedPacket(NetOutput out, Packet packet) throws IOException {
+        ByteBuf byteBuf = Unpooled.buffer();
+        try {
+            int stateId = 4 - packet.getType().getState().ordinal();
+            new ByteBufNetOutput(byteBuf).writeVarInt((stateId << 24) | packet.getId());
+            byteBuf.writeBytes(packet.getBuf());
+
+            int rawIndex = byteBuf.readerIndex();
+            int size = byteBuf.readableBytes();
+
+            byteBuf.ensureWritable(size);
+            Deflater deflater = new Deflater();
+            deflater.setInput(byteBuf.array(), byteBuf.arrayOffset() + byteBuf.readerIndex(), size);
+            deflater.finish();
+            int compressedSize = 0;
+            while (!deflater.finished() && compressedSize < size) {
+                compressedSize += deflater.deflate(
+                        byteBuf.array(),
+                        byteBuf.arrayOffset() + byteBuf.writerIndex() + compressedSize,
+                        size - compressedSize
+                );
+            }
+
+            if (compressedSize < size) {
+                byteBuf.readerIndex(rawIndex + size);
+                byteBuf.writerIndex(rawIndex + size + compressedSize);
+                out.writeVarInt(compressedSize << 1 | 1);
+                out.writeVarInt(size);
+            } else {
+                byteBuf.readerIndex(rawIndex);
+                byteBuf.writerIndex(rawIndex + size);
+                out.writeVarInt(size << 1);
+            }
+            writeBytes(out, byteBuf);
+        } catch (IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        } finally {
+            ReferenceCountUtil.release(byteBuf);
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/replay/AbstractReplayFile.java b/src/main/java/com/replaymod/replaystudio/replay/AbstractReplayFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..331aca2130828ce412fd44d1cca8a3feda5ec4e1
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/replay/AbstractReplayFile.java
@@ -0,0 +1,347 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.replay;
+
+import com.google.common.base.Optional;
+import com.google.common.io.Closeables;
+import com.google.gson.*;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.data.Marker;
+import com.replaymod.replaystudio.data.ModInfo;
+import com.replaymod.replaystudio.data.ReplayAssetEntry;
+import com.replaymod.replaystudio.io.ReplayInputStream;
+import com.replaymod.replaystudio.io.ReplayOutputStream;
+import com.replaymod.replaystudio.pathing.PathingRegistry;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.pathing.serialize.TimelineSerialization;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.*;
+import java.util.*;
+import java.util.regex.Pattern;
+
+public abstract class AbstractReplayFile implements ReplayFile {
+
+    private static final String ENTRY_META_DATA = "metaData.json";
+    protected static final String ENTRY_RECORDING = "recording.tmcpr";
+    private static final String ENTRY_RESOURCE_PACK = "resourcepack/%s.zip";
+    private static final String ENTRY_RESOURCE_PACK_INDEX = "resourcepack/index.json";
+    private static final String ENTRY_THUMB_OLD = "thumb";
+    private static final String ENTRY_THUMB = "thumb.jpg";
+    private static final String ENTRY_VISIBILITY_OLD = "visibility";
+    private static final String ENTRY_VISIBILITY = "visibility.json";
+    private static final String ENTRY_MARKERS = "markers.json";
+    private static final String ENTRY_ASSET = "asset/%s_%s.%s";
+    private static final Pattern PATTERN_ASSETS = Pattern.compile("asset/.*");
+    private static final String ENTRY_MODS = "mods.json";
+
+    private static final byte[] THUMB_MAGIC_NUMBERS = {0, 1, 1, 2, 3, 5, 8};
+
+    protected final Studio studio;
+
+    public AbstractReplayFile(Studio studio) throws IOException {
+        this.studio = studio;
+    }
+
+    @Override
+    public ReplayMetaData getMetaData() throws IOException {
+        Optional<InputStream> in = get(ENTRY_META_DATA);
+        if (!in.isPresent()) {
+            return null;
+        }
+        try (Reader is = new InputStreamReader(in.get())) {
+            return new Gson().fromJson(is, ReplayMetaData.class);
+        }
+    }
+
+    @Override
+    public void writeMetaData(PacketTypeRegistry registry, ReplayMetaData metaData) throws IOException {
+        metaData.setFileFormat("MCPR");
+        if (registry != null) {
+            metaData.setFileFormatVersion(ReplayMetaData.CURRENT_FILE_FORMAT_VERSION);
+            metaData.setProtocolVersion(registry.getVersion().getOriginalVersion());
+        }
+        if (metaData.getGenerator() == null) {
+            metaData.setGenerator("ReplayStudio v" + studio.getVersion());
+        }
+
+        try (OutputStream out = write(ENTRY_META_DATA)) {
+            String json = new Gson().toJson(metaData);
+            out.write(json.getBytes());
+        }
+    }
+
+    @Override
+    public ReplayInputStream getPacketData(PacketTypeRegistry registry) throws IOException {
+        Optional<InputStream> in = get(ENTRY_RECORDING);
+        if (!in.isPresent()) {
+            return null;
+        }
+        ReplayMetaData metaData = getMetaData();
+        return new ReplayInputStream(registry, in.get(), metaData.getFileFormatVersion(), metaData.getRawProtocolVersionOr0());
+    }
+
+    @Override
+    public ReplayOutputStream writePacketData() throws IOException {
+        return new ReplayOutputStream(write(ENTRY_RECORDING));
+    }
+
+    @Override
+    public Map<Integer, String> getResourcePackIndex() throws IOException {
+        Optional<InputStream> in = get(ENTRY_RESOURCE_PACK_INDEX);
+        if (!in.isPresent()) {
+            return null;
+        }
+        Map<Integer, String> index = new HashMap<>();
+        try (Reader is = new InputStreamReader(in.get())) {
+            JsonObject array = new Gson().fromJson(is, JsonObject.class);
+            for (Map.Entry<String, JsonElement> e : array.entrySet()) {
+                try {
+                    index.put(Integer.parseInt(e.getKey()), e.getValue().getAsString());
+                } catch (NumberFormatException ignored) {
+                }
+            }
+        }
+        return index;
+    }
+
+    @Override
+    public void writeResourcePackIndex(Map<Integer, String> index) throws IOException {
+        try (OutputStream out = write(ENTRY_RESOURCE_PACK_INDEX)) {
+            String json = new Gson().toJson(index);
+            out.write(json.getBytes());
+        }
+    }
+
+    @Override
+    public Optional<InputStream> getResourcePack(String hash) throws IOException {
+        return get(String.format(ENTRY_RESOURCE_PACK, hash));
+    }
+
+    @Override
+    public OutputStream writeResourcePack(String hash) throws IOException {
+        return write(String.format(ENTRY_RESOURCE_PACK, hash));
+    }
+
+    @Override
+    public Map<String, Timeline> getTimelines(PathingRegistry pathingRegistry) throws IOException {
+        return new TimelineSerialization(pathingRegistry, this).load();
+    }
+
+    @Override
+    public void writeTimelines(PathingRegistry pathingRegistry, Map<String, Timeline> timelines) throws IOException {
+        new TimelineSerialization(pathingRegistry, this).save(timelines);
+    }
+
+    @Override
+    public Optional<InputStream> getThumbBytes() throws IOException {
+        Optional<InputStream> maybeThumb = get(ENTRY_THUMB);
+        if (maybeThumb.isPresent()) {
+            return Optional.of(maybeThumb.get());
+        }
+
+        maybeThumb = get(ENTRY_THUMB_OLD);
+        if (maybeThumb.isPresent()) {
+            PushbackInputStream in = new PushbackInputStream(maybeThumb.get(), THUMB_MAGIC_NUMBERS.length);
+            byte[] buf = new byte[THUMB_MAGIC_NUMBERS.length];
+            new DataInputStream(in).readFully(buf);
+            if (!Arrays.equals(buf, THUMB_MAGIC_NUMBERS)) {
+                in.unread(buf);
+            }
+            return Optional.of(in);
+        }
+
+        return Optional.absent();
+    }
+
+    @Override
+    public void writeThumbBytes(byte[] image) throws IOException {
+        try (OutputStream out = write(ENTRY_THUMB)) {
+            out.write(image);
+        }
+    }
+
+    @Override
+    public Optional<Set<UUID>> getInvisiblePlayers() throws IOException {
+        Optional<InputStream> in = get(ENTRY_VISIBILITY);
+        if (!in.isPresent()) {
+            in = get(ENTRY_VISIBILITY_OLD);
+            if (!in.isPresent()) {
+                return Optional.absent();
+            }
+        }
+        Set<UUID> uuids = new HashSet<>();
+        try (Reader is = new InputStreamReader(in.get())) {
+            JsonObject json = new Gson().fromJson(is, JsonObject.class);
+            for (JsonElement e : json.getAsJsonArray("hidden")) {
+                uuids.add(UUID.fromString(e.getAsString()));
+            }
+        }
+        return Optional.of(uuids);
+    }
+
+    @Override
+    public void writeInvisiblePlayers(Set<UUID> uuids) throws IOException {
+        try (OutputStream out = write(ENTRY_VISIBILITY)) {
+            JsonObject root = new JsonObject();
+            JsonArray array = new JsonArray();
+            root.add("hidden", array);
+            for (UUID uuid : uuids) {
+                array.add(new JsonPrimitive(uuid.toString()));
+            }
+            String json = new Gson().toJson(root);
+            out.write(json.getBytes());
+        }
+    }
+
+    @Override
+    public Optional<Set<Marker>> getMarkers() throws IOException {
+        Optional<InputStream> in = get(ENTRY_MARKERS);
+        if (in.isPresent()) {
+            try (Reader is = new InputStreamReader(in.get())) {
+                JsonArray json = new Gson().fromJson(is, JsonArray.class);
+                Set<Marker> markers = new HashSet<>();
+                for (JsonElement element : json) {
+                    JsonObject obj = element.getAsJsonObject();
+                    JsonObject value = obj.getAsJsonObject("value");
+                    JsonObject position = value.getAsJsonObject("position");
+                    Marker marker = new Marker();
+                    marker.setTime(obj.get("realTimestamp").getAsInt());
+                    marker.setX(position.get("x").getAsDouble());
+                    marker.setY(position.get("y").getAsDouble());
+                    marker.setZ(position.get("z").getAsDouble());
+                    marker.setYaw(position.get("yaw").getAsFloat());
+                    marker.setPitch(position.get("pitch").getAsFloat());
+                    marker.setRoll(position.get("roll").getAsFloat());
+                    if (value.has("name")) {
+                        marker.setName(value.get("name").getAsString());
+                    }
+                    markers.add(marker);
+                }
+                return Optional.of(markers);
+            }
+        }
+        return Optional.absent();
+    }
+
+    @Override
+    public void writeMarkers(Set<Marker> markers) throws IOException {
+        try (OutputStream out = write(ENTRY_MARKERS)) {
+            JsonArray root = new JsonArray();
+            for (Marker marker : markers) {
+                JsonObject entry = new JsonObject();
+                JsonObject value = new JsonObject();
+                JsonObject position = new JsonObject();
+
+                entry.add("realTimestamp", new JsonPrimitive(marker.getTime()));
+                value.add("name", marker.getName() == null ? null : new JsonPrimitive(marker.getName()));
+                position.add("x", new JsonPrimitive(marker.getX()));
+                position.add("y", new JsonPrimitive(marker.getY()));
+                position.add("z", new JsonPrimitive(marker.getZ()));
+                position.add("yaw", new JsonPrimitive(marker.getYaw()));
+                position.add("pitch", new JsonPrimitive(marker.getPitch()));
+                position.add("roll", new JsonPrimitive(marker.getRoll()));
+
+                value.add("position", position);
+                entry.add("value", value);
+                root.add(entry);
+            }
+            out.write(new Gson().toJson(root).getBytes());
+        }
+    }
+
+    @Override
+    public Collection<ReplayAssetEntry> getAssets() throws IOException {
+        Map<String, InputStream> entries = getAll(PATTERN_ASSETS);
+        entries.values().forEach(Closeables::closeQuietly);
+        List<ReplayAssetEntry> list = new ArrayList<>();
+        for (String key : entries.keySet()) {
+            int delim = key.indexOf('_');
+            UUID uuid = UUID.fromString(key.substring(0, delim));
+            String name = key.substring(delim + 1, key.lastIndexOf('.'));
+            String extension = key.substring(key.lastIndexOf('.'));
+            list.add(new ReplayAssetEntry(uuid, extension, name));
+        }
+        return list;
+    }
+
+    @Override
+    public Optional<InputStream> getAsset(UUID uuid) throws IOException {
+        Map<String, InputStream> entries = getAll(Pattern.compile("asset/" + Pattern.quote(uuid.toString()) + "_.*"));
+        if (entries.isEmpty()) {
+            return Optional.absent();
+        }
+        return Optional.of(entries.values().iterator().next());
+    }
+
+    @Override
+    public OutputStream writeAsset(ReplayAssetEntry asset) throws IOException {
+        return write(String.format(ENTRY_ASSET, asset.getUuid().toString(), asset.getName(), asset.getFileExtension()));
+    }
+
+    @Override
+    public void removeAsset(UUID uuid) throws IOException {
+        Collection<ReplayAssetEntry> assets = getAssets();
+        for (ReplayAssetEntry asset : assets) {
+            if (asset.getUuid().equals(uuid)) {
+                remove(String.format(ENTRY_ASSET, asset.getUuid().toString(), asset.getName(), asset.getFileExtension()));
+            }
+        }
+    }
+
+    @Override
+    public Collection<ModInfo> getModInfo() throws IOException {
+        Optional<InputStream> in = get(ENTRY_MODS);
+        if (in.isPresent()) {
+            try (Reader is = new InputStreamReader(in.get())) {
+                JsonArray json = new Gson().fromJson(is, JsonObject.class).getAsJsonArray("requiredMods");
+                List<ModInfo> modInfoList = new ArrayList<>();
+                for (JsonElement element : json) {
+                    JsonObject obj = element.getAsJsonObject();
+                    modInfoList.add(new ModInfo(
+                            obj.get("modID").getAsString(),
+                            obj.get("modName").getAsString(),
+                            obj.get("modVersion").getAsString()
+                    ));
+                }
+                return modInfoList;
+            }
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public void writeModInfo(Collection<ModInfo> modInfo) throws IOException {
+        try (OutputStream out = write(ENTRY_MODS)) {
+            JsonObject root = new JsonObject();
+            JsonArray array = new JsonArray();
+            for (ModInfo mod : modInfo) {
+                JsonObject entry = new JsonObject();
+                entry.addProperty("modID", mod.getId());
+                entry.addProperty("modName", mod.getName());
+                entry.addProperty("modVersion", mod.getVersion());
+                array.add(entry);
+            }
+            root.add("requiredMods", array);
+            out.write(new Gson().toJson(root).getBytes());
+        }
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/replay/ReplayFile.java b/src/main/java/com/replaymod/replaystudio/replay/ReplayFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..5260353f00f0d75ddbc9de62cf41a5c056ce2b6e
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/replay/ReplayFile.java
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.replay;
+
+import com.google.common.base.Optional;
+import com.replaymod.replaystudio.data.Marker;
+import com.replaymod.replaystudio.data.ModInfo;
+import com.replaymod.replaystudio.data.ReplayAssetEntry;
+import com.replaymod.replaystudio.io.ReplayInputStream;
+import com.replaymod.replaystudio.io.ReplayOutputStream;
+import com.replaymod.replaystudio.pathing.PathingRegistry;
+import com.replaymod.replaystudio.pathing.path.Timeline;
+import com.replaymod.replaystudio.protocol.PacketTypeRegistry;
+
+import javax.imageio.ImageIO;
+import java.awt.image.BufferedImage;
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.Closeable;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+import java.util.regex.Pattern;
+
+public interface ReplayFile extends Closeable {
+
+    /**
+     * Returns an input stream for the specified entry in this replay file.
+     * @param entry The entry
+     * @return Optional input stream
+     * @throws IOException If an I/O error occurs
+     */
+    Optional<InputStream> get(String entry) throws IOException;
+
+    /**
+     * Returns an input stream for the specified entry in the cache of this replay file.
+     * @param entry The entry
+     * @return Optional input stream
+     * @throws IOException If an I/O error occurs
+     */
+    Optional<InputStream> getCache(String entry) throws IOException;
+
+    /**
+     * Returns input streams for each entry matching in this replay file.
+     * @param pattern The pattern used for matching entries
+     * @return Map with entry names as keys and their input streams as values
+     * @throws IOException If an I/O error occurs
+     */
+    Map<String, InputStream> getAll(Pattern pattern) throws IOException;
+
+    /**
+     * Write to the specified entry in this replay file.
+     * If an output stream for this entry already exists, it is closed.
+     * The changes will not be written unless {@link #save()} is called.
+     * @param entry The entry
+     * @return An output stream to write to
+     * @throws IOException If an I/O error occurs
+     */
+    OutputStream write(String entry) throws IOException;
+
+    /**
+     * Write to the specified cache entry of this replay file.
+     * Since the cache in not part of the original replay file, there's no need to call {@link #save()} to persist it.
+     * There's also no guarantee of persistence, the cache may be cleared (but shouldn't be most of the time) when the
+     * cache entry is closed. The cache will always be cleared when the replay data is being re-written.
+     * Writing to the cache while an OutputStream to the replay data is open results in undefined behavior.
+     * @param entry The entry
+     * @return An output stream to write to
+     * @throws IOException If an I/O error occurs
+     */
+    OutputStream writeCache(String entry) throws IOException;
+
+    /**
+     * Removes the entry from this replay file.
+     * Changes will not be written unless {@link #save()} is called.
+     * @param entry The entry
+     * @throws IOException
+     */
+    void remove(String entry) throws IOException;
+
+    /**
+     * Removes the cache entry of this replay file.
+     * @param entry The entry
+     * @throws IOException
+     */
+    void removeCache(String entry) throws IOException;
+
+    /**
+     * Saves the changes to this replay file.
+     * If this operation fails, the original replay file will be unchanged,
+     * @throws IOException If an I/O error occurs
+     */
+    void save() throws IOException;
+
+    /**
+     * Saves this replay file and all changes to the specified file.
+     * Does not include any cache entries.
+     * @param target The target file location
+     * @throws IOException If an I/O error occurs
+     */
+    void saveTo(File target) throws IOException;
+
+    ReplayMetaData getMetaData() throws IOException;
+    void writeMetaData(PacketTypeRegistry registry, ReplayMetaData metaData) throws IOException;
+
+    ReplayInputStream getPacketData(PacketTypeRegistry registry) throws IOException;
+
+    ReplayOutputStream writePacketData() throws IOException;
+
+    Map<Integer, String> getResourcePackIndex() throws IOException;
+    void writeResourcePackIndex(Map<Integer, String> index) throws IOException;
+
+    Optional<InputStream> getResourcePack(String hash) throws IOException;
+    OutputStream writeResourcePack(String hash) throws IOException;
+
+    Map<String, Timeline> getTimelines(PathingRegistry pathingRegistry) throws IOException;
+    void writeTimelines(PathingRegistry pathingRegistry, Map<String, Timeline> timelines) throws IOException;
+
+    default Optional<BufferedImage> getThumb() throws IOException {
+        Optional<InputStream> maybeThumb = getThumbBytes();
+        if (maybeThumb.isPresent()) {
+            return Optional.of(ImageIO.read(maybeThumb.get()));
+        }
+        return Optional.absent();
+    }
+    default void writeThumb(BufferedImage image) throws IOException {
+        ByteArrayOutputStream out = new ByteArrayOutputStream();
+        ImageIO.write(image, "jpg", out);
+        writeThumbBytes(out.toByteArray());
+    }
+
+    Optional<InputStream> getThumbBytes() throws IOException;
+    void writeThumbBytes(byte[] image) throws IOException;
+
+    Optional<Set<UUID>> getInvisiblePlayers() throws IOException;
+    void writeInvisiblePlayers(Set<UUID> uuids) throws IOException;
+
+    Optional<Set<Marker>> getMarkers() throws IOException;
+    void writeMarkers(Set<Marker> markers) throws IOException;
+
+    Collection<ReplayAssetEntry> getAssets() throws IOException;
+    Optional<InputStream> getAsset(UUID uuid) throws IOException;
+    OutputStream writeAsset(ReplayAssetEntry asset) throws IOException;
+    void removeAsset(UUID uuid) throws IOException;
+
+    Collection<ModInfo> getModInfo() throws IOException;
+    void writeModInfo(Collection<ModInfo> modInfo) throws IOException;
+}
diff --git a/src/main/java/com/replaymod/replaystudio/replay/ReplayMetaData.java b/src/main/java/com/replaymod/replaystudio/replay/ReplayMetaData.java
new file mode 100644
index 0000000000000000000000000000000000000000..7348024e44c46177b45036fe2ed91d0527406f96
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/replay/ReplayMetaData.java
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.replay;
+
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+/**
+ * Meta data for replay files.
+ */
+public class ReplayMetaData {
+    public static final int CURRENT_FILE_FORMAT_VERSION = 14;
+
+    /**
+     * Mapping from replay file version to protocol version for versions prior to 10.
+     * For 10+ see https://github.com/ReplayMod/ReplayStudio/issues/9 (i.e. {@link #protocol}).
+     */
+    public static final Map<Integer, Integer> PROTOCOL_FOR_FILE_FORMAT = Collections.unmodifiableMap(new HashMap<Integer, Integer>() {{
+        put(0, 47);
+        put(1, 47);
+        put(2, 110);
+        put(3, 210);
+        put(4, 315);
+        put(5, 316);
+        put(6, 335);
+        put(7, 338);
+        put(8, 5);
+        put(9, 340);
+    }});
+
+    /**
+     * Whether this is a singleplayer recording.
+     */
+    private boolean singleplayer;
+
+    /**
+     * The server address or the singleplayer world name.
+     */
+    private String serverName;
+
+    /**
+     * The server name (as configured by the user in the "Add Server" menu) or the singleplayer world name.
+     * May be absent for older replays or when "Direct Connection" was used.
+     */
+    private String customServerName;
+
+    /**
+     * Duration of the replay in milliseconds.
+     */
+    private int duration;
+
+    /**
+     * Unix timestamp of when the recording was started in milliseconds.
+     */
+    private long date;
+
+    /**
+     * Minecraft version. (E.g. 1.8)
+     */
+    private String mcversion;
+
+    /**
+     * File format. Defaults to 'MCPR'
+     */
+    private String fileFormat;
+
+    /**
+     * Version of the file format.
+     */
+    private int fileFormatVersion;
+
+    /**
+     * Minecraft protocol version. Mandatory for `fileFormatVersion >= 13`.
+     */
+    private Integer protocol;
+
+    /**
+     * The program which generated the file.
+     * Will always be written as "ReplayStudio vXY".
+     */
+    private String generator;
+
+    /**
+     * The entity id of the player manually added to this replay which represents the recording player.
+     * Must be a valid entity id (e.g. must not be -1). May not be set.
+     */
+    private int selfId = -1;
+
+    /**
+     * Array of UUIDs of all players which can be seen in this replay.
+     */
+    private String[] players = new String[0];
+
+    public ReplayMetaData() {
+    }
+
+    public ReplayMetaData(ReplayMetaData other) {
+        singleplayer = other.singleplayer;
+        serverName = other.serverName;
+        customServerName = other.customServerName;
+        duration = other.duration;
+        date = other.date;
+        mcversion = other.mcversion;
+        fileFormat = other.fileFormat;
+        fileFormatVersion = other.fileFormatVersion;
+        generator = other.generator;
+        selfId = other.selfId;
+        players = Arrays.copyOf(other.players, other.players.length);
+    }
+
+    public boolean isSingleplayer() {
+        return this.singleplayer;
+    }
+
+    public String getServerName() {
+        return this.serverName;
+    }
+
+    public String getCustomServerName() {
+        return customServerName;
+    }
+
+    public int getDuration() {
+        return this.duration;
+    }
+
+    public long getDate() {
+        return this.date;
+    }
+
+    public String getMcVersion() {
+        return mcversion;
+    }
+
+    public String getFileFormat() {
+        return this.fileFormat;
+    }
+
+    public int getFileFormatVersion() {
+        return this.fileFormatVersion;
+    }
+
+    public Integer getRawProtocolVersion() {
+        return protocol;
+    }
+
+    public int getRawProtocolVersionOr0() {
+        return protocol != null ? protocol : 0;
+    }
+
+    public ProtocolVersion getProtocolVersion() {
+        return getProtocolVersion(this.fileFormatVersion, this.getRawProtocolVersionOr0());
+    }
+
+    public static ProtocolVersion getProtocolVersion(int fileFormatVersion, int fileProtocol) {
+        // See https://github.com/ReplayMod/ReplayStudio/issues/9#issuecomment-464451582
+        // and https://github.com/ReplayMod/ReplayStudio/issues/9#issuecomment-464456558
+        Integer protocol = fileProtocol != 0 ? fileProtocol : null;
+        if (protocol == null) {
+            protocol = PROTOCOL_FOR_FILE_FORMAT.get(fileFormatVersion);
+            if (protocol == null) {
+                throw new IllegalStateException("Replay files with version 10+ must provide the `protocol` key.");
+            }
+        }
+        return ProtocolVersion.getProtocol(protocol);
+    }
+
+    public String getGenerator() {
+        return this.generator;
+    }
+
+    public int getSelfId() {
+        return this.selfId;
+    }
+
+    public String[] getPlayers() {
+        return this.players;
+    }
+
+    public void setSingleplayer(boolean singleplayer) {
+        this.singleplayer = singleplayer;
+    }
+
+    public void setServerName(String serverName) {
+        this.serverName = serverName;
+    }
+
+    public void setCustomServerName(String customServerName) {
+        this.customServerName = customServerName;
+    }
+
+    public void setDuration(int duration) {
+        this.duration = duration;
+    }
+
+    public void setDate(long date) {
+        this.date = date;
+    }
+
+    public void setMcVersion(String mcVersion) {
+        this.mcversion = mcVersion;
+    }
+
+    public void setFileFormat(String fileFormat) {
+        this.fileFormat = fileFormat;
+    }
+
+    public void setFileFormatVersion(int fileFormatVersion) {
+        this.fileFormatVersion = fileFormatVersion;
+    }
+
+    public void setProtocolVersion(int protocol) {
+        this.protocol = protocol;
+    }
+
+    public void setGenerator(String generator) {
+        this.generator = generator;
+    }
+
+    public void setSelfId(int selfId) {
+        this.selfId = selfId;
+    }
+
+    public void setPlayers(String[] players) {
+        this.players = players;
+    }
+
+    public boolean equals(Object o) {
+        if (o == this) return true;
+        if (!(o instanceof ReplayMetaData)) return false;
+        final ReplayMetaData other = (ReplayMetaData) o;
+        if (!other.canEqual(this)) return false;
+        if (this.singleplayer != other.singleplayer) return false;
+        if (!Objects.equals(this.serverName, other.serverName)) return false;
+        if (!Objects.equals(this.customServerName, other.customServerName)) return false;
+        if (this.duration != other.duration) return false;
+        if (this.date != other.date) return false;
+        if (!Objects.equals(this.mcversion, other.mcversion)) return false;
+        if (!Objects.equals(this.fileFormat, other.fileFormat)) return false;
+        if (this.fileFormatVersion != other.fileFormatVersion) return false;
+        if (this.protocol != other.protocol) return false;
+        if (!Objects.equals(this.generator, other.generator)) return false;
+        if (this.selfId != other.selfId) return false;
+        return Arrays.deepEquals(this.players, other.players);
+    }
+
+    public int hashCode() {
+        int result = 1;
+        result = result * 59 + (this.singleplayer ? 79 : 97);
+        result = result * 59 + (serverName == null ? 0 : serverName.hashCode());
+        result = result * 59 + (customServerName == null ? 0 : customServerName.hashCode());
+        result = result * 59 + this.duration;
+        result = result * 59 + (int) (date >>> 32 ^ date);
+        result = result * 59 + (mcversion == null ? 0 : mcversion.hashCode());
+        result = result * 59 + (fileFormat == null ? 0 : fileFormat.hashCode());
+        result = result * 59 + this.fileFormatVersion;
+        result = result * 59 + this.protocol;
+        result = result * 59 + (generator == null ? 0 : generator.hashCode());
+        result = result * 59 + this.selfId;
+        result = result * 59 + Arrays.deepHashCode(this.players);
+        return result;
+    }
+
+    protected boolean canEqual(Object other) {
+        return other instanceof ReplayMetaData;
+    }
+
+    @Override
+    public String toString() {
+        return "ReplayMetaData{" +
+                "singleplayer=" + singleplayer +
+                ", serverName='" + serverName + '\'' +
+                ", customServerName='" + customServerName + '\'' +
+                ", duration=" + duration +
+                ", date=" + date +
+                ", mcversion='" + mcversion + '\'' +
+                ", fileFormat='" + fileFormat + '\'' +
+                ", fileFormatVersion=" + fileFormatVersion +
+                ", protocol=" + protocol +
+                ", generator='" + generator + '\'' +
+                ", selfId=" + selfId +
+                ", players=" + Arrays.toString(players) +
+                '}';
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/replay/ZipReplayFile.java b/src/main/java/com/replaymod/replaystudio/replay/ZipReplayFile.java
new file mode 100644
index 0000000000000000000000000000000000000000..8160e03a6df97cc68a82a95ee2414b831fe4f465
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/replay/ZipReplayFile.java
@@ -0,0 +1,382 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.replay;
+
+import com.google.common.base.Charsets;
+import com.google.common.base.Optional;
+import com.google.common.io.Closeables;
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.util.Utils;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.*;
+import java.util.regex.Pattern;
+import java.util.zip.CRC32;
+import java.util.zip.GZIPInputStream;
+import java.util.zip.GZIPOutputStream;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipFile;
+import java.util.zip.ZipOutputStream;
+
+import static com.google.common.io.Files.*;
+import static java.nio.file.Files.*;
+import static java.nio.file.Files.move;
+
+public class ZipReplayFile extends AbstractReplayFile {
+
+    private static final String ENTRY_RECORDING_HASH = "recording.tmcpr.crc32";
+
+    private final File input;
+    private final File output;
+    private final File cache;
+
+    // Temporary folder structure
+    private final File tmpFiles;
+    private final File changedFiles;
+    private final File removedFiles;
+    private final File sourceFile;
+
+    private CRC32 recordingCrc;
+
+    /**
+     * Whether the input file path should be written to the tmp folder on next write.
+     */
+    private boolean shouldSaveInputFile;
+
+    private final Map<String, OutputStream> outputStreams = new HashMap<>();
+    private final Map<String, File> changedEntries = new HashMap<>();
+    private final Set<String> removedEntries = new HashSet<>();
+
+    private ZipFile zipFile;
+
+    public ZipReplayFile(Studio studio, File file) throws IOException {
+        this(studio, file, file);
+    }
+
+    public ZipReplayFile(Studio studio, File input, File output) throws IOException {
+        this(studio, input, output, new File(output.getParentFile(), output.getName() + ".cache"));
+    }
+
+    public ZipReplayFile(Studio studio, File input, File output, File cache) throws IOException {
+        super(studio);
+
+        tmpFiles = new File(output.getParentFile(), output.getName() + ".tmp");
+        changedFiles = new File(tmpFiles, "changed");
+        removedFiles = new File(tmpFiles, "removed");
+        sourceFile = new File(tmpFiles, "source");
+
+        if (input != null && input.exists()) {
+            // Save input file path in case of crash
+            shouldSaveInputFile = true;
+        } else if (input == null && sourceFile.exists()) {
+            // Recover input file
+            input = new File(new String(readAllBytes(sourceFile.toPath()), Charsets.UTF_8));
+            if (!input.exists()) {
+                throw new IOException("Recovered source file no longer exists.");
+            }
+        }
+
+        this.output = output;
+        this.input = input;
+        this.cache = cache;
+
+        if (input != null && input.exists()) {
+            this.zipFile = new ZipFile(input);
+        }
+/*
+        // Try to restore any changes if we weren't able to save them last time
+        if (changedFiles.exists()) {
+            fileTreeTraverser()
+                    .breadthFirstTraversal(changedFiles)
+                    .filter(isFile())
+                    .forEach(f -> changedEntries.put(changedFiles.toURI().relativize(f.toURI()).getPath(), f));
+        }
+        if (removedFiles.exists()) {
+            fileTreeTraverser()
+                    .breadthFirstTraversal(removedFiles)
+                    .filter(isFile())
+                    .transform(f -> removedFiles.toURI().relativize(f.toURI()).getPath())
+                    .forEach(removedEntries::add);
+        }
+*/ // Doesn't compile
+        // Validate cache
+        String cacheHash = null;
+        String mcprHash = null;
+
+        Optional<InputStream> cacheIn = getCache(ENTRY_RECORDING_HASH);
+        if (cacheIn.isPresent()) {
+            try (InputStream in = cacheIn.get();
+                 Reader rin = new InputStreamReader(in);
+                 BufferedReader brin = new BufferedReader(rin)) {
+                cacheHash = brin.readLine();
+            } catch (IOException ignored) {}
+        }
+
+        Optional<InputStream> mcprIn = get(ENTRY_RECORDING_HASH);
+        if (mcprIn.isPresent()) {
+            try (InputStream in = mcprIn.get();
+                 Reader rin = new InputStreamReader(in);
+                 BufferedReader brin = new BufferedReader(rin)) {
+                mcprHash = brin.readLine();
+            } catch (IOException ignored) {}
+        }
+
+        if (!Objects.equals(cacheHash, mcprHash)) {
+            delete(cache);
+            createCache(mcprHash);
+        }
+    }
+
+    private void createCache(String hash) throws IOException {
+        if (hash == null) return; // legacy replay without hash entry, should get one when recording data is re-written
+        try (OutputStream out = writeCache(ENTRY_RECORDING_HASH);
+             Writer writer = new OutputStreamWriter(out)) {
+            writer.write(hash);
+        }
+    }
+
+    /**
+     * Saves the input file path to the source file in the temp folder structure.
+     * @throws IOException
+     */
+    private void saveInputFile() throws IOException {
+        if (shouldSaveInputFile) {
+            createParentDirs(sourceFile);
+            try (OutputStream out = new BufferedOutputStream(new FileOutputStream(sourceFile))) {
+                out.write(input.getCanonicalPath().getBytes(Charsets.UTF_8));
+            }
+            shouldSaveInputFile = false;
+        }
+    }
+
+    @Override
+    public Optional<InputStream> get(String entry) throws IOException {
+        if (changedEntries.containsKey(entry)) {
+            return Optional.of(new BufferedInputStream(new FileInputStream(changedEntries.get(entry))));
+        }
+        if (zipFile == null || removedEntries.contains(entry)) {
+            return Optional.absent();
+        }
+        ZipEntry zipEntry = zipFile.getEntry(entry);
+        if (zipEntry == null) {
+            return Optional.absent();
+        }
+        return Optional.of(new BufferedInputStream(zipFile.getInputStream(zipEntry)));
+    }
+
+    @Override
+    public Optional<InputStream> getCache(String entry) throws IOException {
+        Path path = cache.toPath().resolve(entry);
+        if (!Files.exists(path)) {
+            return Optional.absent();
+        }
+        InputStream rawIn = new BufferedInputStream(Files.newInputStream(path));
+        try {
+            return Optional.of(new GZIPInputStream(rawIn));
+        } catch (IOException e) {
+            Closeables.closeQuietly(rawIn);
+            return Optional.absent();
+        }
+    }
+
+    @Override
+    public Map<String, InputStream> getAll(Pattern pattern) throws IOException {
+        Map<String, InputStream> streams = new HashMap<>();
+
+        for (Map.Entry<String, File> entry : changedEntries.entrySet()) {
+            String name = entry.getKey();
+            if (pattern.matcher(name).matches()) {
+                streams.put(name, new BufferedInputStream(new FileInputStream(changedEntries.get(name))));
+            }
+        }
+
+        if (zipFile != null) {
+            Enumeration<? extends ZipEntry> entries = zipFile.entries();
+            while (entries.hasMoreElements()) {
+                ZipEntry entry = entries.nextElement();
+                String name = entry.getName();
+                if (pattern.matcher(name).matches()) {
+                    if (!streams.containsKey(name) && !removedEntries.contains(name)) {
+                        streams.put(name, new BufferedInputStream(zipFile.getInputStream(entry)));
+                    }
+                }
+            }
+        }
+
+        return streams;
+    }
+
+    @Override
+    public OutputStream write(String entry) throws IOException {
+        saveInputFile();
+        File file = changedEntries.get(entry);
+        if (file == null) {
+            file = new File(changedFiles, entry);
+            createParentDirs(file);
+            changedEntries.put(entry, file);
+        }
+        OutputStream out = new BufferedOutputStream(new FileOutputStream(file));
+        Closeables.close(outputStreams.put(entry, out), true);
+        if (removedEntries.remove(entry)) {
+            deleteIfExists(new File(removedFiles, entry).toPath());
+        }
+        if (ENTRY_RECORDING.equals(entry)) {
+            // Immediately invalidate old hash in case we crash during writing
+            try (OutputStream os = ZipReplayFile.this.write(ENTRY_RECORDING_HASH);
+                 Writer writer = new OutputStreamWriter(os)) {
+                writer.write("invalid");
+            }
+
+            // Compute new hash
+            recordingCrc = new CRC32();
+            OutputStream inner = out;
+            out = new OutputStream() {
+                @Override
+                public void write(int i) throws IOException {
+                    recordingCrc.update(i);
+                    inner.write(i);
+                }
+
+                @Override
+                public void write(byte[] b, int off, int len) throws IOException {
+                    recordingCrc.update(b, off, len);
+                    inner.write(b, off, len);
+                }
+
+                @Override
+                public void flush() throws IOException {
+                    inner.flush();
+                }
+
+                @Override
+                public void close() throws IOException {
+                    inner.close();
+
+                    String crc = "" + recordingCrc.getValue();
+                    recordingCrc = null;
+
+                    // Write new hash
+                    try (OutputStream out = ZipReplayFile.this.write(ENTRY_RECORDING_HASH);
+                         Writer writer = new OutputStreamWriter(out)) {
+                        writer.write(crc);
+                    }
+
+                    // Invalidate cache
+                    delete(cache);
+                    createCache(String.valueOf(crc));
+                }
+            };
+        }
+        return out;
+    }
+
+    @Override
+    public OutputStream writeCache(String entry) throws IOException {
+        Path path = cache.toPath().resolve(entry);
+        Files.createDirectories(path.getParent());
+        return new GZIPOutputStream(new BufferedOutputStream(Files.newOutputStream(path)));
+    }
+
+    @Override
+    public void remove(String entry) throws IOException {
+        saveInputFile();
+        Closeables.close(outputStreams.remove(entry), true);
+        File file = changedEntries.remove(entry);
+        if (file != null && file.exists()) {
+            delete(file);
+        }
+        removedEntries.add(entry);
+        File removedFile = new File(removedFiles, entry);
+        createParentDirs(removedFile);
+        touch(removedFile);
+    }
+
+    @Override
+    public void removeCache(String entry) throws IOException {
+        Path path = cache.toPath().resolve(entry);
+        Files.deleteIfExists(path);
+    }
+
+    @Override
+    public void save() throws IOException {
+        if (zipFile != null && changedEntries.isEmpty() && removedEntries.isEmpty()) {
+            return; // No changes, no need to save
+        }
+        File outputFile = createTempFile("replaystudio", "replayfile").toFile();
+        saveTo(outputFile);
+        close();
+        if (output.exists()) {
+            delete(output);
+        }
+        move(outputFile.toPath(), output.toPath());
+        zipFile = new ZipFile(output);
+    }
+
+    @Override
+    public void saveTo(File target) throws IOException {
+        for (OutputStream out : outputStreams.values()) {
+            Closeables.close(out, false);
+        }
+        outputStreams.clear();
+
+        try (ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(target)))) {
+            if (zipFile != null) {
+                for (ZipEntry entry : Collections.list(zipFile.entries())) {
+                    if (!changedEntries.containsKey(entry.getName()) && !removedEntries.contains(entry.getName())) {
+                        entry = new ZipEntry(entry);
+                        entry.setCompressedSize(-1);
+                        out.putNextEntry(entry);
+                        Utils.copy(zipFile.getInputStream(entry), out);
+                    }
+                }
+            }
+            for (Map.Entry<String, File> e : changedEntries.entrySet()) {
+                out.putNextEntry(new ZipEntry(e.getKey()));
+                Utils.copy(new BufferedInputStream(new FileInputStream(e.getValue())), out);
+            }
+        }
+    }
+
+    @Override
+    public void close() throws IOException {
+        if (zipFile != null) {
+            zipFile.close();
+        }
+        for (OutputStream out : outputStreams.values()) {
+            Closeables.close(out, true);
+        }
+        outputStreams.clear();
+
+        changedEntries.clear();
+        removedEntries.clear();
+        delete(tmpFiles);
+    }
+
+    private void delete(File file) throws IOException {
+        File[] children = file.listFiles();
+        if (children != null) {
+            for (File child : children) {
+                delete(child);
+            }
+        }
+        Files.deleteIfExists(file.toPath());
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/stream/AbstractPacketStream.java b/src/main/java/com/replaymod/replaystudio/stream/AbstractPacketStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..4af0771f5f70450a46387760841e916cb1977055
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/stream/AbstractPacketStream.java
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.stream;
+
+import com.google.common.base.Supplier;
+import com.google.common.collect.Lists;
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.filter.StreamFilter;
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+import java.util.*;
+
+import static com.google.common.base.Preconditions.checkNotNull;
+
+public abstract class AbstractPacketStream implements PacketStream {
+
+    public static AbstractPacketStream of(Supplier<PacketData> supplier) {
+        return new AbstractPacketStreamImpl(supplier);
+    }
+
+    private static final class AbstractPacketStreamImpl extends AbstractPacketStream {
+        private final Supplier<PacketData> supplier;
+
+        public AbstractPacketStreamImpl(Supplier<PacketData> supplier) {
+            this.supplier = supplier;
+        }
+
+        @Override
+        public void start() {
+
+        }
+
+        @Override
+        protected void cleanup() {
+
+        }
+
+        @Override
+        protected PacketData nextInput() {
+            return supplier.get();
+        }
+    }
+
+    private class PacketStreamContext implements PacketStream {
+        private final StreamElement element;
+
+        public PacketStreamContext(StreamElement element) {
+            this.element = checkNotNull(element);
+        }
+
+        @Override
+        public void insert(PacketData packet) {
+            element.inserted.add(packet);
+        }
+
+        @Override
+        public void insert(long time, Packet packet) {
+            element.inserted.add(new PacketData(time, packet));
+        }
+
+        @Override
+        public void addFilter(StreamFilter filter) {
+            AbstractPacketStream.this.addFilter(filter);
+        }
+
+        @Override
+        public void addFilter(StreamFilter filter, long from, long to) {
+            AbstractPacketStream.this.addFilter(filter, from, to);
+        }
+
+        @Override
+        public void removeFilter(StreamFilter filter) {
+            AbstractPacketStream.this.removeFilter(filter);
+        }
+
+        @Override
+        public Collection<FilterInfo> getFilters() {
+            return AbstractPacketStream.this.getFilters();
+        }
+
+        @Override
+        public PacketData next() {
+            throw new IllegalStateException("Cannot get next data from within stream pipeline");
+        }
+
+        @Override
+        public void start() {
+            throw new IllegalStateException("Cannot start from within stream pipeline");
+        }
+
+        @Override
+        public List<PacketData> end() {
+            throw new IllegalStateException("Cannot end from within stream pipeline");
+        }
+    }
+
+    private class StreamElement {
+        private final FilterInfo filter;
+        private final PacketStreamContext context = new PacketStreamContext(this);
+        private final Queue<PacketData> inserted = new LinkedList<>();
+        private boolean active;
+        private long lastTimestamp;
+        private StreamElement next;
+
+        /**
+         * When using this constructor make sure to override {@link #process(PacketData)} as it will throw NPE otherwise.
+         */
+        protected StreamElement() {
+            filter = null;
+        }
+
+        public StreamElement(FilterInfo filter) {
+            this.filter = checkNotNull(filter);
+        }
+
+        public void process(PacketData data) throws IOException {
+            boolean keep = true;
+            if (data != null && filter.applies(data.getTime())) {
+                if (!active) {
+                    filter.getFilter().onStart(context);
+                    active = true;
+                }
+                keep = filter.getFilter().onPacket(context, data);
+                if (!keep) {
+                    data.getPacket().getBuf().release();
+                }
+            } else if (active) {
+                filter.getFilter().onEnd(context, lastTimestamp);
+                active = false;
+                for (PacketData d : inserted) {
+                    if (d.getTime() > lastTimestamp) {
+                        lastTimestamp = d.getTime();
+                    }
+                    next.process(d);
+                }
+                inserted.clear();
+            }
+            if (data != null && keep) {
+                if (data.getTime() > lastTimestamp) {
+                    lastTimestamp = data.getTime();
+                }
+                next.process(data);
+            }
+            for (PacketData d : inserted) {
+                if (d.getTime() > lastTimestamp) {
+                    lastTimestamp = d.getTime();
+                }
+                next.process(d);
+            }
+            inserted.clear();
+            if (data == null) {
+                next.process(null);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return (active ? "" : "in") + "active " + filter;
+        }
+    }
+
+    private class StreamElementEnd extends StreamElement {
+        public StreamElementEnd() {
+            super();
+        }
+
+        @Override
+        public void process(PacketData data) {
+            if (data != null) {
+                AbstractPacketStream.this.inserted.add(data);
+            }
+        }
+
+        @Override
+        public String toString() {
+            return "Out";
+        }
+    }
+
+    private final Queue<PacketData> inserted = new LinkedList<>();
+    private final List<StreamElement> filters = new ArrayList<>();
+
+    private StreamElement firstElement;
+
+    @Override
+    public void insert(PacketData packet) {
+        inserted.add(packet);
+    }
+
+    @Override
+    public void insert(long time, Packet packet) {
+        inserted.add(new PacketData(time, packet));
+    }
+
+    private void buildPipe() {
+        Iterator<StreamElement> iter = filters.iterator();
+        StreamElement l = null;
+        while (iter.hasNext()) {
+            StreamElement e = iter.next();
+            if (l == null) {
+                firstElement = e;
+            } else {
+                l.next = e;
+            }
+            l = e;
+        }
+        if (l == null) {
+            firstElement = new StreamElementEnd();
+        } else {
+            l.next = new StreamElementEnd();
+        }
+    }
+
+    @Override
+    public void addFilter(StreamFilter filter) {
+        addFilter(filter, -1, -1);
+    }
+
+    @Override
+    public void addFilter(StreamFilter filter, long from, long to) {
+        filters.add(new StreamElement(new FilterInfo(filter, from, to)));
+        buildPipe();
+    }
+
+    @Override
+    public void removeFilter(StreamFilter filter) {
+        Iterator<StreamElement> iter = filters.iterator();
+        while (iter.hasNext()) {
+            if (filter == iter.next().filter.getFilter()) {
+                iter.remove();
+            }
+        }
+        buildPipe();
+    }
+
+    protected abstract PacketData nextInput();
+
+    @Override
+    public PacketData next() throws IOException {
+        while (inserted.isEmpty()) {
+            PacketData next = nextInput();
+            if (next == null) {
+                break;
+            }
+            firstElement.process(next);
+        }
+        return inserted.poll();
+    }
+
+    @Override
+    public Collection<FilterInfo> getFilters() {
+        return Collections.unmodifiableList(Lists.transform(filters, (e) -> e.filter));
+    }
+
+    @Override
+    public List<PacketData> end() throws IOException {
+        firstElement.process(null);
+        List<PacketData> result = new LinkedList<>(inserted);
+        inserted.clear();
+        return result;
+    }
+
+    /**
+     * Clean up this packet stream (e.g. close input streams, etc.)
+     */
+    protected abstract void cleanup();
+
+    @Override
+    public String toString() {
+        StringBuilder sb = new StringBuilder("PacketStream[");
+        StreamElement e = firstElement;
+        while (e != null) {
+            sb.append(e);
+            if (e.next != null) {
+                sb.append(" -> ");
+            }
+            e = e.next;
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/stream/IteratorStream.java b/src/main/java/com/replaymod/replaystudio/stream/IteratorStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..43b6d43c1671ffc9d3e396d95745d31e1f5c70bf
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/stream/IteratorStream.java
@@ -0,0 +1,151 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.stream;
+
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.filter.StreamFilter;
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+import java.util.*;
+
+/**
+ * A stream wrapper for list iterators. Only supports a single filter.
+ */
+public class IteratorStream implements PacketStream {
+
+    private final ListIterator<PacketData> iterator;
+    private final List<PacketData> added = new ArrayList<>();
+    private final FilterInfo filter;
+    private boolean filterActive;
+    private boolean processing;
+    private long lastTimestamp = -1;
+
+    public IteratorStream(ListIterator<PacketData> iterator, StreamFilter filter) {
+        this(iterator, new FilterInfo(filter, -1, -1));
+    }
+
+    public IteratorStream(ListIterator<PacketData> iterator, FilterInfo filter) {
+        this.iterator = iterator;
+        this.filter = filter;
+    }
+
+    @Override
+    public void insert(PacketData packet) {
+        if (processing) {
+            added.add(packet);
+        } else {
+            iterator.add(packet);
+        }
+        if (packet.getTime() > lastTimestamp) {
+            lastTimestamp = packet.getTime();
+        }
+    }
+
+    @Override
+    public void insert(long time, Packet packet) {
+        insert(new PacketData(time, packet));
+    }
+
+    @Override
+    public void addFilter(StreamFilter filter) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void addFilter(StreamFilter filter, long from, long to) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void removeFilter(StreamFilter filter) {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean hasNext() {
+        return iterator.hasNext();
+    }
+
+    @Override
+    public PacketData next() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Collection<FilterInfo> getFilters() {
+        return Arrays.asList(filter);
+    }
+
+    public void processNext() throws IOException {
+        processing = true;
+
+        PacketData next = iterator.next();
+        boolean keep = true;
+        if ((filter.getFrom() == -1 || filter.getFrom() <= next.getTime())
+                && (filter.getTo() == -1 || filter.getFrom() >= next.getTime())) {
+            if (!filterActive) {
+                filter.getFilter().onStart(this);
+                filterActive = true;
+            }
+            keep = filter.getFilter().onPacket(this, next);
+        } else if (filterActive) {
+            filter.getFilter().onEnd(this, lastTimestamp);
+            filterActive = false;
+        }
+        if (!keep) {
+            iterator.remove();
+            next.getPacket().getBuf().release();
+            if (lastTimestamp == -1) {
+                lastTimestamp = next.getTime();
+            }
+        } else {
+            if (next.getTime() > lastTimestamp) {
+                lastTimestamp = next.getTime();
+            }
+        }
+
+        for (PacketData data : added) {
+            iterator.add(data);
+        }
+        added.clear();
+        processing = false;
+    }
+
+    public void processAll() throws IOException {
+        while (hasNext()) {
+            processNext();
+        }
+
+        end();
+    }
+
+    @Override
+    public void start() {
+
+    }
+
+    @Override
+    public List<PacketData> end() throws IOException {
+        if (filterActive) {
+            filterActive = false;
+            filter.getFilter().onEnd(this, lastTimestamp);
+        }
+        return Collections.unmodifiableList(added);
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/stream/PacketStream.java b/src/main/java/com/replaymod/replaystudio/stream/PacketStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..b183c5cb4569ea9037da939b4599dd4086c455f4
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/stream/PacketStream.java
@@ -0,0 +1,178 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.stream;
+
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.filter.StreamFilter;
+import com.replaymod.replaystudio.protocol.Packet;
+
+import java.io.IOException;
+import java.util.Collection;
+import java.util.List;
+import java.util.Objects;
+
+/**
+ * Represents a stream of packets.
+ */
+public interface PacketStream {
+
+    /**
+     * Information on the time frame for which a filter should apply and the filter itself.
+     */
+    public static class FilterInfo {
+        /**
+         * The filter.
+         */
+        private final StreamFilter filter;
+
+        /**
+         * Timestamp (milliseconds) from which this filter should apply (inclusive).
+         * A value of -1 means that it should apply right from the start.
+         */
+        private final long from;
+
+        /**
+         * Timestamp (milliseconds) up to which this filter should apply (inclusive).
+         * A value of -1 means that it should apply up until the end.
+         */
+        private final long to;
+
+        public FilterInfo(StreamFilter filter, long from, long to) {
+            this.filter = filter;
+            this.from = from;
+            this.to = to;
+        }
+
+        /**
+         * Returns whether this filter should be applied at the specified timestamp.
+         * @param time The timestamp (milliseconds)
+         * @return {@code true} if this filter should apply, {@code false} otherwise
+         */
+        public boolean applies(long time) {
+            return (from == -1 || from <= time) && (to == -1 || to >= time);
+        }
+
+        public StreamFilter getFilter() {
+            return this.filter;
+        }
+
+        public long getFrom() {
+            return this.from;
+        }
+
+        public long getTo() {
+            return this.to;
+        }
+
+        public boolean equals(Object o) {
+            if (o == this) return true;
+            if (!(o instanceof FilterInfo)) return false;
+            final FilterInfo other = (FilterInfo) o;
+            if (!other.canEqual(this)) return false;
+            if (!Objects.equals(this.filter, other.filter)) return false;
+            if (this.from != other.from) return false;
+            if (this.to != other.to) return false;
+            return true;
+        }
+
+        public int hashCode() {
+            int result = 1;
+            result = result * 59 + (filter == null ? 0 : filter.hashCode());
+            result = result * 59 + (int) (from >>> 32 ^ from);
+            result = result * 59 + (int) (to >>> 32 ^ to);
+            return result;
+        }
+
+        protected boolean canEqual(Object other) {
+            return other instanceof FilterInfo;
+        }
+
+        public String toString() {
+            return "FilterInfo(filter=" + this.filter + ", from=" + this.from + ", to=" + this.to + ")";
+        }
+    }
+
+    /**
+     * Inserts a new packet into this stream.
+     * If called from {@link StreamFilter#onPacket(PacketStream, PacketData)}, this inserts the packet after the packet
+     * that is being processed. This behavior can be changed by canceling the packet that is being processed and
+     * inserting it manually using this method.
+     * @param packet The packet
+     * @see #insert(long, Packet)
+     */
+    void insert(PacketData packet);
+
+    /**
+     * Inserts a new packet into this stream at the specified time.
+     * If called from {@link StreamFilter#onPacket(PacketStream, PacketData)}, this inserts the packet after the packet
+     * that is being processed. This behavior can be changed by canceling the packet that is being processed and
+     * inserting it manually using this method.
+     * @param time The timestamp
+     * @param packet The packet
+     * @see #insert(PacketData)
+     */
+    void insert(long time, Packet packet);
+
+    /**
+     * Adds a new filter to this packet stream.
+     * @param filter The filter
+     */
+    void addFilter(StreamFilter filter);
+
+    /**
+     * Adds a new filter to this packet stream.
+     * Only applies the filter within the specified bounds (inclusive).
+     * A timestamp of -1 does not limit the duration.
+     * @param filter The filter
+     * @param from Timestamp from which to apply the filter
+     * @param to Timestamp to which to apply the filter
+     */
+    void addFilter(StreamFilter filter, long from, long to);
+
+    /**
+     * Removes a filter from this packet stream.
+     * @param filter The filter
+     */
+    void removeFilter(StreamFilter filter);
+
+    /**
+     * Returns all filters in the order they were added.
+     * @return Unmodifiable list of filters
+     */
+    Collection<FilterInfo> getFilters();
+
+    /**
+     * Retrieves the next element in this stream applying all filters.
+     * @return The next packet or {@code null} if the end of the stream has been reached
+     */
+    PacketData next() throws IOException;
+
+    /**
+     * Starts this packet stream (e.g. opening input streams, etc.).
+     */
+    void start();
+
+    /**
+     * Ends this packet stream by calling the {@link StreamFilter#onEnd(PacketStream, long)} method for every filter
+     * still active and then performing cleanup (e.g. closing input streams, etc).
+     * @return Excess packets generated during this call.
+     */
+    List<PacketData> end() throws IOException;
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/stream/VoidPacketStream.java b/src/main/java/com/replaymod/replaystudio/stream/VoidPacketStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..e6901188aa7a61e8ec67a33c40f4eddbc1521952
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/stream/VoidPacketStream.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.stream;
+
+public class VoidPacketStream {
+}
diff --git a/src/main/java/com/replaymod/replaystudio/studio/ReplayStudio.java b/src/main/java/com/replaymod/replaystudio/studio/ReplayStudio.java
new file mode 100644
index 0000000000000000000000000000000000000000..e5552ae54304e70e6d536b1d6999b3d2d6c2691d
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/studio/ReplayStudio.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.studio;
+
+import com.replaymod.replaystudio.Studio;
+import com.replaymod.replaystudio.filter.StreamFilter;
+import com.replaymod.replaystudio.replay.ReplayMetaData;
+import com.replaymod.replaystudio.viaversion.ViaVersionPacketConverter;
+
+import java.util.ServiceLoader;
+
+public class ReplayStudio implements Studio {
+
+    private final ServiceLoader<StreamFilter> streamFilterServiceLoader = ServiceLoader.load(StreamFilter.class);
+
+    @Override
+    public String getName() {
+        return "ReplayStudio";
+    }
+
+    @Override
+    public int getVersion() {
+        return 1;
+    }
+
+    @Override
+    public StreamFilter loadStreamFilter(String name) {
+        for (StreamFilter filter : streamFilterServiceLoader) {
+            if (filter.getName().equalsIgnoreCase(name)) {
+                try {
+                    // Create a new instance of the filter
+                    return filter.getClass().newInstance();
+                } catch (InstantiationException | IllegalAccessException e) {
+                    throw new RuntimeException(e);
+                }
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public boolean isCompatible(int fileVersion, int protocolVersion, int currentVersion) {
+        return ViaVersionPacketConverter.isFileVersionSupported(fileVersion, protocolVersion, currentVersion);
+    }
+
+    @Override
+    public int getCurrentFileFormatVersion() {
+        return ReplayMetaData.CURRENT_FILE_FORMAT_VERSION;
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/studio/StudioPacketStream.java b/src/main/java/com/replaymod/replaystudio/studio/StudioPacketStream.java
new file mode 100644
index 0000000000000000000000000000000000000000..3afaaf12923ec650f773b040fc20ed177388c8d9
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/studio/StudioPacketStream.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.studio;
+
+import com.replaymod.replaystudio.PacketData;
+import com.replaymod.replaystudio.io.ReplayInputStream;
+import com.replaymod.replaystudio.stream.AbstractPacketStream;
+
+import java.io.IOException;
+
+public class StudioPacketStream extends AbstractPacketStream {
+
+    private final ReplayInputStream in;
+
+    public StudioPacketStream(ReplayInputStream in) {
+        this.in = in;
+    }
+
+    @Override
+    protected PacketData nextInput() {
+        try {
+            return in.readPacket();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void start() {
+
+    }
+
+    @Override
+    protected void cleanup() {
+        try {
+            in.close();
+        } catch (IOException e) {
+            e.printStackTrace();
+        }
+    }
+
+}
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/CustomConnectionManager.java b/src/main/java/com/replaymod/replaystudio/viaversion/CustomConnectionManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..eca06eb1ba9c3431adbbee3e63d54951aa454a96
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/CustomConnectionManager.java
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+
+package com.replaymod.replaystudio.viaversion;
+
+import com.viaversion.viaversion.api.connection.ConnectionManager;
+import com.viaversion.viaversion.api.connection.UserConnection;
+
+import java.util.Collections;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
+
+public class CustomConnectionManager implements ConnectionManager {
+
+    @Override
+    public boolean isClientConnected(UUID uuid) {
+        return getConnectedClient(uuid) != null;
+    }
+
+    @Override
+    public UserConnection getConnectedClient(UUID uuid) {
+        UserConnection user = CustomViaAPI.INSTANCE.get().user();
+        if (uuid.equals(user.getProtocolInfo().getUuid())) {
+            return user;
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public UUID getConnectedClientId(UserConnection userConnection) {
+        return userConnection.getProtocolInfo().getUuid();
+    }
+
+    @Override
+    public Set<UserConnection> getConnections() {
+        return Collections.singleton(CustomViaAPI.INSTANCE.get().user());
+    }
+
+    @Override
+    public Map<UUID, UserConnection> getConnectedClients() {
+        UserConnection user = CustomViaAPI.INSTANCE.get().user();
+        UUID uuid = user.getProtocolInfo().getUuid();
+        return Collections.singletonMap(uuid, user);
+    }
+
+    @Override
+    public void onLoginSuccess(UserConnection userConnection) {
+    }
+
+    @Override
+    public void onDisconnect(UserConnection userConnection) {
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaAPI.java b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaAPI.java
new file mode 100644
index 0000000000000000000000000000000000000000..56ac35412f342b43d9c933f1516c7a07ecb37b97
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaAPI.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.viaversion;
+
+import io.netty.buffer.ByteBuf;
+import com.viaversion.viaversion.ViaAPIBase;
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.connection.UserConnection;
+
+import java.util.SortedSet;
+import java.util.UUID;
+
+class CustomViaAPI extends ViaAPIBase<Void> {
+    static final ThreadLocal<CustomViaAPI> INSTANCE = new ThreadLocal<>();
+
+    private final int sourceVersion;
+    private final UserConnection userConnection;
+
+    CustomViaAPI(int sourceVersion, UserConnection userConnection) {
+        this.sourceVersion = sourceVersion;
+        this.userConnection = userConnection;
+    }
+
+    UserConnection user() {
+        return userConnection;
+    }
+
+    @Override
+    public int getPlayerVersion(Void aVoid) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public int getPlayerVersion(UUID uuid) {
+        if (uuid.equals(userConnection.getProtocolInfo().getUuid())) {
+            return sourceVersion;
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isInjected(UUID uuid) {
+        return sourceVersion >= 107;
+    }
+
+    @Override
+    public String getVersion() {
+        return Via.getPlatform().getPluginVersion();
+    }
+
+    @Override
+    public void sendRawPacket(Void aVoid, ByteBuf byteBuf) throws IllegalArgumentException {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void sendRawPacket(UUID uuid, ByteBuf byteBuf) throws IllegalArgumentException {
+        if (uuid.equals(userConnection.getProtocolInfo().getUuid())) {
+            userConnection.sendRawPacket(byteBuf);
+            return;
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public SortedSet<Integer> getSupportedVersions() {
+        return Via.getManager().getProtocolManager().getSupportedVersions();
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaConfig.java b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..d5a88dd21ec997cb6b2d7482becaa288a2983764
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaConfig.java
@@ -0,0 +1,348 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.viaversion;
+
+import com.viaversion.viaversion.api.configuration.ViaVersionConfig;
+import com.viaversion.viaversion.api.minecraft.WorldIdentifiers;
+import com.viaversion.viaversion.api.protocol.version.BlockedProtocolVersions;
+import com.viaversion.viaversion.libs.fastutil.ints.IntSet;
+import com.viaversion.viaversion.libs.gson.JsonElement;
+import com.viaversion.viaversion.protocol.BlockedProtocolVersionsImpl;
+
+import java.util.Collections;
+import java.util.Map;
+
+// Configured as per recommendations at https://docs.viaversion.com/display/VIAVERSION/Configuration
+public class CustomViaConfig implements ViaVersionConfig {
+    @Override
+    public boolean isCheckForUpdates() {
+        return false;
+    }
+
+    @Override
+    public void setCheckForUpdates(boolean b) {
+    }
+
+    @Override
+    public boolean isPreventCollision() {
+        return false;
+    }
+
+    @Override
+    public boolean isNewEffectIndicator() {
+        return false;
+    }
+
+    @Override
+    public boolean isShowNewDeathMessages() {
+        return false;
+    }
+
+    @Override
+    public boolean isSuppressMetadataErrors() {
+        return true;
+    }
+
+    @Override
+    public boolean isShieldBlocking() {
+        return false;
+    }
+
+    @Override
+    public boolean isNoDelayShieldBlocking() {
+        return false;
+    }
+
+    @Override
+    public boolean isShowShieldWhenSwordInHand() {
+        return false;
+    }
+
+    @Override
+    public boolean isHologramPatch() {
+        return true;
+    }
+
+    @Override
+    public boolean isPistonAnimationPatch() {
+        return false;
+    }
+
+    @Override
+    public boolean isBossbarPatch() {
+        return true;
+    }
+
+    @Override
+    public boolean isBossbarAntiflicker() {
+        return false;
+    }
+
+    @Override
+    public double getHologramYOffset() {
+        return -0.96;
+    }
+
+    @Override
+    public boolean isAutoTeam() {
+        return false;
+    }
+
+    @Override
+    public int getMaxPPS() {
+        return -1;
+    }
+
+    @Override
+    public String getMaxPPSKickMessage() {
+        return null;
+    }
+
+    @Override
+    public int getTrackingPeriod() {
+        return -1;
+    }
+
+    @Override
+    public int getWarningPPS() {
+        return -1;
+    }
+
+    @Override
+    public int getMaxWarnings() {
+        return -1;
+    }
+
+    @Override
+    public String getMaxWarningsKickMessage() {
+        return null;
+    }
+
+    @Override
+    public boolean isSendSupportedVersions() {
+        return false;
+    }
+
+    @Override
+    public boolean isSimulatePlayerTick() {
+        return false;
+    }
+
+    @Override
+    public boolean isItemCache() {
+        return false;
+    }
+
+    @Override
+    public boolean isNMSPlayerTicking() {
+        return false;
+    }
+
+    @Override
+    public boolean isReplacePistons() {
+        return false;
+    }
+
+    @Override
+    public int getPistonReplacementId() {
+        return -1;
+    }
+
+    @Override
+    public boolean isChunkBorderFix() {
+        return true;
+    }
+
+    @Override
+    public boolean isForceJsonTransform() {
+        return false;
+    }
+
+    @Override
+    public boolean is1_12NBTArrayFix() {
+        return true;
+    }
+
+    @Override
+    public boolean is1_13TeamColourFix() {
+        return true;
+    }
+
+    @Override
+    public boolean shouldRegisterUserConnectionOnJoin() {
+        return false;
+    }
+
+    @Override
+    public boolean is1_12QuickMoveActionFix() {
+        return false;
+    }
+
+    @Override
+    public BlockedProtocolVersions blockedProtocolVersions() {
+        return new BlockedProtocolVersionsImpl(IntSet.of(), 0, 0);
+    }
+
+    @Override
+    public String getBlockedDisconnectMsg() {
+        return null;
+    }
+
+    @Override
+    public String getReloadDisconnectMsg() {
+        return null;
+    }
+
+    @Override
+    public boolean isSuppressConversionWarnings() {
+        return false;
+    }
+
+    @Override
+    public boolean isDisable1_13AutoComplete() {
+        return false;
+    }
+
+    @Override
+    public boolean isMinimizeCooldown() {
+        return true;
+    }
+
+    @Override
+    public boolean isServersideBlockConnections() {
+        return true;
+    }
+
+    @Override
+    public String getBlockConnectionMethod() {
+        return "packet";
+    }
+
+    @Override
+    public boolean isReduceBlockStorageMemory() {
+        return false;
+    }
+
+    @Override
+    public boolean isStemWhenBlockAbove() {
+        return true;
+    }
+
+    @Override
+    public boolean isVineClimbFix() {
+        return false;
+    }
+
+    @Override
+    public boolean isSnowCollisionFix() {
+        return false;
+    }
+
+    @Override
+    public boolean isInfestedBlocksFix() {
+        return false;
+    }
+
+    @Override
+    public int get1_13TabCompleteDelay() {
+        return 0;
+    }
+
+    @Override
+    public boolean isTruncate1_14Books() {
+        return false;
+    }
+
+    @Override
+    public boolean isLeftHandedHandling() {
+        return true;
+    }
+
+    @Override
+    public boolean is1_9HitboxFix() {
+        return true;
+    }
+
+    @Override
+    public boolean is1_14HitboxFix() {
+        return true;
+    }
+
+    @Override
+    public boolean isNonFullBlockLightFix() {
+        return false;
+    }
+
+    @Override
+    public boolean is1_14HealthNaNFix() {
+        return true;
+    }
+
+    @Override
+    public boolean is1_15InstantRespawn() {
+        return false;
+    }
+
+    @Override
+    public boolean isIgnoreLong1_16ChannelNames() {
+        return false;
+    }
+
+    @Override
+    public boolean isForcedUse1_17ResourcePack() {
+        return false;
+    }
+
+    @Override
+    public JsonElement get1_17ResourcePackPrompt() {
+        return null;
+    }
+
+    @Override
+    public WorldIdentifiers get1_16WorldNamesMap() {
+        return new WorldIdentifiers(WorldIdentifiers.OVERWORLD_DEFAULT);
+    }
+
+    @Override
+    public boolean cache1_17Light() {
+        return true;
+    }
+
+    @Override
+    public boolean isArmorToggleFix() {
+        return false;
+    }
+
+    @Override
+    public void reload() {
+    }
+
+    @Override
+    public void save() {
+    }
+
+    @Override
+    public void set(String s, Object o) {
+    }
+
+    @Override
+    public Map<String, Object> getValues() {
+        return Collections.emptyMap();
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaInjector.java b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaInjector.java
new file mode 100644
index 0000000000000000000000000000000000000000..85e87a54c9398479382ce25eb9091928128ce799
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaInjector.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.viaversion;
+
+import com.viaversion.viaversion.libs.gson.JsonObject;
+import com.replaymod.replaystudio.studio.ReplayStudio;
+import com.viaversion.viaversion.api.platform.ViaInjector;
+
+public class CustomViaInjector implements ViaInjector {
+    private final int serverProtocolVersion = new ReplayStudio().getCurrentFileFormatVersion();
+
+    @Override
+    public void inject() throws Exception {}
+
+    @Override
+    public void uninject() throws Exception {}
+
+    @Override
+    public int getServerProtocolVersion() throws Exception {
+        return serverProtocolVersion;
+    }
+
+    @Override
+    public String getEncoderName() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getDecoderName() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public JsonObject getDump() {
+        throw new UnsupportedOperationException();
+    }
+}
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaManager.java b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..d07f529649a0285834e41ff575d9eac737d01f91
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaManager.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.viaversion;
+
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.ViaManager;
+import com.viaversion.viaversion.api.command.ViaVersionCommand;
+import com.viaversion.viaversion.api.configuration.ConfigurationProvider;
+import com.viaversion.viaversion.api.connection.ConnectionManager;
+import com.viaversion.viaversion.api.debug.DebugHandler;
+import com.viaversion.viaversion.api.platform.ViaInjector;
+import com.viaversion.viaversion.api.platform.ViaPlatform;
+import com.viaversion.viaversion.api.platform.ViaPlatformLoader;
+import com.viaversion.viaversion.api.platform.providers.ViaProviders;
+import com.viaversion.viaversion.api.protocol.ProtocolManager;
+import com.viaversion.viaversion.api.scheduler.Scheduler;
+import com.viaversion.viaversion.debug.DebugHandlerImpl;
+import com.viaversion.viaversion.protocol.ProtocolManagerImpl;
+
+import java.util.HashSet;
+import java.util.Set;
+
+public class CustomViaManager implements ViaManager {
+    public static synchronized void initialize() {
+        // Exists only to trigger the static initializer
+    }
+
+    static {
+        CustomViaManager manager = new CustomViaManager();
+        Via.init(manager);
+        manager.protocolManager.registerProtocols();
+        manager.protocolManager.refreshVersions();
+        manager.initialized = true;
+    }
+
+    private final ProtocolManagerImpl protocolManager = new ProtocolManagerImpl();
+    private final ConnectionManager connectionManager = new CustomConnectionManager();
+    private final ViaProviders providers = new ViaProviders();
+    private final ViaPlatform<?> platform = new CustomViaPlatform();
+    private final ViaInjector injector = new CustomViaInjector();
+    private final Set<String> subPlatforms = new HashSet<>();
+    private final DebugHandler debugHandler = new DebugHandlerImpl();
+    private boolean initialized;
+
+    private CustomViaManager() {
+    }
+
+    @Override
+    public ProtocolManager getProtocolManager() {
+        return protocolManager;
+    }
+
+    @Override
+    public ViaPlatform<?> getPlatform() {
+        return platform;
+    }
+
+    @Override
+    public ConnectionManager getConnectionManager() {
+        return connectionManager;
+    }
+
+    @Override
+    public ViaProviders getProviders() {
+        return providers;
+    }
+
+    @Override
+    public ViaInjector getInjector() {
+        return injector;
+    }
+
+    @Override
+    public ViaVersionCommand getCommandHandler() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ViaPlatformLoader getLoader() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public Scheduler getScheduler() {
+        return null;
+    }
+
+    @Override
+    public ConfigurationProvider getConfigurationProvider() {
+        return null;
+    }
+
+    @Override
+    public DebugHandler debugHandler() {
+        return debugHandler;
+    }
+
+    @Override
+    public Set<String> getSubPlatforms() {
+        return subPlatforms;
+    }
+
+    @Override
+    public void addEnableListener(Runnable runnable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isInitialized() {
+        return initialized;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaPlatform.java b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaPlatform.java
new file mode 100644
index 0000000000000000000000000000000000000000..3ceb49a98f0bcaf9c4c2a366dfe0f4458d32781a
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/CustomViaPlatform.java
@@ -0,0 +1,138 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.viaversion;
+
+import com.viaversion.viaversion.api.ViaAPI;
+import com.viaversion.viaversion.api.command.ViaCommandSender;
+import com.viaversion.viaversion.api.configuration.ConfigurationProvider;
+import com.viaversion.viaversion.api.configuration.ViaVersionConfig;
+import com.viaversion.viaversion.api.platform.PlatformTask;
+import com.viaversion.viaversion.api.platform.ViaPlatform;
+import com.viaversion.viaversion.libs.gson.JsonObject;
+
+import java.io.File;
+import java.util.UUID;
+import java.util.logging.Logger;
+
+public class CustomViaPlatform implements ViaPlatform<Void> {
+    private CustomViaConfig config = new CustomViaConfig();
+
+    @Override
+    public Logger getLogger() {
+        return Logger.getLogger(CustomViaPlatform.class.getName());
+    }
+
+    @Override
+    public String getPlatformName() {
+        return "ReplayStudio";
+    }
+
+    @Override
+    public String getPlatformVersion() {
+        return null;
+    }
+
+    @Override
+    public String getPluginVersion() {
+        return "1.0";
+    }
+
+    @Override
+    public PlatformTask<?> runAsync(Runnable runnable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PlatformTask<?> runRepeatingAsync(Runnable runnable, long l) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PlatformTask<?> runSync(Runnable runnable) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PlatformTask<?> runSync(Runnable runnable, long aLong) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public PlatformTask<?> runRepeatingSync(Runnable runnable, long aLong) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ViaCommandSender[] getOnlinePlayers() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void sendMessage(UUID uuid, String s) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean kickPlayer(UUID uuid, String s) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isPluginEnabled() {
+        return true;
+    }
+
+    @Override
+    public ViaAPI<Void> getApi() {
+        return CustomViaAPI.INSTANCE.get();
+    }
+
+    @Override
+    public ViaVersionConfig getConf() {
+        return config;
+    }
+
+    @Override
+    public ConfigurationProvider getConfigurationProvider() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public File getDataFolder() {
+        return null;
+    }
+
+    @Override
+    public void onReload() {}
+
+    @Override
+    public JsonObject getDump() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public boolean isOldClientsAllowed() {
+        return false;
+    }
+
+    @Override
+    public boolean hasPlugin(String name) {
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/com/replaymod/replaystudio/viaversion/ViaVersionPacketConverter.java b/src/main/java/com/replaymod/replaystudio/viaversion/ViaVersionPacketConverter.java
new file mode 100644
index 0000000000000000000000000000000000000000..2df34e29cbdc6dcc4aea998923dd5fea10dae5bc
--- /dev/null
+++ b/src/main/java/com/replaymod/replaystudio/viaversion/ViaVersionPacketConverter.java
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2021
+ *
+ * This file is part of ReplayStudio.
+ *
+ * ReplayStudio is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * ReplayStudio is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with ReplayStudio.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.replaymod.replaystudio.viaversion;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.embedded.EmbeddedChannel;
+import com.github.steveice10.packetlib.tcp.io.ByteBufNetInput;
+import com.viaversion.viaversion.api.Via;
+import com.viaversion.viaversion.api.connection.ProtocolInfo;
+import com.viaversion.viaversion.api.connection.UserConnection;
+import com.viaversion.viaversion.api.protocol.ProtocolPathEntry;
+import com.viaversion.viaversion.api.protocol.packet.Direction;
+import com.viaversion.viaversion.api.protocol.packet.PacketWrapper;
+import com.viaversion.viaversion.api.protocol.packet.State;
+import com.viaversion.viaversion.api.protocol.version.ProtocolVersion;
+import com.viaversion.viaversion.connection.UserConnectionImpl;
+import com.viaversion.viaversion.protocol.ProtocolPipelineImpl;
+import com.viaversion.viaversion.api.protocol.ProtocolPipeline;
+import com.viaversion.viaversion.exception.CancelException;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.UUID;
+
+import static com.replaymod.replaystudio.replay.ReplayMetaData.PROTOCOL_FOR_FILE_FORMAT;
+
+/**
+ * Converts a sequence of packets from one version to another using ViaVersion.
+ * This class is stateful and packets must be processed in order.
+ */
+public class ViaVersionPacketConverter {
+    @Deprecated
+    public static ViaVersionPacketConverter createForFileVersion(int input, int output) {
+        return createForFileVersion(input, 0, PROTOCOL_FOR_FILE_FORMAT.get(output));
+    }
+
+    public static ViaVersionPacketConverter createForFileVersion(int fileVersion, int fileProtocol, int outputProtocol) {
+        if (!PROTOCOL_FOR_FILE_FORMAT.containsKey(fileVersion) && fileVersion < 10) throw new IllegalArgumentException("Unknown file version");
+        return createForProtocolVersion(fileVersion < 10 ? PROTOCOL_FOR_FILE_FORMAT.get(fileVersion) : fileProtocol, outputProtocol);
+    }
+
+    public static ViaVersionPacketConverter createForProtocolVersion(int input, int output) {
+        return new ViaVersionPacketConverter(input, output);
+    }
+
+    @Deprecated
+    public static boolean isFileVersionSupported(int input, int output) {
+        return PROTOCOL_FOR_FILE_FORMAT.containsKey(input) &&
+                PROTOCOL_FOR_FILE_FORMAT.containsKey(output) &&
+                isProtocolVersionSupported(PROTOCOL_FOR_FILE_FORMAT.get(input), PROTOCOL_FOR_FILE_FORMAT.get(output));
+    }
+
+    public static boolean isFileVersionSupported(int fileVersion, int fileProtocol, int outputProtocol) {
+        if (fileVersion < 10) {
+            if (!PROTOCOL_FOR_FILE_FORMAT.containsKey(fileVersion)) return false;
+            fileProtocol = PROTOCOL_FOR_FILE_FORMAT.get(fileVersion);
+        }
+        return isProtocolVersionSupported(fileProtocol, outputProtocol);
+    }
+
+    public static boolean isProtocolVersionSupported(int input, int output) {
+        if (input == output) return true;
+        CustomViaManager.initialize();
+        return Via.getManager().getProtocolManager().getProtocolPath(output, input) != null;
+    }
+
+    private final UserConnection user;
+    private final CustomViaAPI viaAPI;
+    private final ProtocolPipeline pipeline;
+    private List<ByteBuf> out = new ArrayList<>();
+
+    private ViaVersionPacketConverter(int inputProtocol, int outputProtocol) {
+        CustomViaManager.initialize();
+
+        List<ProtocolPathEntry> path = Via.getManager().getProtocolManager().getProtocolPath(outputProtocol, inputProtocol);
+        if (path != null) {
+            user = new DummyUserConnection();
+            viaAPI = new CustomViaAPI(inputProtocol, user);
+            pipeline = new ProtocolPipelineImpl(user);
+            ProtocolInfo protocolInfo = user.getProtocolInfo();
+            protocolInfo.setClientState(outputProtocol >= ProtocolVersion.v1_20_2.getVersion() ? State.CONFIGURATION : State.PLAY);
+            protocolInfo.setServerState(inputProtocol >= ProtocolVersion.v1_20_2.getVersion() ? State.CONFIGURATION : State.PLAY);
+            protocolInfo.setUsername("$Camera$");
+            protocolInfo.setUuid(UUID.randomUUID());
+            path.stream().map(ProtocolPathEntry::getProtocol).forEachOrdered(pipeline::add);
+        } else {
+            user = null;
+            viaAPI = null;
+            pipeline = null;
+        }
+    }
+
+    /**
+     * @deprecated Use {@link #convertPacket(ByteBuf,State)} instead.
+     */
+    @Deprecated
+    public List<ByteBuf> convertPacket(ByteBuf buf) throws IOException {
+        return convertPacket(buf, State.PLAY);
+    }
+
+    /**
+     * Converts the provided packet to the output protocol.
+     * @param buf The ByteBuf containing the packet, may be modified
+     * @return List of ByteBuf, one for each output packet, may be empty
+     */
+    public List<ByteBuf> convertPacket(ByteBuf buf, State state) throws IOException {
+        if (user == null) {
+            buf.retain();
+            return Collections.singletonList(buf);
+        }
+        CustomViaAPI.INSTANCE.set(viaAPI);
+        try {
+            int packetId = new ByteBufNetInput(buf).readVarInt();
+            PacketWrapper packetWrapper = PacketWrapper.create(packetId, buf, user);
+
+            try {
+                pipeline.transform(Direction.CLIENTBOUND, state, packetWrapper);
+            } catch (CancelException e) {
+                if (!out.isEmpty()) {
+                    return popOut();
+                } else {
+                    return Collections.emptyList();
+                }
+            }
+
+            ByteBuf result = buf.alloc().buffer();
+            packetWrapper.writeToBuffer(result);
+            if (!out.isEmpty()) {
+                out.add(0, result);
+                return popOut();
+            } else {
+                return Collections.singletonList(result);
+            }
+        } catch (IOException e) {
+            throw e;
+        } catch (Exception e) {
+            throw new IOException("Exception during ViaVersion conversion:", e);
+        } finally {
+            CustomViaAPI.INSTANCE.remove();
+        }
+    }
+
+    /**
+     * Returns {@link #out} and replaces it with a new list
+     * @return {@link #out}
+     */
+    private List<ByteBuf> popOut() {
+        try {
+            return out;
+        } finally {
+            out = new ArrayList<>();
+        }
+    }
+
+    /**
+     * User connection that pushes all sent packets into the {@link #out} list.
+     */
+    private final class DummyUserConnection extends UserConnectionImpl {
+        DummyUserConnection() {
+            super(new EmbeddedChannel());
+        }
+
+        @Override
+        public void sendRawPacket(ByteBuf packet) {
+            out.add(packet);
+        }
+
+        @Override
+        public void scheduleSendRawPacket(ByteBuf packet) {
+            out.add(packet);
+        }
+
+        @Override
+        public ChannelFuture sendRawPacketFuture(ByteBuf packet) {
+            throw new UnsupportedOperationException();
+        }
+    }
+}
